x.x.x.x.x := let type x = int in end
let type x = int in end
while x.x.x[for x := -() to if "totor" then nil else "totor" do -break].x(x.x.x.x(int {x = int {x = "totor", x = "totor"} } , new int), if (() ; 5) then x.x) do int {x = if if x.x("totor", "totor") then int {x = ()}  then let var x := 5 in end, x = x.x.x()/x.x.x()} 
function x(x : int) : int = int {x = 5-nil} 
function x(x : int, x : int) : int = -(5) class x extends int {var x := 5} 
var x := if () then break else "totor"
x()
x.x[let  in end].x[x(let var x := 5 in end, new int)]
class x {var x := 5}  class x extends int {var x := 5} 
int {} 
var x : int := let  in 5 end
new int
function x(x : int) = int {x = (5)}  function x(x : int) = let  in end
if (("totor" ; 5)) then int [x(x(int {x = "totor"} , while "totor" do nil), new int)] of for x := -nil to x := break do x()&while int {}  do x := break else let class x {}  import "empty.tih" in end
int {} 
class x extends int {var x := 5}  function x(x : int) = int {}  type x = int
(int {x = x[nil].x(x.x(), nil-5), x = -x.x(5, 5)}  ; while int [()] of break do x)
var x := x
int {} 
int {} 
x((int {x = x.x(5, break), x = int {x = (), x = nil} }  ; x() ; 5), int {} )
while while while x(x.x(), x((), break)) do x.x do for x := int {}  to x(x.x("totor", 5), int ["totor"] of 5) do new int do int [x.x[if break then break].x()] of if if int {}  then x.x(break, "totor") else x() then while x.x() do -nil
function x(x : int, x : int) = x.x
if while if x[nil] := x then x.x do ((5)) then (let var x := 5 in end ; ()&5 ; nil ; 5)
int {x = x.x.x.x := x(), x = x[nil][x(break, "totor")][x()]} 
class x {var x := 5 var x := 5} 
class x {var x := 5}  class x extends int {var x := 5}  type x = int var x := 5
-if let import "empty.tih" var x := 5 in int {x = nil, x = "totor"}  ; break ; 5 end then let var x := 5 var x := 5 in x.x((), ()) ; break ; 5 end
function x(x : int, x : int) : int = -x := "totor" class x extends int {var x := 5}  function x() : int = break import "empty.tih" var x := 5
-int {x = x(), x = x.x[let  in end].x(int [5/()] of x.x(), new int)} 
type x = int
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) = let var x := 5 in end
class x {var x := 5} 
if if x(for x := let  in end to let  in end do int {} , x.x.x()) then int {x = int [if 5 then 5 else 5] of x(break, ()), x = x[break].x()}  then for x := let var x := 5 in () ; 5 end to if 5 then nil|int [nil] of break do x(x := (), x := 5)&int {x = (5), x = -int [break] of "totor"}  else if int {} *x(int {x = 5} , let  in 5 end) then x(let var x := 5 in () end, let var x := 5 in end)
let class x extends int {var x := 5}  in new int/let var x := 5 in end ; (5) end
let function x(x : int) : int = if 5 then () else "totor" class x {}  import "empty.tih" var x := 5 in x(let  in end&(5), (())) ; -x end
class x {var x := 5}  class x {var x := 5}  class x {} 
x.x[int {} ][(())].x := x.x.x.x := -x[5] := int {x = 5, x = "totor"} 
x(let class x {}  var x := 5 in int {x = let  in end, x = x()}  end, int {x = if let var x := 5 in break ; 5 end then int [if 5 then "totor" else break] of if nil then 5 else nil} )
type x = {x : int} var x := break var x := 5
x.x.x[int {} ][int [x.x := x.x("totor", break)] of let  in end/let  in end] := x(int [x()] of new int, x(-let  in 5 end, (5)))
function x(x : int) = new int
int {x = let type x = int import "empty.tih" in end} 
(x[5].x)
let class x {var x := 5}  class x extends int {}  in end
x[break][x.x()].x[let import "empty.tih" var x := 5 in x.x() end]
class x {var x := 5 var x := 5}  type x = array of int class x extends int {}  import "empty.tih" var x := 5
function x(x : int) : int = x[5] := let  in 5 end
let function x(x : int) = int {x = ()}  in end
function x(x : int) = x[5] := int {x = (), x = 5}  class x extends int {var x := 5}  class x extends int {} 
x[()].x.x[int [while new int do let  in end] of x.x.x()]
int {x = -int {x = int [(5)] of new int} } 
class x {var x := 5 var x := 5}  var x : int := 5
function x(x : int, x : int) = for x := for x := "totor" to nil do break to if break then break else () do x()
function x(x : int) = int {}  type x = array of int function x() = ()
var x : int := if break then break class x {var x := 5}  var x := 5
new int
var x := new int
let function x(x : int) = x.x(5, 5) in x((5), int [nil] of break)|for x := int [nil] of "totor" to let  in end do (5) end
(int {}  ; for x := x to while 5 do 5 do int [nil] of 5)
class x {var x := 5} 
var x : int := x.x() var x := "totor" type x = int
type x = array of int
x.x[let  in 5 end].x.x
int {} 
class x {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5} 
class x {var x := 5}  type x = class {} function x() = break
int {} 
while x[break].x.x.x() do if if if if nil then 5 else () then int {x = break}  then x[()].x() else x.x.x(x.x(5, break), new int) then int {x = x[nil] := let  in end}  else x[5][-nil].x()
class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5}  var x : int := break
for x := int {x = int [x.x()] of while nil do (), x = x[()] := for x := 5 to break do break}  to x.x[x] := -int {x = "totor"}  do -x+let  in end*if int {x = new int}  then new int
class x {var x := 5 var x := 5} 
int {x = x[nil][int [5] of nil][let var x := 5 in "totor" ; 5 end].x()} 
var x := int {}  type x = array of int function x() : int = "totor"
-x.x.x.x
function x(x : int, x : int) = let var x := 5 in break end class x extends int {var x := 5} 
function x(x : int) : int = if x(nil, 5) then int {x = ()}  function x(x : int) : int = new int var x := 5 var x := 5 var x := 5
x[nil].x[if int [break] of 5 then x()]-(int [x.x("totor", "totor")] of new int ; int {}  ; "totor" ; 5)
function x(x : int) : int = int {x = -5} 
function x(x : int, x : int) : int = (break ; 5) function x(x : int) = if nil then 5 else 5
x()
if int {x = if (5) then -(), x = x(new int, new int)} *(int {x = 5, x = nil} ) then let function x() = 5 in end else (x[nil].x(x, x := ()))
function x(x : int) = x(int {x = ()} , x := break)
class x extends int {var x := 5 var x := 5}  var x := 5 function x() : int = "totor"
x[()][x()][x[()].x(for x := nil to break do (), (5))][x.x[x] := int {x = while break do nil} ]
int {} 
function x(x : int, x : int) : int = x["totor"] class x {var x := 5} 
for x := int {}  to let function x() : int = "totor" import "empty.tih" var x := 5 in end do if if int {x = x.x(), x = let  in end}  then int {}  else (break ; 5) then if while if () then nil else break do int ["totor"] of 5 then int [for x := "totor" to break do break] of let  in 5 end else x()
var x := int ["totor"] of "totor" class x extends int {var x := 5} 
int [x()] of for x := int {}  to new int do (()&"totor")
int {} 
var x := (5) function x(x : int) = let  in 5 end function x() = nil var x := 5
x.x.x[let var x := 5 in nil end].x.x(x[break].x[new int].x(int {x = if -5 then 5*nil else while () do "totor"} , x(x[()].x(int {x = "totor"} , new int), nil|5|new int)), -x())
var x : int := x.x() function x(x : int) : int = x var x := 5 var x := 5 var x := 5
int {x = int [x.x.x] of int {x = x[break] := int {} } } 
var x := let  in end
class x extends int {var x := 5} 
type x = class {var x := 5}
type x = class {var x := 5} function x(x : int) = x.x()
x["totor"].x[x(x.x(), while nil do "totor")][x(x(), x.x := ()/5)] := x.x[int {x = 5, x = "totor"} ][x[()].x(x.x(nil, 5), for x := break to 5 do 5)].x()
if int {x = for x := while let  in 5 end do x.x() to int {}  do (nil ; 5)}  then while x(int [x := ()] of x := (), x.x.x(int {} , x)) do int {}  else new int
function x(x : int, x : int) : int = if let  in end then -break else let  in end function x(x : int) = (5)
x.x.x[int [-()] of let  in end].x := let type x = int import "empty.tih" in int {}  ; int {}  end
x[()][x][if x then let  in 5 end].x.x(x[()][-5][int {x = int {x = "totor"} } ] := if let var x := 5 in end then while -nil do int [nil] of 5, int {} )
(int {x = x[break].x(), x = x.x.x(int {x = break, x = 5} , let  in end)}  ; -nil|int {x = 5, x = 5} )
new int
class x extends int {var x := 5 var x := 5} 
function x(x : int) : int = let var x := 5 in end
class x {var x := 5 var x := 5} 
x[()].x.x.x
x()
(int {x = int [for x := () to () do ()] of while break do 5}  ; -if break then () else ())
int {x = let class x extends int {}  in end} 
var x := x.x() function x(x : int) : int = int {}  function x() = "totor"
x[()][nil-nil][x[()].x()].x := int {} 
int {} 
int [x[5].x[x.x := new int]] of x.x[let  in 5 end][int [(5)] of for x := nil to nil do "totor"].x(int {x = int [int [5] of "totor"] of int [()] of ()} , int [x((), nil)&int {x = nil, x = ()} ] of -x := 5)
class x extends int {var x := 5}  type x = array of int type x = int
type x = int
function x(x : int) = x["totor"].x(x.x((), break), if 5 then nil) function x(x : int) = x := break class x {} 
let class x extends int {var x := 5}  in end
var x : int := new int class x {var x := 5} 
-for x := let import "empty.tih" var x := 5 in end to x[5].x := let  in 5 end*int [break] of nil do int {x = let var x := 5 in nil end} 
x.x.x[int [if nil then "totor" else "totor"] of int [()] of ()].x := x["totor"][while () do nil][int {x = for x := "totor" to break do 5} ]
int {x = x(), x = int [if x.x.x(5/5, int {} ) then int {} ] of let import "empty.tih" in end} 
var x : int := x() function x(x : int) : int = x := nil type x = int
type x = int
var x := int {x = 5} 
for x := x(while int {x = int {x = nil} }  do x(), -int {x = let  in end, x = x()} ) to let function x() : int = break var x := 5 in int {x = int {x = nil} , x = x.x(break, "totor")}  end do new int
function x(x : int, x : int) = int [x()] of while break do break type x = class {} function x() : int = break var x := 5
x.x.x.x[x[break].x.x()] := (int {x = int [5] of (), x = let  in end}  ; int {}  ; () ; 5)
x()
x()
x()
class x extends int {var x := 5}  type x = int
function x(x : int, x : int) : int = if while 5 do "totor" then int {} 
x[5].x[x.x := while 5 do break][let import "empty.tih" in end].x()
var x : int := if 5 then 5 function x(x : int) : int = x.x() type x = int
new int
class x extends int {var x := 5} 
x.x[let  in 5 end].x.x.x()
type x = array of int
int {x = x.x.x.x := if ()&break*if nil then break else break then x.x.x(), x = int {x = int {x = let var x := 5 in () end} , x = int [(nil ; 5)] of let var x := 5 in 5 end} } 
function x(x : int, x : int) : int = int {x = -()}  type x = class extends int{} type x = int
function x(x : int) = int {}  function x(x : int) = "totor"|5
type x = {x : int} class x {var x := 5} 
class x extends int {var x := 5} 
int {x = (int {}  ; int {x = "totor", x = "totor"}  ; break ; 5)} 
x.x.x.x[x[()].x.x(int {x = (5), x = ()-"totor"} , int {x = int {x = (), x = "totor"} , x = int {x = nil} } )].x(for x := if if new int then while () do "totor" then x.x := int {x = (), x = nil}  to int [int {x = x("totor", 5)} ] of while let  in 5 end do int {x = (), x = 5}  do x["totor"][new int], int {} )
x.x[let  in end].x[x.x.x.x(-x, if new int then if () then nil else nil else x())].x()
int {x = let class x {}  var x := 5 var x := 5 in let var x := 5 in break ; 5 end ; x.x() end} 
function x(x : int, x : int) = x["totor"]
var x := if 5 then "totor" else () class x {var x := 5}  class x extends int {} 
function x(x : int) : int = x.x.x() var x : int := nil class x {}  import "empty.tih"
-while int {}  do int [x(while () do break, x.x())] of int {x = int [5] of "totor", x = while break do 5} 
class x {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) : int = x class x {}  import "empty.tih" var x := 5
function x(x : int, x : int) = let var x := 5 in end
for x := for x := (x((), break) ; () ; 5) to -x() do let var x := 5 var x := 5 in end to x(if int {x = if 5 then ()}  then if "totor" then ()-int {} , (if 5 then nil)) do int {x = int {} } 
function x(x : int, x : int) = if -break then x := () else x(nil, break)
class x {var x := 5 var x := 5}  class x {var x := 5} 
function x(x : int) : int = if (5) then int {x = "totor", x = ()} 
int [(int {} )] of int {x = if let var x := 5 in "totor" ; 5 end then int {x = x.x(break, ())} , x = for x := x-if 5 then nil to let var x := 5 in end do x.x()-int {} } 
let class x {var x := 5}  function x() = nil in end
x(while new int do int {x = let var x := 5 in () ; 5 end} , x.x[int {x = (), x = 5} ].x)
x.x[x(nil, 5)][let var x := 5 in () end].x := let type x = int in let var x := 5 in 5 ; 5 end end
for x := (new int ; while nil do nil ; 5 ; 5) to int [if int {x = x.x(nil, 5)}  then x[5].x(x := nil, let  in end) else x[()].x()] of new int do x.x.x.x.x()
new int
function x(x : int, x : int) : int = let var x := 5 in end
type x = int
x()
var x : int := (5)
if if -let var x := 5 in end then new int else if x[break] then int {x = int {} , x = int {x = 5} }  then int {x = let import "empty.tih" in end} 
int {} 
type x = array of int class x {var x := 5}  class x {} 
var x := while nil do break
if x() then let class x extends int {}  var x := 5 var x := 5 in end else x.x[for x := break to 5 do break].x := int [if x then x() else let  in end] of let var x := 5 in 5 end
for x := new int to -let var x := 5 in end|x(if () then "totor", if break then "totor" else ()) do (while int {x = (), x = ()}  do x())
let var x := 5 in end
if x[5].x.x.x() then new int
x[nil][while 5 do nil].x.x := while while (()) do x() do x.x[x(break, 5)].x(let var x := 5 in break ; 5 end, new int|x())
let type x = int in int [new int] of x.x.x(int [nil] of "totor", (5)) end
function x(x : int) : int = x()
class x {var x := 5}  class x {var x := 5}  class x extends int {}  var x := 5
for x := if let var x := 5 in () end then if new int then let  in 5 end else x(5, ()) to x(new int, x(nil/break, for x := () to "totor" do ())) do x.x.x-int [if int {x = new int, x = -5}  then -new int] of if int [int {} ] of x.x() then x[5] := new int else int {x = x, x = if break then 5 else ()} 
type x = {x : int}
function x(x : int, x : int) : int = x() var x := nil
let class x extends int {var x := 5}  function x() : int = break in end
if for x := -x((), break)*break&"totor" to int [int {} ] of x(let  in 5 end, x()) do int {x = x[5]}  then -x()
x(--int [(5)] of let  in 5 end, x(x.x, x())&for x := if int {x = ()}  then x.x() else for x := "totor" to nil do break to x() do for x := int {x = break}  to if 5 then nil do int {x = nil} )
class x {var x := 5 var x := 5} 
x.x.x.x.x.x()
function x(x : int) : int = -x := ()
class x extends int {var x := 5 var x := 5} 
x(x.x.x.x, int {x = if x(x.x((), nil), let  in 5 end) then int {} } )
x.x[let  in end].x[let var x := 5 in let  in end end].x()
int {x = while int {x = x(if break then () else nil, int {} ), x = x(x(nil, break), x.x())}  do int {} , x = while if (break ; 5) then new int else int {x = x, x = int [()] of break}  do x()} 
class x extends int {var x := 5} 
class x {var x := 5} 
int {} 
function x(x : int) : int = int {x = let  in end, x = new int}  function x(x : int) = let  in end
-x.x[if () then () else ()].x := if x.x.x(int {x = "totor"} , x := break) then x[nil].x(x.x(nil, 5), -5)
int {} 
function x(x : int, x : int) = while () do break|int {x = "totor"}  function x(x : int) = int [break] of break function x() = ()
function x(x : int, x : int) : int = new int
x(x(), let type x = int var x := 5 var x := 5 in int {}  ; x ; "totor" ; 5 end)
let type x = class extends int{} in int {}  end
int [for x := -new int to while int {}  do new int do let import "empty.tih" var x := 5 in new int ; "totor" ; 5 end] of x.x[-nil][let  in 5 end+int [break] of nil].x(x[5].x.x(), x(int {x = let  in end} , let var x := 5 in end))
if x.x.x[new int] := x["totor"][if nil then ()].x() then x(if int [int {} ] of new int then int {x = let  in end, x = let  in 5 end} , --while () do "totor") else if while while int {x = (), x = ()}  do int [5] of () do let var x := 5 in end then int {x = for x := x.x() to for x := break to nil do nil do nil+"totor"}  else int [x.x := x.x()] of while new int do while 5 do break
var x := int [break] of 5
x(let class x extends int {}  var x := 5 in let var x := 5 in end end, x(for x := x.x.x() to -x.x() do int {x = int {x = break} , x = (5)} , int {x = while int [nil] of nil do (5), x = x[nil].x()} ))
if for x := x["totor"].x to int [x.x.x(if nil then 5 else break, int {} )] of new int do let import "empty.tih" in int {x = 5}  end then x()
function x(x : int) = new int
let type x = int function x() : int = break import "empty.tih" in int [while () do ()] of if 5 then 5/if let  in end then for x := nil to nil do nil else int [()] of nil end
class x extends int {var x := 5}  function x(x : int) : int = if 5 then () class x extends int {}  var x := 5
class x {var x := 5 var x := 5} 
x[break][if "totor" then break][int {} ][-int ["totor"] of ()+x.x]
let var x := 5 class x extends int {}  in let var x := 5 in x := "totor" ; () ; 5 end ; let  in 5 end*for x := nil to "totor" do "totor" end
function x(x : int) : int = for x := x("totor", break) to x.x() do while 5 do "totor"
var x := if () then "totor" else 5 function x(x : int) : int = new int
class x {var x := 5} 
if x.x[x("totor", ())].x.x() then x.x[x.x()][let var x := 5 in break end].x()
x[5][if nil then 5][int {x = ()/"totor"} ].x.x(x()/int {} , new int)
type x = {x : int}
function x(x : int, x : int) = x(int {} , int {x = 5} ) var x := 5 function x() : int = nil import "empty.tih" var x := 5
x[()].x[while -"totor" do int {x = "totor", x = ()} ].x.x(int {x = new int} , int {x = -if x then x.x()} )
class x {var x := 5}  class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
new int
while -x() do x.x.x.x := -if x() then -"totor"
var x := int {} 
function x(x : int) : int = new int class x {var x := 5}  function x() = "totor"
int {x = let type x = int in end} 
class x extends int {var x := 5}  class x {var x := 5} 
function x(x : int, x : int) : int = (() ; 5) class x {var x := 5}  class x extends int {}  var x := 5
while x[nil][(5)].x := let var x := 5 in nil end-(break) do x.x["totor"*5][let var x := 5 in end] := (x.x() ; break ; 5)
function x(x : int) : int = x()
class x {var x := 5} 
(int [(() ; 5)] of int {}  ; for x := "totor"*5 to int {}  do break-"totor")
for x := x[break].x[-new int] := new int to x()-int {}  do let type x = int in end
let function x(x : int) : int = x((), ()) in int {}  end
x.x[while "totor" do ()][if int ["totor"] of "totor" then new int][(x() ; break)]
class x {var x := 5} 
function x(x : int) : int = x(x, if nil then break else 5)
x.x.x.x[x(x[nil].x(int {x = break, x = ()} , int {x = "totor"} ), int {x = (5)} )].x(int {} , int {x = x[()].x := (break)} )
function x(x : int) = x["totor"]
type x = array of int
function x(x : int, x : int) : int = x(int [()] of nil, new int)
if if -new int then int {x = x.x.x()}  then new int else x()
int [if if if while () do nil then while 5 do "totor" then new int else -(5) then while x["totor"] := int ["totor"] of 5 do x.x.x(break-nil, int [break] of break) else if while x.x() do if () then nil then x(x, let  in end)] of x.x[x.x()].x.x()
x.x.x[if x.x() then x.x(break, "totor") else int {x = "totor", x = nil} ].x.x(let import "empty.tih" var x := 5 in end&x[break][(5)].x(), let class x extends int {}  import "empty.tih" in end)
type x = class {var x := 5}
function x(x : int, x : int) : int = let var x := 5 in nil end class x extends int {var x := 5}  type x = int var x := 5 var x := 5
function x(x : int) : int = if if nil then nil then x() else int {} 
for x := x[break][int {} ].x to x.x.x[x[()].x()] do while let import "empty.tih" var x := 5 in end do x()
if for x := let var x := 5 in end to int {x = let  in 5 end*-nil, x = let var x := 5 in end}  do x.x[for x := 5 to nil do "totor"] := if int {x = nil, x = ()}  then while break do nil else let  in 5 end then int {x = let var x := 5 in end, x = int {x = new int&nil|"totor"} }  else int {x = int {x = int {x = 5} } , x = x()} +let import "empty.tih" in -5 end
int {} 
x.x.x[x(x.x(), x.x())].x.x(if x.x[int {x = "totor"} ] then for x := x.x := x() to if x := break then int {x = nil, x = "totor"}  else let  in 5 end do while x.x(5, 5) do let  in end else for x := let var x := 5 in end to x.x := int {}  do if let  in 5 end then int {}  else while nil do 5, new int)
--x[break][for x := nil to () do nil] := x[break] := x.x(5, ())
while x.x[-nil].x := int [for x := x("totor", nil) to -() do int {} ] of int {x = x := break}  do x["totor"].x[new int|x.x(5, ())] := int [int [new int] of int {} ] of x["totor"] := let  in 5 end
new int
type x = class {var x := 5} function x(x : int) : int = x := ()
x.x[x.x((), break)].x.x := if x(int {x = int {x = 5, x = 5} } , if while 5 do nil then x.x("totor", "totor") else int [break] of nil) then x(x(), if let  in end then x()) else x[5].x := x()
function x(x : int, x : int) = for x := int ["totor"] of nil to x(nil, break) do x() class x {var x := 5} 
var x : int := let  in end function x(x : int) = int [break] of nil
let class x extends int {var x := 5}  class x extends int {}  in end
x(x(), int [if for x := 5/5 to int {}  do let  in 5 end then if "totor" then ()+if "totor" then break] of if int {x = new int}  then -x("totor", 5))
if for x := new int to x.x[if () then "totor" else nil].x() do x["totor"][(5)].x() then if x(int {x = 5|(), x = x()} , x()) then let import "empty.tih" in end else if if "totor" then 5 else 5 then x else x((), nil)+let var x := 5 in nil end
-int [int {x = x.x} ] of (x := nil ; break)
x()
while x.x.x.x do for x := int {x = let  in 5 end, x = x()}  to for x := x() to -"totor" do x(break, break) do x[()].x()*int {} -(break)
var x : int := let  in 5 end function x(x : int) = int {} 
int [if x[nil].x then if x() then if x() then x() else x.x else -let var x := 5 in nil ; 5 end] of if if x(let  in end, int {} ) then int {}  then x["totor"][x := 5].x()
function x(x : int, x : int) : int = new int
-for x := x() to x() do x.x.x := if ()|"totor" then let  in 5 end else int {x = 5, x = ()} 
class x {var x := 5}  var x : int := nil var x := 5
let class x extends int {var x := 5}  in int {}  ; x(x("totor", break), x((), "totor")) end
function x(x : int, x : int) : int = int {x = let  in end} 
function x(x : int) : int = int {x = x(), x = for x := 5 to break do break} 
x.x.x.x[if (5) then int [x := break] of int {x = "totor"} ]
function x(x : int, x : int) : int = int [x.x(nil, ())] of x.x("totor", break)
var x : int := if break then break else ()
let class x extends int {var x := 5}  in if int {x = (5)}  then if while () do nil then let  in end else int {}  end
for x := for x := let var x := 5 in int {x = "totor"}  end to new int do (int [5] of () ; break ; 5) to let function x() = break in end do for x := (x() ; () ; 5) to for x := let  in end+x := 5 to for x := new int to x() do x.x() do x.x.x() do x[break].x.x()
class x extends int {var x := 5 var x := 5}  var x := break function x() = 5 import "empty.tih"
int {} 
type x = {x : int}
int {} 
for x := -x[nil][nil&()].x() to x[5].x[int {} ].x() do (int {} )
x()
class x extends int {var x := 5 var x := 5} 
for x := x() to for x := if x[nil].x() then int {x = int {x = (), x = break} }  to if if (5) then while "totor" do () then x.x.x(new int, x(5, ())) do new int do x(int [x()] of x((5), -"totor"), while x.x.x(if () then 5, 5/nil) do if x.x() then (5) else -5)
function x(x : int) : int = for x := x(break, "totor") to if 5 then () else () do (5)
while let function x() = break in end do int [int {} ] of x()
var x : int := int {} 
var x : int := x := 5 var x : int := "totor"
x(int [(x := () ; break ; 5)] of -let  in end/(5), if int {x = x.x.x()}  then x[break].x.x())
function x(x : int) : int = x.x var x := 5
x(let class x extends int {}  import "empty.tih" var x := 5 in end, int {x = x[break].x, x = x.x.x.x(for x := "totor"/nil to x.x() do x(), -x.x())} )
int {x = -let var x := 5 in end-if if nil then () else () then int {}  else x, x = if x(x.x, x[5]) then (let  in 5 end) else -x.x.x(x := "totor", new int)} 
if int {}  then while new int do for x := -for x := nil to () do () to x() do for x := let  in 5 end to if 5 then "totor" do if break then 5 else 5
class x {var x := 5}  class x {var x := 5}  class x {}  var x := 5
int {} 
x.x[(5)][(break)].x.x(x[nil][x.x()][x[()] := x.x((), ())].x(), int {} )
class x {var x := 5 var x := 5} 
type x = class {var x := 5} function x(x : int) : int = x
for x := x[break][x.x()][(5)].x() to let class x extends int {}  in end do let function x() : int = 5 import "empty.tih" var x := 5 in int {} /let  in end ; x() ; () end
class x {var x := 5 var x := 5} 
-x[()].x[x.x]
x[()].x.x.x.x(int {x = int [x[break].x()] of x["totor"].x(), x = int [-int {x = "totor", x = nil} ] of int {x = x := nil} } , x[nil][nil&nil][for x := while () do 5 to let  in end do if 5 then "totor"])
let function x(x : int) = for x := break to 5 do 5 function x() = () var x := 5 var x := 5 in end
x(if (nil&break) then x[5].x := while if nil then nil do if "totor" then () else "totor", if int {x = for x := x(5, 5) to int {x = "totor"}  do int [5] of break, x = for x := (5) to -nil do let  in end}  then -for x := () to "totor" do "totor"|x(x := 5, if nil then "totor" else nil) else x[break].x.x())
type x = class extends int{var x := 5}
int [x["totor"].x.x.x()] of if int {}  then x()
class x extends int {var x := 5}  type x = array of int
class x extends int {var x := 5 var x := 5}  var x := ()
type x = int
class x extends int {var x := 5 var x := 5} 
while x[()][let  in end].x.x(let var x := 5 in while "totor" do nil end, -x()) do (-x(5, nil))
function x(x : int) = let var x := 5 in end type x = array of int class x extends int {} 
function x(x : int, x : int) = let var x := 5 in () end function x(x : int) = int [5] of nil function x() : int = "totor"
class x {var x := 5 var x := 5} 
if x(x(), x["totor"].x := int {x = x((), nil)} ) then x.x[if () then break][let  in 5 end&int {x = break, x = ()} ].x((new int ; ()), for x := int {}  to let var x := 5 in end do x())
type x = int
let var x : int := nil in if int {x = x.x(), x = ()/5}  then int {}  end
class x {var x := 5}  type x = class {} var x := 5
x(new int, while while if int [5] of () then int {}  else while "totor" do "totor" do if if nil then "totor" then int {}  do int [x.x.x(int [break] of break, int {x = 5} )] of x[break] := x.x())
class x extends int {var x := 5 var x := 5} 
var x := int {} 
class x extends int {var x := 5} 
var x := for x := () to nil do 5
int {x = x(), x = new int} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = x(nil, 5) var x := 5
-if int {x = x} +if nil then nil else 5*x.x((), "totor") then x(x[5].x(new int, (5)), while int {x = 5, x = ()}  do ()/nil)
x(int {x = x(new int, int {x = let  in end, x = nil&nil} )} , while x[nil].x(x.x((), break), (5))/if if break then "totor" then let  in end do if for x := int ["totor"] of break to if break then () else "totor" do x := 5 then new int)
function x(x : int) : int = int {x = x.x(), x = for x := 5 to 5 do ()}  type x = class extends int{} class x {}  import "empty.tih"
class x {var x := 5 var x := 5} 
function x(x : int) : int = ("totor" ; 5)
int [int [x.x.x := x.x.x()] of x()] of if (int {}  ; break) then x.x.x.x() else int [x(x(), x := 5)] of while x.x(5, 5) do if () then ()
function x(x : int, x : int) = if x.x() then x() else int {x = break}  function x(x : int) : int = x.x()
var x := -5
function x(x : int, x : int) = new int
-if x["totor"][x("totor", ())].x(x(new int, x := "totor"), x.x := x := break) then (x := "totor") else let var x := 5 var x := 5 in end
x[break][new int].x[int [x.x((), ())] of (5)+x[5]]
function x(x : int) = x["totor"].x(x, int ["totor"] of break)
class x extends int {var x := 5}  type x = {} function x() = break var x := 5 var x := 5
if x[5][if nil then nil][let var x := 5 in () end] := if x[break] then let var x := 5 in nil end else for x := if "totor" then () to (5) do for x := () to break do nil then int {x = x.x.x(int {x = (), x = "totor"} , int [break] of 5), x = int {x = x((), nil), x = x} } &x()
class x extends int {var x := 5}  function x(x : int) = break|"totor" var x := 5 var x := 5
function x(x : int, x : int) : int = x.x.x() type x = {}
var x : int := let  in 5 end class x extends int {var x := 5}  class x {}  import "empty.tih"
(x[break].x)
new int
var x : int := if () then nil else 5
class x extends int {var x := 5}  class x {var x := 5}  class x {}  var x := 5
class x {var x := 5 var x := 5} 
class x extends int {var x := 5} 
x[()].x.x+for x := (let  in end ; () ; 5) to let var x := 5 in end do int {} 
x[5].x[x(int {x = nil, x = "totor"} , (5))][let var x := 5 var x := 5 in end].x(int {x = x.x[int {} ], x = (x := 5 ; 5)} , let class x extends int {}  import "empty.tih" var x := 5 in for x := if 5 then () to int {}  do -break end)
new int
x(-x.x.x.x(), new int)
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  function x() = ()
class x {var x := 5}  var x := 5
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) = new int class x {var x := 5} 
function x(x : int) = (break ; 5)
x[break][if break then 5][if for x := () to nil do nil then x.x(break, ()) else while () do 5][int {} ].x(x[nil][int [nil] of nil].x.x(), let class x extends int {}  in end)
x(int [while int {x = (5), x = int {} }  do x[break] := new int] of int {x = while let  in end do new int} , let class x {}  in end)
new int
-int {} 
function x(x : int, x : int) = x[()].x(-"totor", x.x()) class x {var x := 5} 
x()
for x := let function x() = "totor" var x := 5 var x := 5 in end to for x := if x.x then x[break] := let  in end to for x := x.x.x(int {x = nil} , int {x = (), x = ()} ) to if new int then while nil do 5 else int {x = break}  do int {x = let  in 5 end}  do x.x[x.x((), ())] do x[5].x[int [x := "totor"] of x.x()].x()
if x(int {x = if for x := 5 to "totor" do "totor" then x, x = x.x.x()} , for x := x["totor"].x() to x["totor"] do x[break].x()) then int {x = let var x := 5 var x := 5 in x.x(break, "totor") ; "totor" ; 5 end, x = int {x = if if 5 then () then (5) else (5)} }  else if if int {}  then int {x = x(5, "totor"), x = new int}  else -x(nil, nil) then let import "empty.tih" var x := 5 in x.x() ; 5 end
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  type x = int var x := 5
var x : int := let  in end class x extends int {var x := 5}  class x extends int {}  var x := 5 var x := 5
class x {var x := 5 var x := 5} 
if x(x[5].x()-new int, for x := x() to for x := int {x = "totor", x = nil}  to -5 do x.x(break, "totor") do x()) then x["totor"][new int].x.x()
int {} 
x()
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
int {x = -let var x := 5 in nil ; 5 end} |let type x = int in (nil ; 5) end
class x {var x := 5}  type x = array of int function x() : int = () var x := 5
int {} 
function x(x : int) : int = int {x = let  in end, x = x.x(5, break)} 
x["totor"].x.x.x := int {x = (if nil then () ; break)} 
int {x = int {x = x[5][let  in 5 end], x = let import "empty.tih" in end} } 
class x extends int {var x := 5 var x := 5} 
function x(x : int) = x.x.x()
x[nil].x.x[int {x = int {} } ].x(for x := x.x[while nil do "totor"].x(int {x = int [break] of nil, x = int {x = 5, x = nil} } , int {x = new int, x = if "totor" then ()} ) to int {}  do x[5][x(nil, nil)].x(new int, x["totor"].x()), x[nil].x := x.x&for x := x[()] to x.x.x(let  in end, if 5 then "totor" else ()) do if if "totor" then 5 then int [nil] of nil else if break then ())
type x = class {var x := 5} class x {var x := 5}  class x extends int {}  import "empty.tih"
for x := (x.x.x() ; int [()] of break ; () ; 5) to if int {x = x.x := -nil}  then int [-let  in end] of x["totor"] do while let var x := 5 var x := 5 in new int ; 5 ; 5 end do x[nil].x.x(if x(5, ()) then -break else x(5, nil), x())
class x extends int {var x := 5 var x := 5}  var x := ()
class x extends int {var x := 5}  var x := break
(int {} )
x()
function x(x : int) = while int {x = ()}  do x((), nil) type x = int class x extends int {}  var x := 5 var x := 5
x.x.x[if x then let  in end else -break].x.x()
class x {var x := 5 var x := 5} 
let type x = {} in end
(if -let  in end then if for x := 5 to 5 do nil then if 5 then nil)
((int {x = ()} ) ; let var x := 5 in nil end)
int {x = x()} 
int [if x(int [nil+break] of x(break, break), int [let  in end] of x.x("totor", nil)) then x[nil][int [nil] of ()].x(x[nil].x(x, let  in 5 end), x["totor"] := int {} ) else x[5][while nil do nil].x()] of new int
while x() do x.x.x.x := x.x[-nil]
int {} 
function x(x : int) : int = if int [nil] of 5 then if break then break else let  in end function x(x : int) : int = let  in 5 end class x extends int {}  var x := 5 var x := 5
class x {var x := 5} 
function x(x : int, x : int) = x.x class x {var x := 5} 
if int {}  then if for x := x() to int {}  do if x() then new int else let  in 5 end then x[()][x := ()] else for x := let  in 5 end to x do x("totor", 5)|(() ; 5) else int [x(while x(break, "totor") do let  in 5 end, -x)] of let import "empty.tih" in let  in end ; break end
class x extends int {var x := 5} 
if x() then int {} 
x.x[int ["totor"] of "totor"].x.x.x(int {} , if int {x = "totor"} *for x := () to break do break then -x := ()&int {} )
while x[nil].x.x do int {x = x.x.x.x(), x = (x.x() ; "totor" ; 5)} 
function x(x : int) = if x then int {x = 5}  var x := ()
function x(x : int, x : int) : int = x["totor"].x()
x[()].x[if new int then x(nil, nil)][for x := x() to int {x = x.x(nil, 5)}  do -int {x = "totor", x = "totor"} ].x()
new int
int {} 
x[5][if () then ()][x(int {x = break, x = ()} , x())].x
x[break].x.x.x := new int
function x(x : int, x : int) : int = int [int {} ] of if 5 then ()
let type x = int in end
x[nil].x[while int {x = break, x = break}  do int {x = (), x = "totor"} ][int [if new int then if "totor" then 5] of if -() then int {x = break, x = 5} ] := while x.x[int {} ].x(int {} , int {x = x.x(), x = x.x()} ) do x(int {x = -"totor"} , int {x = x.x(break, nil)} )
function x(x : int) = x.x.x()
function x(x : int) = int [new int] of (5) function x(x : int) = for x := break to () do 5 class x {} 
class x {var x := 5}  function x(x : int) : int = x.x(nil, ()) class x {} 
function x(x : int) = x.x.x()
x["totor"].x[let var x := 5 in end].x.x(x[nil][(5)].x := new int, x())
class x extends int {var x := 5} 
function x(x : int) = x()
type x = class {var x := 5}
type x = array of int type x = {}
function x(x : int) = while while "totor" do "totor" do if nil then () else "totor" type x = class extends int{}
-int {x = if let var x := 5 in () end then --(), x = x[nil].x.x(while while nil do break do (5), int {x = x} )} 
x.x.x.x[x.x[let  in end] := new int*for x := "totor" to "totor" do nil].x(x[5].x*-x["totor"].x(), x["totor"][while 5 do ()].x := for x := if let  in end then int {x = nil, x = nil}  to int [for x := () to nil do "totor"] of int {x = (), x = nil}  do for x := x.x() to int {x = "totor", x = nil}  do for x := 5 to "totor" do break)
x.x[int {} ].x.x
let var x := nil in end
x(int {} , let var x := 5 var x := 5 var x := 5 in x.x.x() end)
int {x = if (for x := nil to "totor" do break) then x.x&int {} , x = int {x = x.x.x := x[5] := -"totor"} } 
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  class x extends int {} 
x[nil][x()][(5 ; 5)].x := x[()][x.x()].x
let function x(x : int) = if "totor" then nil else break function x() : int = break import "empty.tih" var x := 5 in while (nil) do int {x = int {} , x = int [5] of ()}  end
for x := int {x = x[break].x}  to x[()].x.x.x(x["totor"][x].x(new int, x[nil].x(x(nil, break), int {} )), if for x := int ["totor"] of "totor" to int ["totor"] of () do int [nil] of () then x.x else x()) do x(-let var x := 5 in 5 end, x["totor"][int {x = break, x = "totor"} ])
type x = int class x extends int {var x := 5}  function x() : int = "totor" import "empty.tih" var x := 5
x.x.x[int {x = for x := () to 5 do break} ][if new int then let  in 5 end else x.x(break, 5)|x(x(break, break), x)].x(int {x = for x := x.x to for x := for x := 5 to break do 5 to x() do if "totor" then "totor" do int {} } , if int {x = x.x(), x = for x := nil to () do "totor"} +int {x = new int, x = let  in end}  then if int {x = int {x = 5} }  then int [x] of let  in end else for x := x() to for x := int [5] of 5 to x := 5 do x(5, "totor") do x["totor"].x(while nil do "totor", int {} ))
var x : int := x(break, break) type x = class {} class x extends int {} 
x[nil]["totor"+()][for x := let  in end to for x := break to () do break do x][int {x = ("totor" ; 5)} ] := x[nil][if 5 then 5][int [let  in 5 end] of for x := break to nil do ()] := int {x = int [int {} ] of x.x((), break)} 
x[nil].x[int [5+5] of int {} ].x.x(x[5].x[x()].x(), if for x := for x := int {x = 5}  to x.x() do x(5, "totor") to x.x := if nil then break do while int {x = "totor", x = 5}  do int {x = 5}  then let import "empty.tih" in end else int {} )
type x = int function x(x : int) : int = let  in end class x {}  import "empty.tih" var x := 5
var x := x
var x := int {x = 5}  class x {var x := 5} 
if (x.x.x()) then let class x {}  in int {x = -nil, x = x(5, nil)}  end else (let var x := 5 in break end ; int {x = 5, x = ()} )
if int [for x := x[break] to x.x := new int do int {x = (5)} ] of int {x = x[nil].x()}  then x[break][int [()] of ()].x()*let var x := 5 var x := 5 in end
for x := new int to while new int do x() do if ((5)) then let var x := 5 in int {}  ; "totor" end
x()
type x = int
var x : int := x.x(break, "totor") function x(x : int) = new int class x extends int {}  var x := 5 var x := 5
var x : int := if 5 then break
int {x = x.x.x.x.x()} 
class x {var x := 5 var x := 5} 
(int {x = if while break do nil then x(nil, 5) else x} )
function x(x : int, x : int) = x.x.x(new int, int [5] of 5) type x = {}
function x(x : int, x : int) : int = int {x = if "totor" then "totor" else "totor", x = int {x = break, x = nil} }  function x(x : int) : int = int {x = break, x = 5}  var x := 5 var x := 5 var x := 5
x.x.x.x[(x ; () ; 5)]
var x : int := int [()] of "totor" class x {var x := 5} 
type x = int
x.x[while break do nil][while x.x(break, "totor") do int {x = 5, x = nil} ].x.x(while if x() then x["totor"].x(if nil then "totor" else 5, x.x((), "totor")) else if ()|break then x := () else (5) do let var x := 5 var x := 5 in x.x() end, new int)
class x {var x := 5} 
x(x(int [x["totor"]] of x(let  in 5 end, x := nil), -for x := int {x = "totor", x = 5}  to x.x() do let  in 5 end), int {x = while if let  in 5 end then int [()] of () else new int do x()} )
x.x[x.x()][x.x := int {} ][x["totor"][let  in 5 end]].x(int {x = x(let var x := 5 in nil ; 5 end, x())} , x[()][-()].x.x(int {x = if x() then -break} , let var x := 5 var x := 5 in int {x = break, x = break}  end))
type x = array of int class x extends int {var x := 5} 
x.x[int {x = nil, x = break} ][let var x := 5 in end][x[()][x(5, nil)] := x.x.x(x(), if nil then break)]
class x {var x := 5}  class x extends int {var x := 5}  class x extends int {} 
x["totor"][let  in 5 end][if x := 5 then while "totor" do () else x()][x(int [if nil then () else 5] of int {} , if x(break, "totor") then new int)]
if int {}  then (int [5*"totor"] of x ; x("totor", nil))
function x(x : int, x : int) : int = new int*x
if (if (5) then (5)) then x(new int, int {x = x(), x = new int} ) else x()
type x = array of int
var x := (5)
if x(for x := x() to int {}  do let var x := 5 in break ; 5 end, let var x := 5 var x := 5 in end) then let import "empty.tih" in int {}  ; "totor" end|(if () then 5 ; nil ; 5)
x[nil].x[new int].x := int [int {x = for x := x.x(break, nil) to (5) do while "totor" do ()} ] of (while 5 do nil)
type x = array of int function x(x : int) : int = ()&break type x = int var x := 5 var x := 5
x(if x["totor"][let  in 5 end] := if int {}  then int ["totor"] of 5 else let  in 5 end then int {x = int {x = x(break, ())} } , x.x.x.x.x())
new int
x()
class x {var x := 5 var x := 5} 
let class x extends int {var x := 5}  in while int {x = break, x = nil}  do x&x[nil] := x() end
int [x()] of if let var x := 5 var x := 5 in end then (for x := "totor" to "totor" do "totor" ; "totor")
function x(x : int, x : int) : int = -x
while x["totor"][(5)][x.x.x()].x() do let var x := 5 in end
while for x := for x := int {x = new int}  to x(if break then "totor", if 5 then break else break) do if int {}  then int {x = nil}  to int {x = x(let  in 5 end, while "totor" do ())}  do for x := while if break then 5 else 5 do let  in end to x() do x(x.x("totor", break), x := 5) do x()
type x = class {var x := 5}
type x = class extends int{var x := 5}
type x = int function x(x : int) = x.x() type x = int
class x {var x := 5}  type x = int
function x(x : int, x : int) : int = x.x type x = class extends int{}
x.x[int {} ][let var x := 5 in end][for x := let var x := 5 in end to x.x := if () then nil else 5 do x((5), if () then "totor" else nil)] := x.x[while break do 5][if while 5 do break then -()].x(int {} , int {x = x(), x = if if nil then "totor" else break then if break then nil else "totor"} )
let var x : int := 5 in new int ; x() end
while for x := if x.x.x() then let var x := 5 in end to (int {x = 5, x = ()} ) do new int do for x := let var x := 5 var x := 5 in if break then nil else () end to (x := "totor" ; "totor" ; 5) do x[break].x := x.x.x(let  in 5 end, -break)
(x.x[x.x(nil, 5)] := new int ; x.x.x(x.x(nil, "totor"), ()&nil))
type x = class {var x := 5}
-int [x()] of int [for x := break to () do "totor"&let  in end] of if for x := break to nil do 5 then x()
var x : int := x.x(5, nil) function x(x : int) : int = for x := () to break do nil class x extends int {} 
var x := x := () class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5} 
function x(x : int) : int = x.x.x() class x extends int {var x := 5} 
class x extends int {var x := 5} 
let function x(x : int) : int = x var x := 5 var x := 5 in x["totor"][(5)].x(if int {x = (), x = 5}  then if break then break else let  in end, x[()].x()) ; new int end
x[break][int {} ][let var x := 5 in () end][if int {x = "totor"}  then x(nil, break) else x()|int {x = int [nil] of break} ]
int {x = let var x := 5 var x := 5 in (5)&(5) ; int {}  end} 
for x := int {x = int {} }  to int {x = let var x := 5 var x := 5 in nil/nil ; 5 ; 5 end}  do new int
new int
class x {var x := 5} 
class x extends int {var x := 5 var x := 5} 
var x := new int
var x : int := int {x = 5, x = "totor"} 
x[nil].x.x.x.x()
var x := new int type x = array of int var x := 5
type x = array of int function x(x : int) : int = -break
function x(x : int) = x.x.x() var x : int := nil class x extends int {} 
let function x(x : int) : int = if break then () else () function x() : int = break import "empty.tih" var x := 5 in int {x = x.x.x()}  end
x.x[new int][x()][(x(break, ()) ; nil ; 5)].x(for x := if new int then int [int {} ] of x() else -5-"totor" to -("totor") do x.x := int {x = ()} |let var x := 5 in end, -x[()].x := int [if "totor" then break else break] of x.x(break, break))
x.x.x[int {} ].x.x()
type x = {x : int} type x = int
class x extends int {var x := 5}  class x {var x := 5}  type x = int
x.x[while break do break].x[x.x.x := if int {}  then let  in end].x()
int {} 
class x extends int {var x := 5 var x := 5}  type x = class extends int{}
type x = class {var x := 5}
type x = {x : int}
for x := int {}  to let var x := 5 import "empty.tih" var x := 5 in int [x] of if nil then "totor" else "totor" ; if 5 then break end do int {} 
x["totor"].x.x[x(new int|int {x = "totor"} , (5)+int {x = "totor", x = break} )] := x(x[()][for x := () to 5 do 5].x(), x(for x := int ["totor"] of nil to x := "totor" do int {x = nil} , x[5].x(x.x((), nil), nil/"totor")))
function x(x : int, x : int) = int {x = x.x()}  class x {var x := 5} 
int {} 
x.x.x.x[x[nil][int {x = nil} ]] := int [int {x = int {} } ] of x[5].x := x()
function x(x : int, x : int) = x.x := int [5] of break var x := break
new int
x.x.x.x.x := if int [while -() do x(nil, break)] of if x then let  in end then let import "empty.tih" in int {}  ; nil end else (x := 5)
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
x.x[if nil then nil].x[int {} ]
class x {var x := 5 var x := 5}  function x(x : int) = if "totor" then nil else "totor" class x extends int {} 
function x(x : int) = x[()] := let  in end function x(x : int) = x(nil, ()) class x extends int {}  import "empty.tih" var x := 5
x(while int {x = x(x := 5, x.x()), x = while x("totor", "totor") do for x := nil to 5 do ()}  do x(x(), if x then for x := nil to "totor" do "totor" else x(nil, ())), if let var x := 5 var x := 5 in end then int [x[break] := int {x = 5, x = 5} ] of x.x.x(x(), int {x = "totor", x = break} ))
function x(x : int) : int = int {x = if () then nil}  class x {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) = int [nil] of ()
while let type x = int var x := 5 in int {x = x(nil, ()), x = x(nil, break)}  end do if x[nil]/let var x := 5 in end then x.x[let  in end] := x.x.x(int ["totor"] of nil, x.x(break, nil))
let var x := break in (while 5 do 5) ; if int {}  then let  in 5 end else new int ; let  in end end
int {} 
class x extends int {var x := 5}  var x : int := nil
type x = class {var x := 5}
(let import "empty.tih" in end)
let class x extends int {var x := 5}  in end
class x extends int {var x := 5 var x := 5}  function x(x : int) = x
while x.x.x.x do if int {x = if 5&nil then (5) else x, x = new int}  then x.x.x else x.x.x.x(x(), int {x = int [()] of ()} )
x[break].x[let var x := 5 in end][let import "empty.tih" var x := 5 in end].x(while int [x[()]] of x.x do x(for x := 5*5 to let  in 5 end do int {x = ()} , while let  in 5 end do x("totor", ())), for x := x.x.x := x.x to int [int {} ] of int {x = int {} }  do let import "empty.tih" var x := 5 in int {}  end)
function x(x : int, x : int) = x()
int {x = x.x.x[x()].x(x(), x[()][x.x("totor", ())].x())} 
class x extends int {var x := 5} 
int {} 
let function x(x : int) = new int in end
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  var x := 5
function x(x : int) : int = int {} 
int {x = ((5 ; 5) ; new int ; 5 ; 5), x = x()} 
for x := x[5].x.x := int {x = int [5] of ()-x := nil}  to -int [let var x := 5 in end] of let var x := 5 in end do x.x[int {} ][-5|let  in end].x()
function x(x : int) = if let  in end then x.x(break, "totor") function x(x : int) : int = -break
x.x[let  in end][for x := x(nil, ()) to x() do x := ()].x := x()
while x.x.x.x.x(int {x = while int {x = "totor", x = 5}  do x := 5} , x[nil].x.x()) do x.x.x.x.x(x(int [nil] of nil*int {} , int {} ), int {x = (())} )
if new int then for x := let import "empty.tih" in new int end to let var x := 5 var x := 5 in end do x[5][if break then 5 else "totor"].x()
type x = class {var x := 5}
class x {var x := 5}  var x : int := () function x() : int = nil var x := 5
type x = array of int
class x {var x := 5}  function x(x : int) : int = if break then 5
x.x.x.x.x
let class x extends int {var x := 5}  class x extends int {}  var x := 5 var x := 5 in end
x(let class x extends int {}  in new int ; if () then 5 else break end, x())
var x : int := x
var x := for x := nil to () do ()
int [let type x = int in x() ; -"totor" end] of x(int {} , x(let var x := 5 in 5 end, x[5] := int [5] of "totor"))
int {x = x[()].x[for x := let  in 5 end to int [()] of nil do x("totor", "totor")].x(), x = int {x = let import "empty.tih" var x := 5 in end} } 
x["totor"][int {x = 5, x = nil} ].x[for x := (()) to int {x = int {x = nil, x = "totor"} , x = let  in 5 end}  do x.x := x] := int [int {x = (nil ; 5), x = x.x.x()} ] of for x := int [x(5, ())] of int {}  to x[break].x(let  in end, x(nil, 5)) do if int {x = 5}  then x.x() else for x := "totor" to "totor" do "totor"
function x(x : int, x : int) = for x := x to if () then 5 else "totor" do int [()] of nil
x[nil].x.x.x.x(let class x extends int {}  var x := 5 var x := 5 in int {}  end, let function x() : int = break in end)
class x {var x := 5} 
int {x = x()} 
int {x = x.x.x[x.x.x(x := break, x)], x = while int [if int [()] of break then if nil then nil else "totor"] of int [for x := nil to () do "totor"] of x() do if x() then x.x else x.x.x(x(break, nil), (5))} 
let function x(x : int) = (5) in x.x&int {x = nil&"totor"}  ; let var x := 5 in break end ; for x := break to nil do 5 ; "totor" end
type x = class extends int{var x := 5}
new int
for x := while x(x[break] := int [break] of break, for x := x("totor", nil) to int {}  do new int) do new int to x.x.x[x[break].x(let  in 5 end, (5))] do int {x = if for x := int {}  to int [()] of break do -nil then (5 ; 5)} 
if x.x.x.x() then int {x = new int} +int [x()] of new int
new int
x()
function x(x : int) : int = int {x = x} 
new int
function x(x : int, x : int) = let  in end/x(5, break)
let type x = {} var x := 5 in end
-if x["totor"].x()/let var x := 5 in end then for x := int {x = for x := break to nil do "totor", x = int {x = "totor"} }  to "totor"-nil*let  in end do x()
function x(x : int) = if if () then () then int {x = break, x = break}  else let  in end
let type x = class extends int{} in if int {x = int [nil] of 5}  then x.x else int [while nil do 5] of break+nil end
int {x = int {} , x = if x[()].x.x(int [int {x = "totor"} ] of x.x(nil, 5), (break ; 5)) then x.x[x.x()].x()} 
function x(x : int) : int = x(x(), x.x("totor", nil)) class x {var x := 5}  type x = int import "empty.tih" var x := 5
function x(x : int) : int = x() var x : int := "totor"
int {x = -if x[()] then x.x := ()&() else -new int, x = x[break].x.x.x()} 
function x(x : int) : int = -int {x = break, x = ()} 
for x := let function x() : int = break import "empty.tih" var x := 5 in end to (x.x.x(int {x = break} , int {} ) ; int [break] of "totor") do (int {} )
function x(x : int) : int = x.x.x() class x {var x := 5} 
x(if (x((), "totor") ; () ; 5) then int {x = x[()].x(), x = -int [()] of 5} , int {x = let import "empty.tih" in end, x = -for x := int {x = "totor", x = break}  to let  in 5 end do x.x()} )
new int
let function x(x : int) : int = x(5, 5) class x {}  import "empty.tih" var x := 5 in x() end
x["totor"].x[int [int [nil] of break] of (5)].x.x()
let var x := "totor" var x := 5 import "empty.tih" in end
int [x[break][x := nil][int {x = x(), x = int {x = ()} } ] := int {x = (break)} ] of for x := x.x.x := for x := x((), 5) to x.x() do x(break, ()) to int {}  do if x[5] := (5) then x[break] := if nil then break
var x : int := let  in 5 end class x {var x := 5}  function x() = break var x := 5
int {} *x.x[x.x()][(nil ; 5)] := x((break ; 5), int {} )
int [int {x = x[break].x.x(-int [nil] of 5, int {x = new int} ), x = x.x.x} ] of for x := for x := int [x := nil] of x.x() to (break) do x.x := int {x = 5, x = "totor"}  to int {x = x.x := while "totor" do ()}  do x.x.x := int {x = 5|"totor"} 
let class x {}  var x := 5 var x := 5 in x(x.x(break, break), while break do "totor") ; "totor"*break end|x.x.x[while int {x = "totor"}  do x(5, break)].x()
function x(x : int) = int [x(nil, 5)] of if () then () else break
int {x = let type x = int import "empty.tih" var x := 5 in for x := x.x((), 5) to x.x() do if nil then nil else () end, x = x(if let var x := 5 in end then int [-()] of let  in end else x["totor"], new int)} 
x.x[let  in 5 end][-x.x()].x.x()
for x := while int [x.x] of int {x = if nil then nil else 5, x = while "totor" do "totor"}  do int {x = if x then x := 5}  to x() do x.x.x[x+if () then nil].x((let  in 5 end), int [let  in 5 end] of x.x((), break)--if nil then nil else ())
function x(x : int) : int = while int {x = nil}  do int {x = nil, x = break} 
int {x = if if if int {x = 5, x = 5}  then int [nil] of break else x(nil, nil) then x["totor"].x() then int [x()] of int {}  else x.x.x := x.x.x(int {} , let  in end), x = x(let import "empty.tih" in if () then 5 else 5 end, if x.x then new int)} 
let type x = array of int in end
var x : int := (5) function x(x : int) : int = let  in 5 end class x extends int {}  var x := 5
function x(x : int, x : int) = int {} 
type x = int class x extends int {var x := 5}  function x() = nil var x := 5
function x(x : int) = int {x = x.x(), x = let  in end} 
for x := x[nil][nil&()].x to if while x(x(), x) do (5)&-break then let var x := 5 in nil ; 5 end|x.x.x(while () do "totor", (5)) else if x.x then let var x := 5 in end else while x := break do if () then break do let class x {}  var x := 5 in break*nil/int {x = break, x = "totor"}  end
(-int {}  ; x.x := x(break, break))
var x : int := for x := "totor" to "totor" do () function x(x : int) : int = 5/()
x[()][int {} ].x[let import "empty.tih" in x(5, nil) ; nil end] := if (let  in end ; break ; 5) then ---nil else let var x := 5 var x := 5 in let  in 5 end end
function x(x : int) = let var x := 5 in end class x {var x := 5} 
int {} 
if while for x := ()+() to x do int [break] of nil/new int do (int {x = nil} ) then new int
x(((nil ; 5)), int [x(if x.x() then while () do "totor", int {} *new int)] of int {x = if int {x = (), x = ()}  then x := "totor" else -"totor"} )
function x(x : int) : int = let var x := 5 in 5 end type x = array of int class x extends int {}  var x := 5 var x := 5
-x.x.x[("totor" ; 5)].x()
var x := let  in end
x(-int {} , -let var x := 5 in "totor" end&if int [()] of () then x.x())
-int {x = for x := int {x = x.x(5, nil)}  to let var x := 5 in nil ; 5 end do x.x := nil+"totor", x = x(while if 5 then "totor" else "totor" do if nil then break, x())} 
for x := new int to -int [(break)] of x(nil, 5)/new int do -let var x := 5 in x.x((), ()) end
if x.x[for x := nil to "totor" do nil].x then x(new int, while new int do int [-5] of -()) else if x() then let import "empty.tih" var x := 5 in if () then () ; "totor" end else x()
int {x = x.x.x.x, x = for x := int {x = let var x := 5 in "totor" ; 5 end}  to if while int {x = break, x = nil}  do while "totor" do () then -int {x = nil}  do int {x = int [x.x()] of int [nil] of break, x = x()} } 
x()&if if x["totor"].x(int {} , int {x = "totor"} ) then int {x = let  in 5 end}  then int [x()] of x[()]
type x = {x : int} var x : int := "totor"
int {x = for x := int {x = for x := break to break do nil}  to int {x = if nil then nil else nil}  do while int [()] of break do if () then 5|new int, x = x.x[nil+5][int {x = (5)} ] := int {x = x(), x = int {x = new int} } } 
x()
class x extends int {var x := 5 var x := 5}  function x(x : int) = int ["totor"] of break var x := 5 import "empty.tih"
(int {} )*if x(new int, x((5), (5))) then let import "empty.tih" in x((), break) end
class x {var x := 5} 
type x = {x : int}
function x(x : int, x : int) = x(for x := 5 to nil do break, -5) class x extends int {var x := 5} 
var x : int := int {}  type x = int class x extends int {}  import "empty.tih"
class x {var x := 5}  class x {var x := 5} 
class x extends int {var x := 5}  function x(x : int) = for x := () to nil do "totor" function x() : int = () import "empty.tih" var x := 5
x[nil][(5)][(() ; 5)].x := int {x = x.x[()*"totor"] := x[()]} 
x(new int, int {} )
if int {x = int {x = -int [nil] of nil, x = int {} } }  then x[break][int ["totor"] of break][int [x] of x].x()
while (if (5) then int {x = "totor", x = nil}  else x := "totor") do -x.x.x.x()
function x(x : int) : int = let  in 5 end|let  in end
x(x[5][x.x()][x["totor"].x(if nil then nil else nil, let  in 5 end)] := x(), int [x["totor"].x := x()] of new int)
type x = array of int
function x(x : int, x : int) : int = if -5 then int {x = nil, x = 5}  else (5) class x extends int {var x := 5} 
for x := if for x := if int {x = break}  then int {x = (), x = "totor"}  to int [int {x = "totor"} ] of x := break do x() then x.x.x.x(x.x(nil, break)/-5, x()) else -int {x = if break then "totor" else break}  to x.x.x.x := if int {x = x := ()}  then int {}  do int {x = x.x.x := int [for x := nil to nil do 5] of int [5] of break} 
class x extends int {var x := 5 var x := 5} 
class x {var x := 5} 
x()
let function x(x : int) : int = int {x = "totor"}  in x[()] := int {} -x := nil+int {x = "totor", x = ()}  end
class x extends int {var x := 5}  function x(x : int) = let  in 5 end
x.x.x.x[x.x.x]
let function x(x : int) : int = if break then break else "totor" function x() = 5 in end
class x {var x := 5 var x := 5}  type x = class {} class x {} 
function x(x : int) = for x := x := 5 to x do let  in 5 end var x := "totor" type x = int import "empty.tih" var x := 5
x[nil].x.x[int {x = x(()*(), x())} ].x(let var x := 5 var x := 5 in x.x() ; 5 ; 5 end|let var x := 5 in end, x())
function x(x : int, x : int) : int = x[nil]
int {x = x(), x = let function x() = break in end} 
x.x[x.x(nil, break)].x.x.x(while if int {x = x(nil, ()), x = new int}  then -if "totor" then nil else int [let  in 5 end] of "totor"/() do x(x(), let var x := 5 in break ; 5 end), x.x.x*x.x.x.x())
x["totor"][x.x(break, "totor")].x.x := int {x = x.x, x = x[()] := if break then break} /(x := () ; () ; 5)
x[nil][(5)].x.x.x(x(for x := let var x := 5 in end to x[break] := new int do int {} , (new int)), int {} )
int {} 
var x := x := break
function x(x : int, x : int) : int = new int class x {var x := 5} 
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = let var x := 5 in "totor" end function x(x : int) = for x := nil to break do "totor"
function x(x : int) = while int {x = nil}  do new int
if int [x[nil].x.x()] of x[break][x()].x(int {} , if let  in 5 end then x.x() else int {x = nil, x = ()} ) then x[5][for x := "totor" to () do break]&for x := let var x := 5 in end to -nil+5 do x.x.x()
x.x.x.x.x.x(new int, x(int {x = let var x := 5 in break ; 5 end, x = x()} , x.x["totor"-break].x()))
function x(x : int, x : int) : int = (5 ; 5)
type x = int var x : int := nil
type x = class extends int{var x := 5}
type x = class {var x := 5}
let type x = class {} in end
class x extends int {var x := 5}  function x(x : int) : int = let  in end var x := 5 import "empty.tih" var x := 5
let var x := break in -if x.x(5, "totor") then for x := () to break do nil ; let var x := 5 in "totor" ; 5 end ; (5) ; break end
x[break].x[if let  in 5 end then for x := break to () do nil else let  in end].x
var x : int := if () then "totor"
var x := int [()] of ()
class x extends int {var x := 5 var x := 5}  var x : int := nil
function x(x : int, x : int) = if while nil do break then int [nil] of "totor" else (5) function x(x : int) = int [()] of break
let function x(x : int) : int = -"totor" in end
for x := new int to int [x[break][x].x(x.x, while for x := break to "totor" do nil do x(5, ()))] of let var x := 5 var x := 5 in end do (for x := ()-nil to x.x(nil, nil) do int {x = (), x = "totor"} )
function x(x : int, x : int) = x[break] type x = class {}
x.x[x.x("totor", ())][x.x][x.x[x("totor", nil)]].x(let type x = int import "empty.tih" in int {x = for x := () to "totor" do 5}  ; new int ; break end, int [x.x.x.x()] of let var x := 5 var x := 5 in if nil then break else break end)
function x(x : int, x : int) = x(while "totor" do (), x.x()) function x(x : int) : int = x.x((), "totor")
new int
-while let var x := 5 var x := 5 in int {x = break, x = nil}  ; 5 ; 5 end do let import "empty.tih" var x := 5 in end
x.x.x.x.x
var x := (5)
x.x[x][x := ()&x][x[5].x.x(if x := nil then if nil then break else "totor" else int {x = (), x = break} , let var x := 5 in 5 ; 5 end)]
function x(x : int, x : int) : int = if break|break then int {}  else x := break
x[nil].x.x.x.x(let var x := 5 import "empty.tih" var x := 5 in end, while x.x[x := 5] := x[()] do -x(for x := 5 to nil do nil, int {x = "totor"} ))
class x {var x := 5}  class x extends int {var x := 5} 
while for x := (x() ; 5) to (break)*x.x := new int do x() do x()
x[5][let  in end][while 5 do ()-if break then 5 else 5].x.x()
int {x = x[5][int [5] of nil][x(x(5, break), int {x = nil, x = "totor"} )].x()} 
for x := int {x = let import "empty.tih" var x := 5 in (5) end}  to x() do x["totor"].x.x()|int {} 
for x := int [let import "empty.tih" in int {}  ; "totor" ; 5 end] of -x(int {x = (), x = "totor"} , x(nil, ())) to if new int then x()|new int else new int do new int
class x extends int {var x := 5} 
class x {var x := 5}  function x(x : int) = -nil
if x[()].x.x.x() then x(while while x() do x.x() do for x := x.x() to new int do (5), while x.x do x(if () then nil, int {x = "totor"} )) else int {x = let var x := 5 in end-x(while break do nil, if () then break)} 
function x(x : int) : int = for x := if nil then () to new int do x := 5
class x {var x := 5}  class x {var x := 5} 
for x := int {x = int {} , x = for x := int {x = x.x(break, "totor")}  to int {x = x}  do x.x := int {} }  to int [int {x = if int [break] of nil then x := 5 else let  in end, x = int {} } ] of new int do int {} 
type x = class {var x := 5}
var x := while break do ()
type x = class extends int{var x := 5} function x(x : int) : int = x.x()
x()
let var x : int := 5 type x = int in let var x := 5 in for x := 5 to "totor" do 5 end end
-x[nil].x.x.x(--int {x = break} , while x() do int {} )
for x := if x[nil][(5)] then x.x[5*nil] to let function x() = () import "empty.tih" var x := 5 in end do (x(-break, if "totor" then ()) ; x := ())
-if for x := new int to while int [()] of break do x do x() then (x(5, ()) ; 5)
class x extends int {var x := 5 var x := 5} 
var x := while () do 5 class x {var x := 5} 
let type x = class {} in while x.x.x(let  in 5 end, int {} ) do int {x = let  in 5 end, x = if 5 then 5 else 5}  end
function x(x : int) = x[nil].x() class x {var x := 5} 
x[nil].x.x[-x["totor"].x()].x()
var x : int := for x := () to break do () function x(x : int) : int = (5)
type x = class {var x := 5}
let class x extends int {var x := 5}  var x := 5 var x := 5 var x := 5 in if -let  in 5 end then for x := x.x() to (5) do x() end
x.x[x][if int {x = "totor", x = nil}  then if 5 then nil else let  in end].x()+x.x[new int].x
x()
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = x((), nil) type x = int
type x = array of int
class x extends int {var x := 5} 
function x(x : int) = int {} 
var x : int := if "totor" then 5 else () function x(x : int) : int = break&nil class x extends int {} 
function x(x : int) : int = for x := int {x = break, x = ()}  to x.x(5, "totor") do int {x = 5, x = 5}  function x(x : int) : int = int {}  function x() = "totor" var x := 5
x[5][nil&nil][int [int {x = ()} ] of while () do "totor"].x.x(if let import "empty.tih" in int {x = "totor", x = ()}  end then x.x[x("totor", break)].x(x.x.x(new int, new int), x.x := if "totor" then "totor" else 5), int [(break)+x(-"totor", x := 5)] of let var x := 5 in end)
function x(x : int, x : int) = for x := x() to (5) do int {x = (), x = break}  type x = class {}
class x {var x := 5 var x := 5} 
int {x = int {} } 
x.x.x.x.x := if while x.x.x(x.x(5, "totor"), x()) do if int {}  then x() then int [int {x = int [nil] of nil} ] of x(int {x = break} , x.x())
function x(x : int, x : int) = let var x := 5 in break end var x := 5
x.x[x.x(break, ())].x.x.x()
var x : int := -"totor" var x := break
class x {var x := 5 var x := 5}  type x = {} class x extends int {} 
type x = int function x(x : int) : int = x.x(nil, nil)
var x := int [nil] of () var x : int := "totor"
x()
if x.x[x()].x.x(x.x[x.x()].x(), new int) then int [x()] of if x["totor"] then int {x = int {x = "totor", x = ()} , x = (5)} 
x["totor"].x[x[5].x(x.x(), (5))][x(x, for x := nil to () do ())|int {x = int {x = "totor", x = "totor"} } ].x(int [if x[()] := for x := () to "totor" do "totor" then let var x := 5 in break end] of x(x[5].x(), new int), let function x() : int = () in for x := (5) to x do new int ; int [()] of 5 ; break ; 5 end)
var x : int := new int
function x(x : int) : int = int {x = let  in end}  type x = class extends int{} class x {}  import "empty.tih"
function x(x : int, x : int) = int {x = while 5 do "totor", x = for x := 5 to break do nil} 
x.x.x[if -break then x((), break)].x.x(int {x = int [x[()].x(let  in 5 end, (5))] of x(let  in end, x.x())} , x(int {x = let var x := 5 in end, x = ("totor")} , x[()].x.x(x.x.x(), int {} )))
int [(-"totor")&x[5].x.x((5)/int {x = (), x = "totor"} , x.x := x)] of if let var x := 5 var x := 5 in for x := "totor" to "totor" do nil end then new int
var x : int := (5) var x : int := () type x = int import "empty.tih" var x := 5
x[5][x].x.x
x.x.x[if x.x() then x.x()].x := x[break][x.x()][int {} ].x()
int {x = let type x = int in end, x = if int [if nil+5 then 5/()] of x.x.x() then let var x := 5 var x := 5 in end} 
type x = {x : int}
if x.x.x[for x := if nil then () else 5 to while break do 5 do int [nil] of ()] then x["totor"].x[int [if break then 5] of for x := () to () do break] := x[()][let  in end]
let function x(x : int) : int = x() in end
int {x = int {x = let var x := 5 in 5 end, x = int {x = x := 5, x = int {x = nil} } } &int {x = if x.x() then x() else int {x = "totor", x = nil} } , x = let function x() : int = 5 in end} 
if (x(x.x(nil, 5), new int)) then x[nil][x := 5][-let  in 5 end].x() else let class x extends int {}  in end
function x(x : int, x : int) = x(int {x = 5} , while break do ()) class x extends int {var x := 5}  function x() : int = break var x := 5 var x := 5
int {x = let function x() = 5 in end, x = x()} 
x[5].x[while x.x() do for x := () to break do ()][x.x.x := int {x = for x := 5 to break do 5, x = x.x(5, ())} ].x(x.x.x[int {} ].x(for x := for x := let  in end to x.x(5, 5) do x(break, ()) to int {}  do int {x = x("totor", break), x = let  in end} , (x())), x.x[int {x = nil} ][x[5]].x(-x(), int {} ))
if -x["totor"].x := x() then x() else x[()][new int][int {} /int [5] of break] := int [int {x = int {x = break, x = break} } ] of for x := while break do "totor" to (5) do x
type x = int
var x : int := x type x = int class x extends int {} 
type x = int var x : int := "totor" function x() = "totor"
x[5][let  in 5 end][int {x = -5} ].x := int [int [x()] of let var x := 5 in "totor" ; 5 end] of x.x.x := if -"totor" then x.x(break, "totor") else x.x()
class x extends int {var x := 5} 
x[nil].x[new int].x.x(while new int do for x := x() to int {x = int {x = 5} , x = x := break}  do -for x := "totor" to () do (), (-nil+break ; (5) ; nil))
x(int {x = int [x["totor"].x()] of x[nil]} , int {x = x.x.x, x = x["totor"][let  in 5 end] := new int+x} )
x.x.x.x.x.x(new int, let function x() : int = break var x := 5 var x := 5 in let var x := 5 in end ; int {x = break}  end)
int {} 
if new int then int {x = let var x := 5 in break end} /let var x := 5 var x := 5 in x.x("totor", ()) end
int {} 
x[break].x.x.x.x(int {} , let type x = int import "empty.tih" var x := 5 in end)
if int {x = let import "empty.tih" var x := 5 in end, x = if while x.x((), ()) do if () then "totor" then x.x.x(x := "totor", int {} ) else if let  in end then let  in 5 end else while break do break}  then int {x = int {} , x = x()} 
function x(x : int, x : int) = ("totor")
x(while for x := x() to for x := int {}  to x(nil, ()) do int {}  do x[5].x(if () then () else nil, for x := () to break do "totor") do x(), new int/int {x = int {} } )
while for x := new int to if if x.x() then int [nil] of "totor" then for x := "totor"*"totor" to let  in end do int {x = "totor"}  else int [x] of int {}  do int {}  do new int
int {x = int {} } 
if x.x.x[(break)] then x()
int {x = int {} , x = if x(let var x := 5 in end, new int) then int {x = int [while break do nil] of int {x = break} , x = x := "totor"/int {} } } 
class x extends int {var x := 5 var x := 5} 
x.x["totor"-5][let var x := 5 in end][x.x[let  in end].x(for x := new int to break|nil do x(), int {x = 5|5, x = int [nil] of "totor"} )] := x["totor"].x.x.x(x[5].x.x(for x := while () do "totor" to int {x = break}  do int {} , x(if nil then nil else nil, (5))), (for x := nil to break do break))
class x {var x := 5 var x := 5} 
class x {var x := 5}  var x := 5
function x(x : int) = x[()] class x {var x := 5} 
int {x = for x := let var x := 5 in 5 end to let var x := 5 in nil end do x[()].x()} *int {} 
int [(x(int {x = nil} , x.x(nil, nil)) ; -"totor")] of while int {x = x.x.x(), x = while x := 5 do if () then nil else ()}  do int {x = x.x.x(), x = int {x = int {x = ()} , x = (5)} } 
int {} 
x.x[x][let var x := 5 in end].x.x()
function x(x : int) = new int
class x {var x := 5} 
function x(x : int) = ("totor" ; 5)
int {} 
int {x = for x := -x() to for x := x[5] to x[5] := x.x(nil, nil) do int {x = int [()] of break}  do if x[nil] := -nil then if int ["totor"] of nil then while nil do break else int {} } 
x.x.x.x.x.x(if int [(nil ; 5)] of x.x then (if break then nil ; nil ; 5), x(int {} , x.x.x.x()))
x.x[x.x(5, ())][x[5]].x.x(x[nil][let  in end].x, (for x := int {x = (), x = 5}  to if 5 then break else () do if 5 then "totor"))
x[break][let  in end].x[if int [-()] of x := "totor" then int {} ] := let function x() : int = "totor" in if int [5] of "totor" then while () do () ; x := "totor" ; () ; 5 end
function x(x : int, x : int) = int {x = x(), x = nil*"totor"}  function x(x : int) = x.x()
function x(x : int, x : int) : int = int {}  class x extends int {var x := 5}  function x() = 5 import "empty.tih" var x := 5
for x := x.x[int {x = break} ] := if let  in end then let  in 5 end else x := "totor" to let import "empty.tih" in while break do nil ; break end do x()+x["totor"]["totor"&"totor"][new int]
class x {var x := 5 var x := 5} 
x.x[-nil].x[let var x := 5 in end].x()
if int {x = int {} }  then if x[5][x()] then let var x := 5 in for x := "totor" to 5 do break end else for x := let var x := 5 in end&-int {x = break}  to let var x := 5 var x := 5 in end do int {} 
int {} 
x(x[break][int {x = break} ][x[nil].x()] := x[()].x, int {x = x(5, nil)&x.x("totor", 5)|if x then x := 5} )
(new int)
if if int {} |(nil) then (while "totor" do 5 ; "totor" ; 5) else x.x.x then let function x() : int = () import "empty.tih" var x := 5 in end else x(int {} , if let var x := 5 in nil ; 5 end then new int else x(-5, let  in 5 end))
x[()][(5)][x.x.x(let  in 5 end, while break do ())][int [x(int {} , new int)] of -int {x = nil, x = break} ].x()
class x extends int {var x := 5} 
function x(x : int) = new int class x extends int {var x := 5}  type x = int
for x := int [let var x := 5 var x := 5 in int {}  end] of x.x[-"totor"] := if x then while break do nil to while let var x := 5 var x := 5 in end do int [if x := 5 then while () do break else x := nil] of x.x := int {x = nil, x = nil}  do x(x.x.x.x(if -() then -break, x()|if () then ()), int {} )
x.x.x[for x := x to x do let  in end][-while while 5 do nil do x(break, break)] := int {} 
var x : int := int {x = 5, x = break} 
for x := new int to int {x = x[()][new int], x = x.x.x.x(x.x.x(-"totor", if () then ()), if x() then -nil)}  do int [if x[()] then if nil-() then (5)] of let import "empty.tih" in end
var x : int := int {x = nil, x = 5}  function x(x : int) = new int class x extends int {}  import "empty.tih"
function x(x : int, x : int) = int [(5)] of while nil do 5 function x(x : int) : int = int [break] of "totor"
x["totor"][-nil].x.x
int [x.x[int [break] of nil][for x := while break do "totor" to x(break, ()) do x()]] of let class x extends int {}  var x := 5 var x := 5 in x(let  in end, int {} ) ; if nil then break ; break ; 5 end
function x(x : int) = x() class x extends int {var x := 5}  class x {} 
for x := while for x := let var x := 5 in end to -while () do nil do int {x = (), x = 5} &x := break do new int to int [x(if int {x = break, x = nil}  then x.x() else int {} , x[nil])] of if x[nil] := if () then "totor" then (nil) do int {x = x(x(int {} , if break then break else ()), if nil|break then -() else if "totor" then nil), x = if int {x = for x := break to nil do break, x = x()}  then x(if 5 then "totor" else "totor", if 5 then 5 else break)} 
int {x = x.x.x.x} 
type x = int function x(x : int) = x := nil
if x.x.x.x then int {}  else (int {}  ; let  in end)
type x = class {var x := 5}
type x = class extends int{var x := 5} class x extends int {var x := 5}  var x := 5
class x extends int {var x := 5}  var x := nil
for x := int [int [new int] of int {} ] of int {x = while x do while break do ()}  to if int [x.x.x()] of if -() then x.x((), break) then x() else let import "empty.tih" in x("totor", 5) ; () ; 5 end do for x := if -5&x((), ()) then x.x.x(let  in end, if 5 then nil) else -if "totor" then nil to (x(nil, nil) ; 5) do let import "empty.tih" in end
x(x(), (x(let  in 5 end, x) ; x.x() ; break))
class x {var x := 5 var x := 5} 
let class x extends int {var x := 5}  in end
x[5][5*nil].x.x(for x := new int to if x.x() then x.x(5, "totor") else new int do if if break then 5 then x := nil, if -x then let var x := 5 in 5 ; 5 end)-let function x() = nil var x := 5 var x := 5 in int [break] of break/x() end
function x(x : int, x : int) = int {x = int {} } 
type x = {x : int} function x(x : int) : int = x()
if for x := while x() do x.x() to int [x] of x(nil, ()) do let var x := 5 in nil end then let import "empty.tih" var x := 5 in if () then () end/new int
type x = {x : int} type x = int
var x : int := x.x() class x extends int {var x := 5} 
let class x extends int {var x := 5}  function x() : int = 5 in x.x.x := int {}  ; let var x := 5 in end ; x.x() end
class x {var x := 5 var x := 5}  type x = class extends int{} type x = int import "empty.tih" var x := 5
if x.x.x[x[break] := int {} ] then let function x() : int = break in end else int {} 
x[()].x[x.x.x(x.x(), int {x = break} )].x.x()
for x := x(let var x := 5 in end, x()) to x[nil][int {} ][x()] := x.x.x.x(let var x := 5 in () end, x["totor"].x(-5, x(nil, ()))) do let class x {}  import "empty.tih" in end
x()
x.x[int {} ][while x.x() do for x := "totor" to 5 do nil][if x() then x[break].x(x, x()) else let  in end+x()] := if (x(break, 5) ; break) then x[break].x.x(new int, x()) else int [int {x = int {x = (), x = "totor"} , x = int [nil] of nil} ] of let var x := 5 in end
for x := let class x {}  in end to int [(x() ; nil)] of let var x := 5 in end do x[break].x[x[break] := x.x((), "totor")].x(x.x[int {x = 5, x = "totor"} ] := -if break then (), (()+nil))
var x := if 5 then 5 else break type x = {} var x := 5 var x := 5
int {} 
let function x(x : int) : int = nil-5 in -x[()].x() end
int {x = x["totor"].x.x.x(), x = while for x := if int ["totor"] of nil then int {}  to if x then if 5 then break else nil else x.x() do if x() then x do int {} } 
type x = class {var x := 5}
class x extends int {var x := 5}  function x(x : int) = 5*nil
x[nil].x.x[if int {x = if nil then "totor"}  then let var x := 5 in end].x()
x.x.x.x[while x[5] := int {x = break, x = ()}  do (break ; 5)].x()
type x = array of int class x {var x := 5}  function x() = "totor" import "empty.tih" var x := 5
var x : int := x
int [int {x = int [x[()].x()] of if x := nil then new int else while 5 do "totor"} ] of x(x[nil][int [nil] of break] := x.x("totor", ())-int [nil] of "totor", int {} )
let function x(x : int) = x function x() = 5 var x := 5 in int {x = int {} }  ; (nil ; 5) ; x.x() end
class x {var x := 5} 
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
x.x.x[int {x = new int} ][new int] := x()
x["totor"][let  in end].x[x.x.x.x(let var x := 5 in end, int {x = for x := () to () do (), x = let  in 5 end} )].x()
if int {x = int {x = let var x := 5 in "totor" end, x = int {} } , x = while int {x = let  in 5 end, x = (5)}  do if 5+"totor" then x() else int {} }  then int {x = new int}  else x[5][x][let var x := 5 in 5 ; 5 end].x()
var x : int := x class x {var x := 5} 
x(while int [let var x := 5 in () end] of x() do for x := if int {x = ()}  then int {x = ()}  else x("totor", ()) to x() do int {x = new int} , int {x = x[break].x, x = if int {x = while break do (), x = if break then 5}  then int {x = while () do break}  else int {x = x(nil, 5)} } )
x["totor"].x.x.x.x()
function x(x : int, x : int) : int = int {}  class x extends int {var x := 5}  function x() : int = "totor" var x := 5 var x := 5
type x = {x : int} function x(x : int) : int = x((), ()) class x extends int {} 
let function x(x : int) : int = x in for x := x.x() to int {}  do let  in 5 end*x() ; int {x = 5&nil, x = if 5 then 5}  ; if nil then break ; () end
for x := int {x = for x := x() to x() do x.x.x()}  to x[5][int {x = (), x = 5} ][let var x := 5 in 5 end] := x[5].x := for x := int [()] of 5 to -break do if break then nil do x[()][x := "totor"][int {x = int [nil] of "totor"} ]
(while for x := new int to let  in end do -nil do int {x = for x := nil to () do nil}  ; new int ; while () do break ; 5 ; 5)
function x(x : int) : int = for x := if 5 then "totor" else break to let  in end do for x := "totor" to break do () var x : int := "totor" var x := 5 import "empty.tih" var x := 5
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
x.x[let  in 5 end][x()] := let var x := 5 var x := 5 in end&x[()][let  in 5 end][int {x = while nil do break} ]
var x : int := x := 5 class x extends int {var x := 5} 
var x := int [break] of "totor"
class x extends int {var x := 5} 
function x(x : int) : int = let var x := 5 in 5 end
int {} 
x.x.x[(5)].x.x(x(), let var x := 5 in (5) ; nil|nil ; () ; 5 end)
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
type x = class {var x := 5} function x(x : int) = 5-"totor" function x() = () var x := 5
type x = class extends int{var x := 5} function x(x : int) = while break do "totor" class x extends int {} 
int {} 
function x(x : int) = x.x.x(int [5] of 5, while nil do 5) function x(x : int) = x(nil, "totor") function x() = "totor"
x()
type x = array of int var x := break function x() : int = nil var x := 5
type x = class {var x := 5} class x extends int {var x := 5}  function x() = nil
int {} 
int {x = for x := let var x := 5 var x := 5 in x(nil, ()) ; break ; 5 end to int {}  do if for x := nil to "totor" do break then (5) else "totor"*5/x.x, x = int [x.x.x] of int {} } 
function x(x : int, x : int) = if 5 then break else ()|x
x[5].x[x[break].x(let  in end, x.x())][int {x = x.x := int [break] of "totor", x = int {x = x(), x = x.x()} } ].x()
class x extends int {var x := 5} 
class x {var x := 5} 
class x extends int {var x := 5 var x := 5}  var x := ()
class x extends int {var x := 5 var x := 5} 
int {} 
x.x[int {x = ()} ].x.x.x(-if int {}  then new int else int {x = let  in end} , x.x[-5][x["totor"].x(new int, int {} )] := x((() ; 5), int {x = -break} ))
int [x.x[if 5 then nil else ()][int [int ["totor"] of 5] of x := ()].x()] of if x.x[-5] := int [x.x(break, nil)] of int {x = "totor", x = ()}  then x[break].x := -if () then nil else break else x.x.x := x.x.x(x(nil, nil), for x := nil to "totor" do nil)
var x : int := int {x = nil, x = "totor"} 
class x extends int {var x := 5 var x := 5} 
int {} 
function x(x : int) : int = -if () then "totor"
var x : int := let  in 5 end class x extends int {var x := 5}  class x {} 
for x := if x(-x, int {x = let  in 5 end} ) then x[break].x.x(x(), x[5]) to int {}  do int {} 
type x = int class x {var x := 5} 
if x[5][(5)].x then for x := -let var x := 5 in break ; 5 end to while x(int {} , if "totor" then nil else 5) do (break) do x() else let var x := 5 in x[5].x() ; new int ; () end
function x(x : int) = x(x(break, break), let  in end) class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
type x = int function x(x : int) = while () do () type x = int
-x()
x()
function x(x : int, x : int) = int [x.x()] of while break do ()
class x extends int {var x := 5 var x := 5} 
if x[break][int ["totor"] of break][int [if () then 5 else 5] of int {} ] then int [x["totor"][-break].x(int [int [()] of "totor"] of while 5 do nil, x.x)] of if let var x := 5 in break end then int {} 
var x : int := new int
int {} 
x.x[x := nil].x[int {} ].x(int {} , x())
class x {var x := 5} 
function x(x : int) : int = -(5) var x : int := break
type x = array of int
function x(x : int) = x(x.x(), int {x = (), x = 5} ) function x(x : int) = int {x = "totor", x = "totor"}  class x extends int {} 
if let type x = int import "empty.tih" var x := 5 in while x.x(break, nil) do for x := 5 to "totor" do break ; if 5 then nil else nil end then int {x = if if int {}  then int [()] of () else let  in end then x(x(nil, ()), 5&nil), x = let import "empty.tih" var x := 5 in end}  else x()
type x = {x : int} function x(x : int) = int {x = break} 
x.x.x[new int].x.x()
int [int {} ] of x[break][for x := break to "totor" do 5][x[()].x()].x()
var x := while nil do nil
if -x.x[x(nil, break)] then int {x = ("totor" ; 5), x = -"totor"+x} &x[nil].x := while "totor" do "totor"-int [break] of nil
-x()
function x(x : int, x : int) : int = if -break then let  in 5 end else new int
var x : int := let  in 5 end type x = int function x() : int = nil import "empty.tih" var x := 5
let type x = int function x() = nil in end
function x(x : int, x : int) : int = x[5]
(-int {x = break, x = ()} *let var x := 5 in 5 ; 5 end ; x()|"totor"/"totor" ; if () then break else () ; break ; 5)
var x := int {} 
class x {var x := 5} 
x.x[-"totor"].x[int {} ].x()
x[5].x.x.x := int {} 
class x extends int {var x := 5} 
x(while int {x = x(), x = int {x = nil} }  do if while () do 5 then x else x.x()+x[5].x.x(let var x := 5 in 5 end, -x.x(break, 5)), -x())
while let class x extends int {}  import "empty.tih" var x := 5 in x["totor"] := x(break, 5) ; x() end do for x := x["totor"].x to let var x := 5 var x := 5 in end do int {x = int {} , x = if 5 then nil else 5*if nil then "totor"} 
if int [x.x[break*"totor"] := while x((), break) do let  in end] of -x[5].x() then ((5)) else x()
x(x[break][x.x(nil, nil)].x.x(), x.x.x[x[nil].x((5), int {x = ()} )].x(x(), int {x = x.x.x(int [nil] of break, x := nil), x = int [if 5 then "totor" else "totor"] of ()-nil} ))
-let class x {}  var x := 5 var x := 5 in end
type x = {x : int} type x = class {} function x() = "totor"
if x[5].x.x := (-() ; break) then new int
class x extends int {var x := 5 var x := 5} 
for x := if let var x := 5 in end then int {}  to if while for x := for x := () to "totor" do "totor" to int {x = break, x = nil}  do if break then 5 do x() then let var x := 5 var x := 5 in end do -let var x := 5 in nil end*x(if x := "totor" then let  in end, x[break].x(new int, x.x()))
x.x[x][let var x := 5 in end].x := x[nil].x[while (5) do -5].x(x.x.x.x(), x())
function x(x : int) : int = if x.x() then int {x = ()} 
x()*for x := int [x.x.x()] of let  in end/nil&() to new int do if x[nil].x(5|5, (5)) then x.x else x()
type x = class {var x := 5} type x = class extends int{} function x() = () import "empty.tih"
class x {var x := 5} 
function x(x : int, x : int) = for x := int {x = 5, x = break}  to int [5] of "totor" do x
x()
(x(x.x, x(if () then break, while 5 do 5)) ; int {x = new int, x = x.x()}  ; "totor"|() ; "totor")
class x extends int {var x := 5 var x := 5}  var x := nil function x() = ()
x(int [x()] of let import "empty.tih" in end, x[()][x.x()][while int {}  do x("totor", "totor")] := let var x := 5 var x := 5 in end)
function x(x : int) : int = let var x := 5 in end
x[5][x.x()].x.x.x()
int {x = x.x[let  in end][x.x].x()} 
function x(x : int, x : int) = int {} |if () then () else nil var x : int := ()
function x(x : int) = int [x := ()] of x.x()
class x extends int {var x := 5} 
type x = class extends int{var x := 5} class x extends int {var x := 5}  class x extends int {}  var x := 5
let class x extends int {var x := 5}  in (nil|break ; ()) end
function x(x : int, x : int) : int = int [while 5 do "totor"] of int {x = 5} 
class x extends int {var x := 5} 
x[nil].x[if nil then 5 else "totor"+new int][x()+let var x := 5 in end] := new int
int [let class x extends int {}  in new int end] of int {x = int {x = -break} |if new int then ()-5 else x} 
new int
class x extends int {var x := 5 var x := 5}  function x(x : int) = let  in end type x = int
function x(x : int) : int = x[nil].x()
if while int {x = while x() do if nil then () else "totor", x = x()}  do let import "empty.tih" in x := () end then if x() then -new int else int {x = while let  in end do (5), x = x[break].x()} 
int {} 
new int
var x : int := -5 class x {var x := 5}  function x() = nil
int {x = let class x extends int {}  in int {x = let  in 5 end, x = x}  end, x = -x[nil][for x := nil to 5 do ()] := x()} 
class x {var x := 5} 
x.x[x(break, 5)][for x := if nil then "totor" else "totor" to int {x = 5, x = 5}  do x(break, break)][while int {}  do x.x.x(if 5 then 5 else break, x.x())] := if if if while break do break then int {x = "totor", x = "totor"}  else x := () then while let  in 5 end do x else let var x := 5 in "totor" end then -int {}  else x[()][-nil].x((() ; 5), new int)
if int {x = x[nil].x(), x = x.x} &int {x = while x() do let  in end, x = int {} -new int}  then x[()].x.x := x(new int, while if "totor" then "totor" do x := 5)
new int
if int {}  then x.x[x((), ())].x.x()
while x() do int [let var x := 5 var x := 5 in end] of x[nil].x
int [(("totor") ; x.x(nil, nil))] of int {} 
function x(x : int, x : int) : int = int [nil+break] of let  in 5 end var x : int := nil
function x(x : int) : int = if "totor" then nil|let  in end
class x extends int {var x := 5 var x := 5} 
-x["totor"][int {} ].x.x(if x[5] then int [if break then "totor" else "totor"] of -"totor" else x(x.x(), while "totor" do break), -x((5), x.x(break, "totor")))
type x = class extends int{var x := 5}
class x {var x := 5}  class x extends int {var x := 5}  function x() = 5
x.x[x.x(nil, break)].x[int {x = ("totor" ; 5)} ]
type x = {x : int}
new int
class x {var x := 5 var x := 5}  function x(x : int) = if nil then 5
(x.x[int {x = 5} ] := let var x := 5 in end)
x.x.x[let var x := 5 in end][-for x := x := "totor" to x((), "totor") do let  in 5 end] := let type x = int in if break*() then int {x = "totor", x = nil}  else let  in 5 end end
var x := let  in end
class x {var x := 5}  var x := 5 class x {}  var x := 5
-int {x = if let  in 5 end then x else x()} *(int {x = (5), x = 5/"totor"}  ; new int ; break)
class x extends int {var x := 5}  function x(x : int) : int = for x := "totor" to () do nil
var x := int {x = nil, x = ()}  var x := break
type x = array of int
type x = class extends int{var x := 5}
var x := "totor"|5 function x(x : int) = if nil then nil else 5
int {x = let class x extends int {}  var x := 5 var x := 5 in end} 
class x {var x := 5 var x := 5}  var x : int := break function x() : int = 5
x[()].x[x()][x[5].x.x()].x()
if int {}  then x[nil].x[new int].x()
new int
var x : int := (5) function x(x : int) : int = x.x() var x := 5 var x := 5 var x := 5
x.x.x[new int]*x[break].x.x.x(new int, x.x[if () then 5] := int [(5)] of if "totor" then "totor" else ())
x["totor"][x()].x.x.x()
function x(x : int, x : int) : int = int {x = for x := 5 to () do break}  function x(x : int) : int = while 5 do () var x := 5 import "empty.tih"
type x = array of int
while let function x() : int = "totor" import "empty.tih" var x := 5 in end do -let var x := 5 in x.x(5, "totor") ; "totor" ; 5 end
function x(x : int, x : int) : int = x.x := x := "totor"
function x(x : int) : int = while int {}  do x := break
new int
class x {var x := 5 var x := 5}  class x {var x := 5} 
let function x(x : int) = x() type x = int in let import "empty.tih" var x := 5 in end end
function x(x : int) : int = int {x = while "totor" do (), x = for x := nil to "totor" do ()}  function x(x : int) = int [5] of () type x = int
type x = class {var x := 5}
class x extends int {var x := 5} 
var x := let  in 5 end
while new int do x.x[5*"totor"].x.x()
int {} 
class x extends int {var x := 5} 
type x = int class x extends int {var x := 5}  function x() = ()
let class x extends int {var x := 5}  in end
function x(x : int, x : int) = let var x := 5 in nil end
function x(x : int) = if int ["totor"] of () then (5) else if () then 5
for x := int {x = -new int*while 5 do ()}  to while int [x((), 5)&x] of int {x = int {x = 5, x = nil} }  do x[()].x.x(if x((), break) then if nil then "totor" else () else let  in 5 end, new int) do let function x() = break in if x then int {}  end
int [x.x.x.x.x()] of while let var x := 5 var x := 5 in int {x = break, x = "totor"}  end do if x.x := x((), 5) then let var x := 5 in break ; 5 end
type x = int
function x(x : int, x : int) = x[nil].x()
-x[nil][(5)][while x.x(5, break) do let  in end]
type x = class {var x := 5}
if if x[nil][let  in 5 end].x(if let  in 5 end then while "totor" do nil else new int, let var x := 5 in end) then x.x.x.x(while x do for x := () to 5 do break, new int) else for x := x() to x["totor"].x() do int {x = int [nil] of nil, x = for x := () to () do nil}  then x() else int {x = int {x = while let  in end do nil*5} , x = for x := int {x = int {x = 5, x = nil} }  to if x := () then -5 else x do x(x(5, 5), int [nil] of 5)} 
let function x(x : int) : int = for x := "totor" to "totor" do () in for x := x() to int {}  do x.x := int {x = nil}  end
while x.x[int ["totor"] of break].x.x() do x.x.x[x[break].x()].x((()/() ; 5), x(x.x, (5 ; 5)))
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) : int = (5)
var x := x
x()
let function x(x : int) : int = int {}  in end
class x extends int {var x := 5 var x := 5} 
type x = array of int
if for x := let import "empty.tih" in int [break] of nil end to if for x := x to let  in 5 end do (5) then int [x()] of x.x("totor", "totor") else x[()] do int {x = -x(nil, 5), x = (break ; 5)}  then x[5][x := 5].x
class x {var x := 5} 
class x {var x := 5}  function x(x : int) : int = while break do 5 class x {} 
((int [()] of nil ; 5 ; 5) ; (break))
if for x := new int to for x := x() to x[()] do int [()] of ()&x do while -(5) do x(int {x = (), x = nil} , if () then ()) then int {x = for x := x(if "totor" then break else nil, x.x()) to if new int then let  in 5 end else let  in 5 end do for x := new int to x do x.x(break, nil), x = x(x(), int {} )}  else x[5][x()][while while break do nil do x] := x.x[int [nil] of break] := -int [break] of "totor"
var x := x.x()
function x(x : int) : int = x[5].x() class x {var x := 5}  function x() = "totor" import "empty.tih"
int [x()] of let type x = int in end
x["totor"].x.x[x[5].x := for x := "totor" to "totor" do 5*(5)].x(x.x[if () then 5][let var x := 5 in end].x(), x.x[nil+()][int {} ] := x.x[for x := 5 to break do 5])
function x(x : int) = let var x := 5 in end type x = {} function x() = break var x := 5
function x(x : int) : int = x.x.x(int {x = break} , while break do break) class x extends int {var x := 5}  class x extends int {} 
x()
class x {var x := 5}  class x extends int {var x := 5} 
let class x extends int {var x := 5}  in end
x(for x := x.x[(5)].x() to x[()][int {x = 5, x = break} ] := -if "totor" then break do while x(new int, if "totor" then nil) do x(let  in end, if nil then "totor" else break), int {x = int {} } )
type x = array of int function x(x : int) : int = x function x() : int = 5
type x = {x : int}
function x(x : int) : int = if if () then 5 then x else "totor"-nil
type x = int
int {} 
function x(x : int, x : int) : int = if break|break then int {x = nil, x = nil}  else int {}  var x : int := ()
while int {x = int {x = let var x := 5 in "totor" end, x = if "totor"-5 then x(nil, ())} , x = int {x = x(-nil, "totor"-break)} }  do int [int {} ] of if x.x then int {x = if () then () else "totor"}  else (nil ; 5)
var x := int {x = break} 
for x := int {}  to -while (break) do x := nil+x("totor", break) do int {x = int {x = x[5]} } 
int {x = new int, x = int {x = for x := x[break].x() to let var x := 5 in () end do int [int [5] of "totor"] of int {x = (), x = ()} } } 
for x := x() to x(x.x.x.x(x[5], -if () then 5), (int {} )) do new int--x[5]
-while let var x := 5 in () end do x()|int {x = for x := x() to x := () do int {x = break, x = nil} , x = x[()] := (5)} 
x[nil].x.x[-new int/int ["totor"] of ()] := x(x.x.x.x(while (5) do x.x(), new int), int {x = "totor"/5+x.x(nil, ())} )
new int
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = int {}  type x = int import "empty.tih" var x := 5
class x extends int {var x := 5}  var x := 5
x()
class x extends int {var x := 5}  type x = int
function x(x : int) : int = int {x = while nil do "totor", x = int {x = ()} }  type x = {}
function x(x : int) = if x.x() then int {x = nil, x = break}  else int {}  var x := nil function x() : int = () var x := 5 var x := 5
if x(if x := nil then x.x((), 5) else x("totor", "totor"), x[nil] := x(5, "totor"))+int [x(int [nil] of 5, x.x())] of let var x := 5 in end then x["totor"][x()][while -() do x].x() else int [int [x()] of int {x = if nil then break, x = (5)} ] of new int
class x extends int {var x := 5} 
int {x = while int {x = -int [5] of 5, x = x[break] := x()}  do x.x[let  in end].x(int {x = x, x = x.x("totor", break)} , new int)} 
let function x(x : int) : int = if nil then 5 in end
(-while "totor" do break|-int {}  ; new int)
type x = array of int
for x := int {}  to -x.x[for x := () to break do nil] := if x.x() then x.x(5, 5) else new int do int {} 
var x : int := int [break] of ()
while int {}  do let class x extends int {}  import "empty.tih" in end
type x = class {var x := 5}
var x := "totor"-5 function x(x : int) : int = int {x = break, x = ()} 
function x(x : int) : int = let var x := 5 in nil end class x {var x := 5} 
type x = {x : int}
while x(while for x := while nil do () to int {x = 5}  do int [()] of nil do int [int {x = nil} ] of if break then break, let import "empty.tih" var x := 5 in end) do -int {x = let var x := 5 in nil ; 5 end, x = int {x = while nil do "totor", x = ()|"totor"} } 
x[break][x := nil][int {} ].x.x(while x() do int {x = x["totor"].x(), x = -for x := 5 to () do 5} , x.x[x := 5].x.x())
function x(x : int, x : int) : int = x()
type x = int function x(x : int) : int = x := break var x := 5 var x := 5 var x := 5
((x() ; () ; 5) ; int {} )
function x(x : int) = -while 5 do break
while x(new int, (nil+nil)) do x()
function x(x : int, x : int) = let  in 5 end|for x := nil to break do nil
class x extends int {var x := 5} 
-let var x := 5 in -let  in end ; new int ; "totor" end
function x(x : int, x : int) : int = x(let  in end, x)
function x(x : int) = while if nil then break else "totor" do ()*()
if x[nil][x()].x.x() then new int
x[nil].x[if (5) then for x := "totor" to () do 5 else x.x()].x.x()
function x(x : int, x : int) = for x := -break to ()+"totor" do let  in 5 end
class x {var x := 5 var x := 5} 
(x())
class x extends int {var x := 5 var x := 5} 
if x(int {} , x.x[if "totor" then "totor"]) then x.x[int {x = "totor", x = 5} ][if x(5, 5) then (5)] := let var x := 5 var x := 5 in end
x.x.x.x.x := x(int {x = new int, x = int {x = if () then break else break} } , x["totor"].x.x())
let class x {var x := 5}  type x = int import "empty.tih" in x() ; x() ; while 5 do nil end
let var x : int := 5 class x {}  import "empty.tih" var x := 5 in end
type x = class extends int{var x := 5}
type x = class {var x := 5} function x(x : int) : int = int {x = "totor"} 
if int [x.x[let  in end]] of x["totor"][-5] then let function x() = "totor" in end else x(if let var x := 5 in end then for x := let  in 5 end to for x := break to "totor" do break do x.x(nil, "totor"), int {x = for x := (5) to 5-nil do let  in 5 end} )
int {x = int {} } +let class x extends int {}  import "empty.tih" in end
int {} 
x(int {x = int [x[()].x()] of x((), "totor")*int {x = break} , x = int [x[()]] of x.x.x(let  in 5 end, int {x = ()} )} , int {x = if for x := let  in 5 end to let  in end do let  in 5 end then int {} } )
class x extends int {var x := 5} 
new int/let function x() = break in end
int {x = x[break][if 5 then 5 else break].x.x()} 
-if x[nil][int [5] of break] then int [x.x] of while let  in 5 end do int {x = "totor"}  else x.x.x
class x {var x := 5} 
var x : int := int {} 
x.x[int {} ].x[for x := while 5 do 5 to int [nil] of () do int {x = nil, x = "totor"} *x()].x(x.x.x[while int ["totor"] of "totor" do let  in 5 end].x(), -if new int then while let  in end do int {} )
type x = class {var x := 5} type x = array of int
type x = class extends int{var x := 5}
function x(x : int, x : int) = let var x := 5 in 5 end function x(x : int) = while break do nil function x() : int = ()
function x(x : int, x : int) : int = int {}  class x {var x := 5}  type x = int
var x := let  in 5 end function x(x : int) : int = x(break, ()) type x = int
x(int {} , if int {}  then x[5].x.x(int [new int] of x, int {} ) else while if if () then () else () then while "totor" do 5 do if "totor"&nil then while break do ())
int [x.x[int {x = nil} ][int {x = (5)} ]] of int {x = x.x.x := int [x.x("totor", nil)] of int {} , x = x.x[-nil]} 
type x = {x : int} class x {var x := 5}  type x = int
int {x = if new int then x(), x = int {} } 
while let class x extends int {}  import "empty.tih" var x := 5 in end do if new int then x.x[x.x(5, ())].x(for x := if 5 then 5 to for x := nil to () do () do let  in end, let var x := 5 in () ; 5 end) else int {} 
class x extends int {var x := 5 var x := 5} 
int {x = x.x.x.x, x = new int} 
x[()].x[while "totor" do nil*int {} ] := int {x = (5 ; 5), x = x[5].x()} *let var x := 5 in x.x end
int {x = int [-int {x = let  in 5 end} ] of int [let var x := 5 in end] of int [x.x()] of if nil then nil else 5, x = -int {} } 
x.x[x][x[5].x()].x.x(--while x.x(nil, 5) do ()|break, (let var x := 5 in end ; int {x = (), x = 5}  ; nil))
int [(x(int {} , -"totor"))] of (int [while "totor" do break] of let  in 5 end ; if break then 5 else ())
int {} 
x[break].x[if while () do nil then ()+"totor"] := while x() do new int-x(let import "empty.tih" in x := nil end, for x := -let  in end to x["totor"].x(int {x = nil} , int {} ) do x[break].x())
x.x.x.x[int {x = if let  in 5 end then x.x("totor", break), x = for x := if "totor" then break to -() do int {} } ] := int {x = int [-let  in 5 end] of x[()] := -5, x = x()} 
int {x = let var x := 5 import "empty.tih" in -x ; if "totor" then nil ; 5 end} 
type x = int
class x {var x := 5 var x := 5} 
function x(x : int) = new int-x.x()
type x = array of int class x extends int {var x := 5} 
-int {} 
x.x[if break then () else 5].x.x := x.x.x[while let  in 5 end do while "totor" do "totor"].x()
let function x(x : int) : int = (5) class x extends int {}  in end
function x(x : int, x : int) : int = -int {x = nil, x = "totor"}  type x = int
function x(x : int) : int = -let  in 5 end function x(x : int) = if "totor" then 5
var x : int := x var x := nil function x() = () var x := 5
class x extends int {var x := 5} 
x.x[int {x = 5} ][int [x] of let  in end][while x[()] := -5 do x["totor"].x(let  in 5 end, x)].x()
x(int {x = int {x = x.x.x(x, let  in end)} } , x["totor"][while 5 do 5].x.x())
x()
int {x = x.x[int {x = "totor"} ].x.x(-x(), int {x = int {} , x = while x() do x()} )} 
function x(x : int) : int = -x() type x = class extends int{} type x = int
let function x(x : int) : int = if "totor" then "totor" in int [if if break then () else nil then x((), "totor")] of let var x := 5 in end end
function x(x : int) : int = new int
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) = int {x = if nil then 5} 
function x(x : int, x : int) = x[break] type x = int
if let var x := 5 var x := 5 var x := 5 in end then x()
type x = array of int
x[()][int {} ].x[int {x = if x() then new int} ] := let function x() : int = 5 in int {}  ; int [()] of 5 ; break ; 5 end
x[nil][if () then () else nil].x := int {} -while if for x := 5*5 to int {x = "totor"}  do for x := 5 to 5 do 5 then int [let  in end] of x.x() else int {}  do x[()].x(while "totor" do (), int {x = "totor"} )+x.x.x(if 5 then 5 else break, x())
type x = {x : int} class x extends int {var x := 5}  var x := 5
type x = class extends int{var x := 5}
let class x {var x := 5}  function x() : int = break in end
int [for x := x.x.x to x[5][for x := () to nil do "totor"].x(("totor"), x[()].x(int [5] of "totor", (5))) do x(x(x.x(), x), if if 5 then "totor" then int {}  else x.x((), "totor"))] of x.x.x.x
class x {var x := 5 var x := 5} 
new int
(while int {}  do while x(5, nil) do if 5 then nil ; new int ; for x := "totor" to nil do "totor")
x()
x[nil][-"totor"].x[let import "empty.tih" in let  in 5 end end]
new int
if --x.x then if x["totor"]["totor"/nil].x() then x((()), while int {x = 5, x = "totor"}  do x.x()) else let class x {}  var x := 5 var x := 5 in let var x := 5 in "totor" ; 5 end ; int {x = break, x = nil}  end
function x(x : int) : int = let var x := 5 in "totor" end
int {} 
function x(x : int) = x["totor"] := for x := () to "totor" do 5
function x(x : int) : int = x()
int {x = x(x.x.x.x(let var x := 5 in end, for x := int {x = break, x = break}  to new int do -()), x(int [x()] of x(), (break))), x = let type x = int import "empty.tih" var x := 5 in end} 
function x(x : int) = int [while break do break] of x.x("totor", 5)
x[()][while () do break][int [let  in end] of let  in end].x.x(x.x[if "totor" then () else "totor"][int {} ].x(), if let import "empty.tih" in end then x[()].x := let var x := 5 in end)
class x {var x := 5} 
int {x = while -nil+int {}  do int [int {x = nil} ] of x.x(nil, "totor")&x(while for x := nil to nil do nil do x(), let var x := 5 in 5 end)} 
x[nil][let  in 5 end][x[break] := let  in end][x()]
function x(x : int) : int = x(-"totor", -break)
int [new int] of x[()][int {x = ()} ][new int].x()
if let class x extends int {}  import "empty.tih" in end then -let import "empty.tih" in let  in end ; "totor" end
let var x := break in end
class x extends int {var x := 5 var x := 5} 
(int {x = x[5]} )
let class x extends int {var x := 5}  class x extends int {}  var x := 5 var x := 5 in int {x = new int, x = if x.x((), nil) then int {}  else for x := () to nil do "totor"}  ; int {x = 5, x = break} +int {x = ()}  end
if x.x[5+"totor"][int [x] of x := break].x() then for x := int ["totor"] of 5&if () then nil to new int do let var x := 5 in () ; 5 end|let var x := 5 in end*int {x = x((), break), x = while nil do nil}  else int [x(-()&"totor", for x := for x := nil to break do break to int {x = break, x = ()}  do x := 5)] of x(x(), for x := x.x((), nil) to let  in 5 end do break|5)
x[5][x := break].x.x.x()
int {x = x(), x = int {x = for x := x[()] := x() to if -5 then x := () do x.x := new int, x = x.x.x := int {x = x(nil, "totor")} } } 
class x {var x := 5}  class x extends int {var x := 5}  var x := 5 import "empty.tih" var x := 5
var x : int := x.x(5, ()) var x : int := nil class x {} 
while while x(x("totor"+5, new int), int {x = int {x = nil, x = nil} } ) do let import "empty.tih" var x := 5 in end do (x((5), x(break, ())))
function x(x : int) : int = if let  in 5 end then while "totor" do break class x extends int {var x := 5} 
x(int [x()] of int {x = int {x = break, x = "totor"} , x = int {x = break} } |x.x.x(for x := nil to 5 do nil, new int), x.x[-()].x := if x(int {x = break} , while () do ()) then for x := x := break to x.x() do if break then () else () else new int)
class x extends int {var x := 5} 
x[break].x[x.x.x(x(), int {x = 5} )][new int] := x(int [if -() then (5)] of x.x.x(break+"totor", 5+"totor"), x())
x.x[let  in end].x.x
int {} 
let class x {var x := 5}  in -for x := x.x() to int {}  do let  in end ; for x := int {x = 5}  to int {x = (), x = 5}  do int {}  ; new int ; "totor" ; 5 end
function x(x : int) : int = x(int {} , -"totor") class x extends int {var x := 5} 
type x = class {var x := 5} function x(x : int) : int = -"totor" function x() = "totor"
if x[5][int {x = 5} ][int {} ].x(int [x()] of int {} , x(x(x(), x.x(break, break)), let var x := 5 in end)) then x()
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = for x := "totor" to break do "totor" type x = int var x := 5
int {x = x[nil][int {x = 5} ].x, x = int {} } 
function x(x : int, x : int) = x(-nil, int {} ) type x = array of int
class x extends int {var x := 5} 
let class x {var x := 5}  function x() = "totor" in let var x := 5 var x := 5 in end ; int {x = (5), x = for x := break to nil do 5}  ; int {x = 5}  end
function x(x : int, x : int) = x[()] := ()-nil var x : int := 5 function x() = break
let class x extends int {var x := 5}  in end
int {x = let var x := 5 var x := 5 var x := 5 in end, x = int [let var x := 5 in end] of int {x = int [x.x("totor", break)] of new int} } 
function x(x : int, x : int) : int = x.x.x() function x(x : int) : int = x := break
type x = array of int
let class x extends int {var x := 5}  in end
int [new int] of while while if (5) then -"totor" else -() do while for x := nil to break do "totor" do (5) do -x(let  in end, x.x())
let type x = class {} in end
class x extends int {var x := 5} 
function x(x : int) = let var x := 5 in end class x {var x := 5}  class x {} 
int {} 
int [let var x := 5 var x := 5 in end] of if x-x := 5 then int {} *for x := new int to while int {}  do int {x = new int, x = x := break}  do x(x(-"totor", let  in end), x[5])
x.x.x.x.x := -(-"totor")
int {x = int {x = int {x = for x := ()*() to x("totor", "totor") do x(), x = while if nil then break do if nil then nil} , x = if x[5] then while break do ()-int {x = break}  else if if nil then break then int ["totor"] of 5} , x = while -int {x = if 5 then "totor", x = x()}  do while (5) do x.x} 
var x := x.x(5, break) type x = class {} function x() : int = ()
class x {var x := 5 var x := 5} 
while if int {x = x[nil] := if 5 then 5}  then x(let var x := 5 in () ; 5 end, int {} ) else for x := int {x = if () then "totor" else ()}  to -x() do x["totor"].x(if () then nil else break, x.x()) do x.x[int {x = ()} ].x.x()
x(int {x = x(x["totor"] := let  in end, x(if "totor" then 5, new int)), x = (x() ; break ; 5)} , if x.x.x.x(int [x := "totor"] of for x := nil to nil do nil, let var x := 5 in end) then int [int {x = x.x((), "totor"), x = for x := "totor" to "totor" do ()} ] of x())
(x((5), let  in end)*x := nil|5/"totor")
type x = int type x = int function x() : int = break
x.x[x("totor", "totor")].x[while int {x = 5, x = ()} +x.x() do for x := x("totor", break) to x do let  in end] := int {x = -new int, x = int [let var x := 5 in nil ; 5 end] of ()&5|x(5, nil)} 
type x = array of int type x = class extends int{} class x {}  import "empty.tih"
function x(x : int) : int = int {} 
class x {var x := 5 var x := 5} 
function x(x : int, x : int) = int {x = x.x(nil, nil)}  function x(x : int) = while nil do 5 var x := 5
function x(x : int, x : int) : int = ("totor") class x extends int {var x := 5}  class x {}  var x := 5
for x := (let var x := 5 in end) to if x["totor"].x.x() then while x.x.x() do x() else x.x.x.x() do int {x = new int} 
x()
new int
var x : int := int {x = 5, x = nil}  class x {var x := 5} 
var x : int := if "totor" then nil else break
if int {}  then -for x := if if 5 then 5 else 5 then x("totor", break) else "totor"&nil to let var x := 5 in nil end do let var x := 5 in "totor" end else new int
function x(x : int) : int = let var x := 5 in end var x := break type x = int var x := 5 var x := 5
function x(x : int) = x(()/break, x.x()) class x extends int {var x := 5}  function x() = "totor" var x := 5
class x extends int {var x := 5} 
(int {x = int {x = x, x = int ["totor"] of 5} , x = new int}  ; x[nil].x())
int {x = for x := int {x = int {x = x(), x = x} }  to let var x := 5 in end do x[()].x(if break then 5 else 5, int {} )/int [int {x = nil} ] of x(5, ())} 
class x extends int {var x := 5}  class x extends int {var x := 5} 
var x : int := x.x() function x(x : int) = new int
let function x(x : int) : int = if break then "totor" else break in end
var x : int := x()
int {x = x("totor"*break&let  in end, new int)|if int {}  then (nil ; 5) else let var x := 5 in end} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = x.x(break, "totor")
class x extends int {var x := 5}  function x(x : int) : int = if 5 then nil else "totor" type x = int import "empty.tih" var x := 5
x[break][for x := break to nil do nil][x.x := int {} ][("totor"*5)]
(x.x[int {} ] := int {x = int ["totor"] of nil, x = let  in end}  ; let var x := 5 in end ; new int)
x.x[if break then 5 else ()].x.x(new int, for x := int [x := nil] of int ["totor"] of () to "totor"|break+if break then "totor" else nil do new int)+(x.x ; -())
function x(x : int, x : int) = x["totor"]
x.x[x(nil, 5)][x(int {x = (), x = ()} , x.x())][int {x = while int {x = nil}  do int {x = "totor"} , x = x.x.x(while 5 do 5, x.x(break, ()))} ].x(x[()][while break do ()].x, x[nil].x.x := x.x.x.x())
type x = array of int
type x = array of int class x {var x := 5} 
class x {var x := 5} 
function x(x : int) : int = (5)-x.x(break, nil)
-int {x = int {x = if let  in 5 end then int {x = nil, x = nil} } } 
type x = {x : int} class x {var x := 5} 
class x {var x := 5} 
x[5].x[int {} ].x := let var x := 5 in end
class x {var x := 5} 
let class x extends int {var x := 5}  function x() : int = () var x := 5 in x(x(x((), ()), let  in end), (nil ; 5)) ; if x() then int {x = nil}  else -() end
if int {x = new int, x = x.x[new int].x(x(), new int)}  then x[5][while nil do nil].x else -let var x := 5 in end
function x(x : int) : int = while (5) do if break then "totor" else break class x {var x := 5}  class x {} 
-int {} 
-for x := if if int [break] of 5 then let  in 5 end then -if "totor" then 5 to x.x.x.x(if x := "totor" then x := break else -5, if () then 5-x.x(nil, nil)) do if -x then let var x := 5 in end else x()
class x extends int {var x := 5} 
x.x[x].x.x
int {} 
x.x.x[while x((), break) do if nil then break else "totor"][x(x.x := x("totor", break), int {x = int {} } )] := int {x = int {x = let  in 5 end, x = while break do "totor"} &new int-if nil then break else 5, x = let import "empty.tih" var x := 5 in let  in end ; 5 ; 5 end} 
x()-x.x[()-()][if int [5] of nil then x := "totor" else int ["totor"] of break].x(int {x = x.x.x((5), let  in 5 end)} , x[5].x := int [new int] of -())
let var x := 5 class x {}  var x := 5 var x := 5 in end
x(x(x["totor"].x.x(int [new int] of int {} , for x := new int to int [break] of () do if break then break), (x(break, ()) ; break ; 5)), x())
int [int {x = int {x = if let  in 5 end then nil+break else int {} } } ] of for x := int {}  to new int do while int {x = x(nil, "totor"), x = x()}  do -x.x()
let class x extends int {var x := 5}  in end
x[nil].x[if x := nil then x((), "totor") else if nil then "totor"].x.x()
var x : int := if "totor" then "totor" else 5 function x(x : int) = nil/()
x.x[x].x.x.x(for x := int {x = ("totor" ; 5)}  to x(while int {x = 5}  do for x := 5 to "totor" do (), int {x = break/nil} ) do (x((), "totor") ; "totor" ; 5), int [int [int {x = "totor", x = nil} ] of if 5 then ()] of int {x = for x := break to () do 5, x = int {x = break, x = break} } /x())
class x extends int {var x := 5} 
var x := new int
var x : int := x type x = array of int
(if (() ; 5) then if if () then "totor" then new int else int {x = new int} )
class x extends int {var x := 5} 
int {x = int {x = x.x := int {x = 5, x = "totor"} /while while 5 do break do int [()] of "totor"} } 
-while x(x&x(), for x := while () do break to "totor"&break do if break then ()) do int {x = for x := nil-nil to int {x = ()}  do if 5 then break} 
let var x : int := break var x := 5 in end
var x : int := int {x = 5, x = nil} 
function x(x : int, x : int) : int = int {} *if "totor" then 5 class x extends int {var x := 5}  var x := 5 import "empty.tih"
x.x.x.x[for x := if if nil then break then int {x = 5, x = 5}  else let  in 5 end to for x := for x := "totor" to () do "totor" to x.x((), nil) do let  in 5 end do x["totor"].x()]
x["totor"][int {} ][int {x = if nil then nil else 5} ].x := -x()
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = x() var x := 5 var x := 5 var x := 5
type x = array of int
class x extends int {var x := 5} 
class x {var x := 5} 
var x : int := int {x = 5} 
class x extends int {var x := 5}  class x {var x := 5}  class x extends int {}  import "empty.tih"
if x["totor"].x.x.x(x(x["totor"], int {} ), x.x.x := if x then x("totor", 5)) then int [int {x = x()} ] of x.x.x := for x := x((), 5) to -() do if 5 then 5
class x {var x := 5}  type x = class {} class x extends int {}  import "empty.tih"
let var x : int := 5 in end
int [x.x-if if "totor" then "totor" then x else x.x(break, break)&x()] of int {} 
int [x[5].x[int [while 5 do 5] of let  in end].x()] of int {} 
type x = array of int
var x : int := int {} 
function x(x : int) : int = if "totor"-nil then x := nil else while "totor" do 5 function x(x : int) = x := 5
int {x = if int {x = x(x("totor", nil), x := "totor")}  then int {x = let var x := 5 in break end, x = if for x := nil to 5 do break then x else for x := break to break do ()} , x = int {} } 
class x {var x := 5 var x := 5} 
if int {x = x.x.x}  then if (x.x(break, nil)) then int [int {x = x.x(nil, "totor")} ] of x.x else int {x = if x("totor", break) then if nil then 5, x = int {x = while () do (), x = x} } 
function x(x : int) : int = int {x = let  in end} 
-x.x[()|nil].x
function x(x : int, x : int) = x.x := int {x = "totor"}  class x extends int {var x := 5}  function x() = "totor"
if x() then let class x extends int {}  in int {}  ; let  in 5 end ; "totor" ; 5 end
function x(x : int) = x()|for x := break to () do 5 type x = array of int function x() = nil var x := 5 var x := 5
class x extends int {var x := 5 var x := 5} 
-x.x.x.x.x()
x.x.x.x[x.x[if () then () else "totor"] := x["totor"]] := int {} 
new int
type x = {x : int}
let class x {var x := 5}  in end
type x = class {var x := 5} function x(x : int) = x.x()
int {x = int {x = while let var x := 5 in end do x(new int, let  in 5 end), x = -if x.x("totor", break) then x((), break) else x()} } 
int {x = if (if nil then nil else "totor" ; 5 ; 5) then int {} } 
class x {var x := 5 var x := 5} 
(for x := int [while break do "totor"] of for x := break to "totor" do nil to if int {x = break, x = break}  then while nil do nil else int {}  do int {x = x("totor", nil), x = x := 5} )
class x extends int {var x := 5 var x := 5}  type x = {} type x = int import "empty.tih"
var x := x()
var x : int := int {x = (), x = "totor"}  function x(x : int) = -nil
x[nil][x := ()][for x := int [nil] of 5 to let  in end do let  in 5 end].x := if if let var x := 5 in "totor" ; 5 end then if -5 then let  in end else x() then int {x = let  in 5 end|x("totor", nil), x = if x() then int {x = "totor"}  else int {x = nil, x = nil} }  else x[break][int [5] of "totor"]
let function x(x : int) : int = let  in end function x() : int = 5 in end
type x = array of int function x(x : int) : int = x
x[5][int {x = "totor"} ].x.x
x[break].x[let var x := 5 in 5 ; 5 end].x.x(x.x.x[-()*(5)].x(x(while nil do 5, int {} )|new int*x(), x[()][if 5 then 5 else nil].x()), x())
x(let class x {}  in end, new int)
new int
x[5].x[int {x = -nil, x = (5)} ].x()-if let var x := 5 in end-let var x := 5 in end then x() else -if int {}  then while 5 do break else int {x = 5} 
type x = {x : int} class x extends int {var x := 5}  var x := 5
class x {var x := 5 var x := 5}  type x = {} type x = int
class x extends int {var x := 5}  var x := nil
while x()*if x(int {x = "totor", x = 5} , if 5 then () else nil) then x[break] := x.x((), 5) do let class x {}  var x := 5 var x := 5 in for x := int {}  to new int do x := () end
int {x = x.x.x.x := -x.x.x(x.x(5, break), new int), x = if int [while int {}  do x(5, break)] of int {x = x.x(), x = if () then break}  then -int [new int] of -5} 
class x {var x := 5}  var x : int := ()
var x := let  in 5 end
function x(x : int, x : int) : int = x[()] := new int
-while int {x = int {} }  do if (()) then int {x = x.x()}  else x[5].x(x := nil, x)
int {x = -x(int [x()] of if break then (), x(5, ())/let  in end)} 
type x = array of int
int [new int] of x.x.x[int {x = if nil then 5 else nil} ].x()
x(if x["totor"][if 5 then break else nil] then let import "empty.tih" var x := 5 in end, x())
for x := if x.x[for x := break to 5 do "totor"] then x(int {x = if nil then break} , (nil)) else x.x.x.x(int {} , x[5].x(-"totor", int {x = (), x = nil} )) to new int do int [x(x.x := x, while while break do () do let  in 5 end)] of while x[5] do if let  in end then (5)
function x(x : int, x : int) : int = if x := nil then int {}  else for x := () to break do ()
x.x.x.x[x[5].x].x(x.x[x].x.x(int [while int [5] of 5 do x(break, ())] of new int, if x.x then let var x := 5 in end else let var x := 5 in end), int [if x := "totor"|let  in end then int [x(break, 5)] of x("totor", "totor") else int {x = x.x((), 5)} ] of -(break ; 5))
var x := x.x((), 5)
while let function x() : int = nil in while (5) do int {}  end do if if for x := nil to break do 5 then x()&(break ; 5) then (while "totor" do 5 ; nil ; 5)
let function x(x : int) = if nil then () in int {x = (() ; 5)}  end
x()
(x(int {x = let  in end} , (() ; 5)) ; -x() ; int {x = nil}  ; 5 ; 5)
function x(x : int) = int [break] of nil&if "totor" then "totor" type x = class extends int{} class x extends int {} 
function x(x : int, x : int) = x(int [break] of (), "totor"&5)
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
function x(x : int) = x*while () do ()
int {x = int [int {x = let var x := 5 in end, x = x.x} ] of let var x := 5 var x := 5 in end} 
for x := x(int {x = if let  in end then x else int {x = break, x = break} , x = int [break|"totor"] of if nil then "totor"} , x["totor"].x.x()) to x(int [let var x := 5 in end] of int {x = -5} , int {x = int {} } ) do x.x[-"totor"][x[()].x(x(break, "totor"), let  in end)]
let function x(x : int) = x() function x() = nil in end
x(x.x[(5)][int {} ].x(let var x := 5 in end, for x := if (5) then x(break, 5) to let var x := 5 in () end do int {x = new int} ), x["totor"].x[if break-"totor" then int {} ] := x["totor"][int {x = nil} ].x(x(), -while nil do nil))
class x {var x := 5 var x := 5}  class x {var x := 5} 
if if int {x = x.x((), ()), x = let  in end} &while x() do int {}  then x() then -(-break) else if x["totor"][x].x() then let var x := 5 in end else int {} 
x[()].x[x.x := int [5] of 5][if while 5 do ()*new int then let  in end-let  in 5 end].x()
let class x {var x := 5}  in x["totor"][while 5 do nil].x() end
var x : int := x var x : int := "totor"
if int {x = x.x[x((), 5)] := int {} , x = int {x = int {} , x = int {} } }  then while int [x.x.x(new int, while () do 5)] of int {x = let  in end, x = while 5 do "totor"}  do x(int {x = int {x = (), x = break} } , let var x := 5 in end) else x[break].x[int {} ] := new int
type x = class {var x := 5}
class x extends int {var x := 5}  function x(x : int) = x() class x extends int {}  import "empty.tih" var x := 5
var x := while 5 do nil
int {x = int [x[nil] := x.x((), ())] of new int|for x := let var x := 5 in "totor" end to int {x = x(break, nil), x = int ["totor"] of break}  do let var x := 5 in end} 
x.x.x[x("totor", break)+int {x = nil} ][x.x.x := x()].x(for x := let var x := 5 var x := 5 in end to for x := while let  in end do -5 to x[nil].x(while nil do "totor", x.x()) do int {x = x((), break)}  do x[nil].x.x(), let class x extends int {}  var x := 5 in end)
class x {var x := 5 var x := 5}  class x {var x := 5} 
type x = class extends int{var x := 5}
type x = int
function x(x : int, x : int) = int {x = int [break] of nil} 
for x := x[nil][if () then break else nil].x.x(new int, x[()].x) to (new int ; let  in 5 end ; "totor" ; 5) do new int
function x(x : int) = for x := int {}  to let  in end do int {x = 5} 
var x : int := let  in end
x.x.x.x[int {} ].x(-x(x(), int [5] of nil)/for x := x(x, if "totor" then nil) to while x.x((), break) do int [5] of "totor" do x.x, int [x[nil][5-"totor"]] of x[break][new int].x(x[break].x(), int [let  in end] of new int))
class x extends int {var x := 5 var x := 5} 
x.x.x.x.x.x()
-x[5][let  in end][int {x = x.x("totor", nil)} ] := int [let var x := 5 in () ; 5 end] of (() ; 5)
function x(x : int) = int {x = break*"totor", x = int {x = 5} }  function x(x : int) : int = x := nil
(for x := int {x = let  in end, x = (5)}  to new int do let var x := 5 in "totor" end ; x[break] := x(break, ()) ; while break do nil ; () ; 5)
x()
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() : int = "totor" import "empty.tih" var x := 5
type x = {x : int} var x := break
int {x = x[break][-nil][int [while () do "totor"] of int {} ] := int {} , x = int {} } 
(let var x := 5 var x := 5 in end)
int {x = if int {x = let var x := 5 in "totor" ; 5 end}  then if x.x := x := break then new int else -x(), x = new int} 
int {} 
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = int {x = "totor", x = ()} 
class x extends int {var x := 5}  var x : int := () type x = int import "empty.tih"
let function x(x : int) = if 5 then "totor" else 5 var x := 5 in end
let function x(x : int) : int = for x := break to 5 do break in end
x.x[-5].x.x.x(new int, x())
let class x {var x := 5}  in int {x = if for x := () to () do 5 then if 5 then nil else if break then 5}  ; -if "totor" then () else break ; x.x() ; break end
-x(-x.x.x(int [()] of nil, (5)), int {x = (5 ; 5)} )
-int {x = x.x[int {x = 5, x = break} ], x = (int {x = "totor"} )} 
class x {var x := 5 var x := 5}  class x {var x := 5}  function x() = "totor"
int {x = -((5)), x = int {x = -int {} |for x := let  in 5 end to if () then () else break do for x := 5 to nil do break} } 
var x : int := if 5 then nil else () class x extends int {var x := 5}  var x := 5
type x = array of int type x = class extends int{}
x[()].x.x.x
class x extends int {var x := 5}  function x(x : int) = int {x = break}  function x() : int = 5 import "empty.tih"
class x {var x := 5} 
new int
var x := int {x = (), x = 5}  var x : int := 5 class x extends int {}  import "empty.tih" var x := 5
function x(x : int, x : int) = if x.x() then x else -()
type x = array of int class x {var x := 5}  function x() : int = nil var x := 5 var x := 5
class x {var x := 5} 
type x = class {var x := 5}
class x extends int {var x := 5}  class x {var x := 5} 
let function x(x : int) = x := "totor" type x = int in while let var x := 5 in end do x(int ["totor"] of 5, while "totor" do "totor") end
for x := (x[5] := x(nil, 5) ; while 5 do 5 ; "totor") to x.x[x("totor", ())][x.x := x] do let function x() = () in end
if let var x := 5 import "empty.tih" in end then (-x.x(break, ())) else if let var x := 5 var x := 5 in nil/5 end then int {x = int {x = x := break} } 
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  class x extends int {}  var x := 5
while x[()].x[x.x].x(x[5][for x := "totor" to () do 5] := x(), int {x = -int {} } ) do x[5].x[let var x := 5 in () ; 5 end].x(while while x.x(break, "totor") do int [nil] of () do int {x = nil, x = "totor"} /x, x[()].x := x.x)
x(x[5].x.x, let var x := 5 in -x := break end)
class x {var x := 5}  class x extends int {var x := 5}  type x = int
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = new int
function x(x : int) : int = x.x(nil, ())|break*break
let type x = int class x {}  var x := 5 var x := 5 in x(if while nil do "totor" then x, x[5] := int [nil] of break) ; if x then -nil else x := () end
class x {var x := 5 var x := 5} 
function x(x : int) : int = let var x := 5 in break end var x : int := break
let function x(x : int) = break|() function x() = "totor" var x := 5 in x() end
function x(x : int, x : int) : int = let var x := 5 in () ; 5 end
var x : int := int {x = "totor"} 
function x(x : int) : int = (5)*int {x = ()} 
let var x : int := nil in int {}  end
if x.x.x[int {x = x.x((), 5)} ].x() then int [new int] of int [x[nil]] of (break ; 5) else x[()][int {} ].x.x(if (5)/x(break, nil) then x[5] := if 5 then nil else x[nil].x(), int {} )
int {} 
var x := while () do 5 function x(x : int) : int = if break then nil else "totor"
class x {var x := 5}  var x := 5
function x(x : int, x : int) : int = x.x var x := () class x {}  import "empty.tih" var x := 5
function x(x : int) : int = x(int {} , int {x = break, x = nil} ) function x(x : int) = while 5 do 5 class x extends int {}  var x := 5 var x := 5
class x {var x := 5}  class x extends int {var x := 5}  function x() = "totor" var x := 5
while for x := x() to while while "totor" do 5 do let  in end&x.x := let  in end do x(int [5*nil] of x, x.x) do int {} 
function x(x : int) = x.x.x()
x.x[-5].x[let import "empty.tih" var x := 5 in (5) end] := int {x = int {x = x[break] := int [nil] of 5, x = int {x = x()} } } 
class x extends int {var x := 5 var x := 5} 
int [x.x.x[let var x := 5 in end] := let var x := 5 var x := 5 in for x := 5 to 5 do () end] of if -x[nil] := (5) then int {x = x.x.x(), x = while x do x}  else int [int {x = if () then break else nil, x = x()} ] of x[nil]
(x() ; (()) ; if nil then () else "totor" ; 5)
class x extends int {var x := 5}  class x {var x := 5} 
class x {var x := 5 var x := 5} 
var x := break|nil function x(x : int) = -5
class x {var x := 5}  class x {var x := 5}  type x = int var x := 5 var x := 5
new int
int {} 
x(let type x = int in end, x[5].x.x)
x.x[x := break].x[let import "empty.tih" var x := 5 in end]
function x(x : int, x : int) : int = new int
let function x(x : int) : int = x := () in end
function x(x : int) : int = if if "totor" then "totor" else () then x(nil, "totor") else let  in 5 end type x = array of int
function x(x : int) : int = int {x = x.x(nil, ())}  function x(x : int) : int = let  in end
new int
let function x(x : int) : int = let  in 5 end type x = int in int {x = x.x.x(), x = let var x := 5 in end}  ; -let  in 5 end ; x.x(nil, 5) end
new int
x.x.x[(5 ; 5)].x := int {x = x[5].x := int {} } 
class x {var x := 5}  function x(x : int) = x var x := 5 var x := 5
var x : int := let  in end class x extends int {var x := 5} 
let function x(x : int) : int = (5) in end
x[break].x[int [while () do nil] of x()][for x := if int {x = "totor"}  then x() else (5) to x()-let  in end do while x(break, "totor") do int {x = 5, x = break} ] := int {x = x(), x = let import "empty.tih" var x := 5 in for x := nil to 5 do 5 ; "totor" end} 
new int
x[break][new int][x(int [()] of nil, x)][(nil ; 5)-(nil ; 5)].x(-(x.x()), while for x := let var x := 5 in end to x.x.x(x(), new int) do if int [5] of 5 then x.x(5, "totor") else if "totor" then 5 do x.x[(5)].x(("totor" ; 5), if x.x() then int [5] of ()))
x.x[int {x = 5, x = "totor"} ].x.x.x()
function x(x : int) = int [for x := nil to () do 5] of int {x = nil} 
int {x = int {x = for x := let var x := 5 in end to while () do 5/x.x() do x(), x = new int} } 
for x := x(int {x = -int {x = 5, x = ()} } , x()) to let function x() = nil var x := 5 var x := 5 in int {x = for x := nil to () do break}  ; break/5 ; nil ; 5 end do (x() ; if () then break else 5)
if int {x = x[()].x.x(int [x(break, ())] of new int, let var x := 5 in () end)}  then x.x.x[-int [nil] of nil].x(x[()][x.x("totor", ())].x(int {x = new int, x = int {} } , x["totor"].x()), let var x := 5 in (5) end) else x(let import "empty.tih" in end, int [x()] of let var x := 5 in break ; 5 end)
int {x = x(), x = x[5][let  in end][int {x = nil-5, x = for x := "totor" to 5 do "totor"} ].x(int [if x then x()] of x(), int [let var x := 5 in "totor" end] of int {x = int {} , x = ()|5} )} 
x()*x[break][x(5, break)][x["totor"].x(let  in 5 end, x((), ()))].x(let var x := 5 var x := 5 in end, x.x[if nil then break] := int [()*5] of if 5 then nil)
var x : int := for x := break to "totor" do 5 var x : int := "totor" function x() = nil
function x(x : int) : int = x[nil].x() class x {var x := 5} 
if while for x := int {}  to x() do int {x = ()*"totor", x = while () do 5}  do if int {x = int {x = nil, x = 5} , x = int {x = "totor"} }  then int {}  then int {} 
for x := x.x[while () do break].x := let var x := 5 in end to int {x = x[()][x()] := new int, x = x.x[-nil].x(x.x := int {} , new int)}  do int {x = int {} } 
new int
function x(x : int, x : int) : int = x(-"totor", x((), ()))
function x(x : int, x : int) : int = x()
class x extends int {var x := 5}  var x : int := break
class x extends int {var x := 5 var x := 5} 
x[nil].x.x.x.x(-(x("totor", break) ; break ; 5), let var x := 5 import "empty.tih" var x := 5 in end)
type x = class extends int{var x := 5}
x[5][let  in 5 end][for x := x := () to while nil do "totor" do for x := () to nil do 5].x := int {} 
var x : int := let  in end
var x : int := x.x()
var x : int := while break do break class x extends int {var x := 5}  function x() : int = nil
class x {var x := 5 var x := 5}  var x : int := break
x.x.x[x[nil]].x
class x {var x := 5}  class x extends int {var x := 5} 
var x : int := int {}  function x(x : int) : int = x := "totor" class x {}  var x := 5 var x := 5
let class x {var x := 5}  function x() : int = break in x[()][for x := 5 to () do nil] := ("totor") ; int {x = (), x = break} +int {x = (), x = "totor"}  ; (5) end
int [-let var x := 5 var x := 5 in end] of (while int {}  do let  in end)
type x = class {var x := 5} class x extends int {var x := 5} 
function x(x : int) : int = int {}  function x(x : int) = for x := 5 to nil do () class x {} 
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = (5)
var x := x.x((), ())
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = let var x := 5 in nil end
type x = {x : int}
-x.x[for x := nil to break do 5]-(let var x := 5 in 5 end)
class x extends int {var x := 5} 
x[5].x.x := if -nil&() then if if 5 then break else break then int {}  else -5-for x := x.x.x to x(let  in 5 end/(5), if while () do nil then int [()] of () else let  in end) do new int
function x(x : int, x : int) : int = int {}  type x = class {} function x() : int = nil
type x = class extends int{var x := 5}
int {x = -x[nil][let  in end] := for x := x to let  in end do let  in 5 end} 
x.x.x.x[if int [while 5 do 5] of for x := nil to "totor" do break then x[nil] := int {x = break}  else -new int].x()
class x {var x := 5 var x := 5}  type x = {}
int {} 
int {x = if x.x.x.x() then int {x = x()} , x = -x.x.x} 
x(x[break].x[if int {x = nil}  then let  in end else x()], -x())
class x extends int {var x := 5 var x := 5} 
int {x = int {x = x(), x = x[break].x()} -new int} 
x[nil].x.x[if int [5] of nil then int {x = nil} *x.x := if "totor" then nil else nil].x(int {x = -x(x(), let  in 5 end), x = -int [x.x()] of x()} , x.x[let  in end][x(x(), let  in 5 end)] := x[5][for x := break to nil do break].x(int {x = x.x((), ())} , if x(nil, break) then int [5] of () else if "totor" then 5))
while for x := if x.x then -int {x = "totor", x = nil}  to x.x.x do let var x := 5 in while "totor" do nil ; 5 ; 5 end do let function x() : int = () var x := 5 var x := 5 in x() ; new int end
(for x := x[()] to while () do nil+x(break, "totor") do if let  in 5 end then x.x(5, "totor") ; -if () then "totor" ; new int ; "totor")
function x(x : int, x : int) : int = x.x
type x = class extends int{var x := 5} function x(x : int) = let  in end
x.x[int ["totor"] of 5][(break)][let var x := 5 in end] := if int [x.x.x()] of x[5].x() then x.x[let  in 5 end].x(if nil then "totor"|x.x(5, nil), let var x := 5 in end)
int {x = if int [if if break then () else "totor" then for x := break to () do nil else for x := break to nil do break] of (nil ; 5) then if if -() then x else if nil then () then x(x.x((), break), if "totor" then nil) else new int, x = if int {x = while int [()] of break do int ["totor"] of "totor"}  then x[break].x.x(x(if break then break, (5)), new int) else int [if int [5] of () then let  in end else x.x("totor", ())] of x[5] := nil|5} 
x(x[break].x[new int].x(), let function x() = () in x.x.x() ; x.x() ; break ; 5 end)
class x {var x := 5} 
if x.x.x[x(if break then 5 else (), int {x = "totor"} )].x() then -while if x then nil-"totor" do -x else let class x {}  var x := 5 var x := 5 in end
let class x {var x := 5}  in new int end
x.x.x.x[for x := int {}  to x[nil].x() do x[nil].x()].x()
var x : int := int [break] of nil
function x(x : int) : int = int {} 
var x : int := x.x((), nil)
function x(x : int, x : int) : int = int {} 
x[break][int {x = "totor", x = nil} ][let var x := 5 in 5 end][let var x := 5 in end].x()
new int
x(int {x = -x()} , x())
x(int {x = x[5].x, x = x[break].x} , -x[nil][x()].x())
x.x.x[if x(nil, 5) then ()*nil else while () do break].x.x()
if let type x = int import "empty.tih" var x := 5 in end then x[break][x()][x.x.x()]
x()
int {x = if while x[5] := int {x = "totor"}  do x[break].x(x(), x.x((), 5)) then x.x.x else let var x := 5 in end} 
if for x := for x := let var x := 5 in 5 ; 5 end to -let  in 5 end do x[5] := int ["totor"] of nil to x(if if break then nil else 5 then x(), x[5].x(x, x := nil)) do int {x = x(), x = x.x(nil, 5)} *(()) then x.x[new int][let var x := 5 in end].x(if x[nil].x(int {} , if "totor" then "totor") then if if () then 5 else () then ()|nil else -for x := "totor" to break do nil, let var x := 5 in end)
int {x = if for x := new int to x() do int [x.x(nil, ())] of let  in 5 end then x[()].x := int {x = if 5 then break else 5} , x = while x(int [-"totor"] of x.x(5, "totor"), x[break] := new int) do (-5 ; 5)} 
var x := int {} 
x[break].x.x[let var x := 5 var x := 5 in end].x()
x()
var x := new int
type x = class extends int{var x := 5} type x = array of int class x extends int {} 
int [int {x = if for x := int {x = nil}  to int {}  do new int then -int [nil] of break, x = new int} ] of x.x[new int] := x["totor"].x(-nil, let  in end)|(int {}  ; "totor" ; 5)
var x := x
x(x[nil].x.x.x(), while for x := int {}  to int {}  do -if () then nil do x.x[while "totor" do break])
x.x[let  in end].x.x
var x : int := int [5] of ()
function x(x : int) = x[break].x()
x.x[while nil do "totor"].x.x := x.x.x[for x := -break to while 5 do break do x.x()].x((-nil), x())
var x : int := for x := break to "totor" do nil
(if x.x := x(5, ()) then new int)
function x(x : int, x : int) : int = while new int do int {x = nil}  type x = array of int
x.x[x.x(break, nil)][int [x] of if () then nil].x
class x extends int {var x := 5 var x := 5} 
x[5][x := 5][int [new int] of x.x()].x.x()
function x(x : int) = int {x = x(nil, nil), x = new int}  class x extends int {var x := 5}  function x() : int = nil
type x = class extends int{var x := 5} var x : int := "totor" var x := 5
x[break].x.x.x
x["totor"][while "totor" do nil][x.x := int [nil] of 5][int {x = x.x := "totor"|nil, x = if if 5 then 5 else () then int {x = break} } ].x(x.x.x.x, x["totor"].x.x)
x[5][if nil then 5][x[()].x(let  in end, int [nil] of nil)][int {x = x[nil].x()} ]
while while x[break] do while x() do int [nil] of nil do int {x = x.x, x = new int} &int {} 
while x() do x()
function x(x : int) : int = if () then 5*(5) class x extends int {var x := 5}  function x() : int = break
var x := x(break, break)
type x = class {var x := 5} class x extends int {var x := 5}  function x() = nil
var x : int := int [5] of break class x extends int {var x := 5}  function x() = "totor"
x()
int [new int] of int {x = while x["totor"].x() do x["totor"] := int [()] of nil} 
for x := x[nil][x.x("totor", break)][x.x.x(let  in end, int {x = 5, x = ()} )].x(int {x = int {x = (5), x = if "totor" then break} } , int [int {x = x.x(5, "totor")} ] of x[break].x()) to if for x := for x := x() to for x := nil to 5 do break do x := 5 to x.x := while 5 do break do int [if nil then break else ()] of int {}  then (int {} ) else let import "empty.tih" in end do x.x[5/break].x := int {x = int {} , x = x[break]} 
type x = {x : int} var x := break
x(let class x {}  import "empty.tih" in end, let class x {}  in for x := "totor" to nil do nil/-() ; if break then nil else break ; () ; 5 end)
class x {var x := 5}  class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) : int = int ["totor"] of break class x extends int {} 
function x(x : int, x : int) = for x := let  in end to let  in 5 end do x.x() function x(x : int) : int = int {x = (), x = break}  type x = int
(x.x.x ; new int)
type x = array of int
let var x := break function x() : int = "totor" in let var x := 5 in x := 5 end end
function x(x : int) = for x := x to x do int {} 
-x()
x(x[break].x.x, int {x = int {x = x.x := if () then "totor" else (), x = int [(5)] of x((), break)} } )
for x := while int {x = x.x.x(if "totor" then 5, new int), x = x["totor"] := for x := "totor" to 5 do nil}  do x() to x(x(x.x := x("totor", 5), x()), let import "empty.tih" in int [()] of nil end) do int {x = int {} , x = x.x.x.x()} 
-int {x = if x.x then int {}  else x[()].x(if nil then break else break, x.x("totor", ())), x = x[5][-"totor"] := if let  in 5 end then let  in end else x.x()} 
-(for x := -5 to for x := break to 5 do 5 do "totor"+break)
x.x.x.x[int [int {x = let  in end} ] of (break ; 5)]
var x : int := (5)
int [let type x = int import "empty.tih" in new int end] of int [int [new int] of x.x.x()] of x["totor"].x := if x.x("totor", break) then x := "totor"
x[5][x()].x[if x() then int {x = int [5] of break}  else -let  in end] := x.x[x.x(break, break)].x.x(if -(5) then x.x.x(), let var x := 5 var x := 5 in end)
if x[()][int {x = "totor", x = nil} ].x := int {x = x.x.x(let  in end, -5), x = int [nil] of nil*x := 5}  then let function x() = nil in int [x()] of x end
x[nil].x[for x := int [()] of () to x.x("totor", ()) do int {x = break} ].x.x()
function x(x : int) : int = x[nil] type x = {}
var x := x := 5
class x {var x := 5 var x := 5} 
(int [int {} ] of x() ; let var x := 5 in end ; x())
function x(x : int) : int = let var x := 5 in 5 end function x(x : int) : int = break|"totor" function x() = 5 import "empty.tih"
class x {var x := 5} 
type x = class extends int{var x := 5} class x {var x := 5}  function x() : int = nil
var x := int {}  function x(x : int) = let  in 5 end type x = int
x.x.x[int {x = int {x = 5} , x = x} ].x()*if int {x = x.x((), nil)} /x[5] := for x := "totor" to "totor" do "totor" then let import "empty.tih" var x := 5 in x.x() end
class x extends int {var x := 5 var x := 5}  function x(x : int) = (5) class x extends int {} 
while x.x.x.x.x() do int {x = x(), x = (new int ; 5 ; 5)} 
var x : int := x()
function x(x : int) : int = x(x(), int {x = 5, x = 5} )
class x extends int {var x := 5} 
int [int [(x((), 5) ; ())] of new int] of int {x = if -x then x(), x = new int} 
x[()].x[-x.x()].x := x()
function x(x : int) : int = new int
x.x.x[int {x = x.x("totor", "totor"), x = (5)} ].x.x(if let import "empty.tih" in (5) ; 5 ; 5 end then x[nil][x] := int {x = int {x = break} }  else if let var x := 5 in "totor" end then x() else (5), for x := if x(x.x(5, nil), int {x = (), x = "totor"} ) then let var x := 5 in break end else for x := for x := () to 5 do "totor" to x.x() do x to int {x = x.x()--5}  do -x())
function x(x : int) : int = x[()].x(x(), int {} )
x[5][int {x = break, x = nil} ][while break|5 do x.x(nil, nil)][x["totor"][(5)].x(int {x = x} , new int)]
new int
function x(x : int) = if if "totor" then break else nil then int {}  else int {x = 5}  function x(x : int) : int = x() class x {}  var x := 5 var x := 5
function x(x : int) = while if () then 5 do let  in end
while x[nil][while () do "totor"][x(x.x("totor", nil), x := ())].x(x.x[x.x()].x(), x()) do -int {} 
function x(x : int, x : int) = if x.x(5, break) then -nil function x(x : int) : int = x.x() class x extends int {}  var x := 5 var x := 5
if (x.x.x()) then int [if x[5] := int {}  then (5)] of new int else x.x[int {x = nil, x = break} ].x.x()
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  var x := 5 import "empty.tih" var x := 5
int {x = int {x = int {x = (nil ; 5)} , x = int {x = x := 5} -for x := (5) to break*() do for x := () to "totor" do 5} , x = int [x.x[(5)] := x()] of x.x[let  in end] := -x} 
let class x {var x := 5}  function x() = "totor" var x := 5 var x := 5 in end
type x = {x : int}
function x(x : int) = if for x := nil to () do "totor" then for x := 5 to "totor" do nil else new int type x = int
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = x(break, "totor")
int {} 
class x extends int {var x := 5 var x := 5} 
-x[5].x.x.x(x(int [x(nil, "totor")] of x((), "totor"), if new int then for x := nil to nil do 5 else x.x()), if x[5] then (break ; 5))
int {x = int [x()] of let var x := 5 var x := 5 in int {x = "totor", x = nil}  ; nil ; 5 end, x = let import "empty.tih" in end|let var x := 5 var x := 5 in x() end} 
class x extends int {var x := 5 var x := 5} 
x[break].x[x()].x.x(x[()].x.x := -while x("totor", break) do int {x = "totor", x = ()} , (while int {x = 5}  do x() ; let  in 5 end))
if int [x.x.x.x(if while () do "totor" then x() else x(), x[()])] of int {x = x[5].x(x((), nil), x.x((), "totor"))}  then if int {x = x[nil].x(x(break, ()), x := "totor")}  then int {x = (() ; 5)}  else new int
class x extends int {var x := 5 var x := 5} 
int {x = x[break][x := "totor"]/for x := --break to int {x = if break then nil else 5, x = int [break] of "totor"}  do new int, x = int [if int {x = for x := "totor" to 5 do ()}  then let var x := 5 in nil end else -x.x()] of while x.x do while int {x = (), x = break}  do (5)} 
int {x = if int {x = let var x := 5 in () end, x = if x.x() then int [nil] of ()}  then x.x.x, x = let class x {}  import "empty.tih" in end} 
class x extends int {var x := 5}  function x(x : int) : int = let  in end
class x extends int {var x := 5 var x := 5} 
let function x(x : int) : int = x := "totor" in x[nil][int {x = break} ] end
type x = class {var x := 5} class x extends int {var x := 5} 
new int
int [x(x.x.x := let var x := 5 in nil ; 5 end, let var x := 5 var x := 5 in int {}  ; "totor" ; 5 end)] of (int {}  ; if nil then "totor" ; () ; 5)
let class x {var x := 5}  in end
let function x(x : int) = while "totor" do 5 in end
class x {var x := 5} 
var x : int := x.x("totor", 5) var x := nil
let class x {var x := 5}  class x {}  var x := 5 in end
int {x = x[()].x[int {x = "totor"} +-"totor"] := x[nil][x()] := int {} , x = while new int do x(x.x.x(for x := break to nil do 5, for x := 5 to nil do break), x())} 
int {x = x(x(), let var x := 5 in x.x(break, ()) ; break end), x = x()} 
x(if new int then let import "empty.tih" var x := 5 in if break then nil else break ; 5 ; 5 end, while x.x[x] do if -(5) then let  in 5 end|(5) else int {x = x} )
x[nil][int {x = break, x = 5} ].x[if (5 ; 5) then x["totor"].x() else while x.x() do x(break, "totor")]
class x {var x := 5} 
x[break][int {x = 5} ].x[(let  in 5 end ; nil ; 5)].x(while for x := for x := x() to x.x() do x.x() to for x := int {}  to for x := "totor" to break do () do x() do int {x = int {x = nil} }  do x(), int {x = while -x := break do x+(5), x = x[break].x.x()} )
x[nil].x.x.x
class x extends int {var x := 5}  function x(x : int) = for x := break to 5 do () function x() = "totor"
type x = class extends int{var x := 5} var x := "totor"
int {} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = -break function x() = ()
int {x = int {x = let var x := 5 in x end, x = if int {x = int [()] of "totor"}  then x[5].x(x.x(), for x := nil to () do break) else int {} } , x = if x() then int {x = x.x.x()}  else for x := x.x.x() to int {x = if 5 then "totor"}  do let var x := 5 in end} 
while x() do int {} 
type x = class {var x := 5}
new int
class x {var x := 5 var x := 5}  type x = array of int
x.x.x.x[x(let var x := 5 in end, x.x := let  in end)].x()
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  function x() : int = ()
(for x := (() ; 5) to x.x do ("totor"))
if x["totor"].x.x then if -let  in 5 end then (break ; 5)+new int else let type x = int in end
class x {var x := 5} 
(while new int do x := ()-let  in 5 end)
type x = class {var x := 5}
while x[()].x[x(while nil do 5, -nil)].x(while x.x do x[5].x(int {} , if break then break else "totor"), int [for x := "totor"/() to int {x = "totor", x = "totor"}  do while () do "totor"] of x[()].x()) do x[5].x.x := let import "empty.tih" in end
function x(x : int) : int = int {}  class x extends int {var x := 5}  class x extends int {} 
class x extends int {var x := 5} 
let function x(x : int) = x.x((), ()) class x {}  var x := 5 in int {x = for x := x(nil, nil) to while nil do nil do if nil then (), x = x[()].x()}  end
int {x = x.x[let  in 5 end].x := int {x = x((5), x((), break))} , x = x()} 
(int {x = x.x}  ; for x := -() to x(5, nil) do if "totor" then "totor" ; x.x(break, nil) ; 5 ; 5)
function x(x : int) = x.x := "totor"&() class x extends int {var x := 5}  var x := 5
var x : int := (5)
class x {var x := 5 var x := 5} 
for x := for x := if if for x := break to nil do break then x.x(break, "totor") else (5) then int {x = if nil then break}  else new int to x.x[int {} ] do while int [let  in 5 end] of if 5 then break do int {x = x := break, x = let  in end}  to x.x.x.x do for x := let var x := 5 var x := 5 in end to while x() do x() do int {} 
type x = array of int class x {var x := 5} 
type x = array of int function x(x : int) = int [nil] of nil class x {}  var x := 5
function x(x : int, x : int) : int = while x.x(nil, 5) do new int
while x["totor"][x.x()].x do for x := if x(int {x = break} , let  in 5 end) then -int {x = 5}  else int {x = while break do "totor"}  to int {x = x("totor", break)} -int {x = x.x((), 5)}  do let import "empty.tih" var x := 5 in let  in end ; break end
x[()].x.x.x := x.x[let  in 5 end][x := nil-x.x("totor", "totor")] := if int {}  then x[5] := while () do ()
if ((5) ; nil)-let var x := 5 in end then new int else (x.x := if nil then break else ())
function x(x : int) : int = while x.x("totor", 5) do -()
class x extends int {var x := 5}  var x := ()
new int
int [x["totor"].x] of for x := let var x := 5 in end to x.x do x()-for x := ((5)) to (let  in 5 end) do int {x = for x := let  in 5 end to break-break do int {x = 5, x = "totor"} } 
int {x = if int {}  then if x.x then if x() then int [()] of () else new int} 
let class x extends int {var x := 5}  in end
function x(x : int) = -let  in 5 end
class x {var x := 5 var x := 5}  class x {var x := 5}  function x() = break var x := 5 var x := 5
class x {var x := 5}  class x {var x := 5} 
x.x[x.x()].x.x := int {x = new int} 
function x(x : int) = int {} &while break do nil
int {} 
function x(x : int, x : int) : int = (nil ; 5) class x extends int {var x := 5} 
-x()
class x {var x := 5} 
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  function x() : int = nil
function x(x : int, x : int) : int = x()
class x {var x := 5} 
let class x extends int {var x := 5}  in while let var x := 5 in end do if x("totor", "totor") then new int else x.x() end
class x {var x := 5 var x := 5}  var x : int := 5
let function x(x : int) = int ["totor"] of nil class x {}  var x := 5 in end
new int
x.x.x[(5 ; 5)][x.x.x := nil&nil/int ["totor"] of break] := int {x = let var x := 5 in 5 end&x["totor"].x()} 
type x = {x : int}
while x[nil].x[if x.x(5, "totor") then x].x(x[nil].x := while x.x(break, break) do x.x((), "totor"), x[break]+(())) do while new int do x.x[for x := () to () do nil].x(while int {}  do int {x = nil, x = nil} , ("totor" ; 5))
if new int then x.x.x[(break ; 5)].x(int [let var x := 5 in end] of int {x = int {} , x = while () do break} , (x() ; break ; 5)) else new int
var x := int {x = break} 
type x = class extends int{var x := 5}
x()
class x {var x := 5}  class x extends int {var x := 5}  function x() : int = "totor"
function x(x : int) = int [new int] of for x := () to () do 5
x.x.x[x()].x.x(x[nil].x[let var x := 5 in end].x(), int {x = if int {x = nil, x = 5} -int [()] of break then (() ; 5) else -new int} )
new int
int {x = int {} , x = let function x() : int = break var x := 5 in int {x = break&5, x = x}  ; -5 end} 
if while new int do x() then for x := if new int then int {}  else new int to x.x()/(5)|let var x := 5 in 5 ; 5 end do int {x = let var x := 5 in end}  else -let var x := 5 var x := 5 in let  in end ; "totor" ; 5 end
class x {var x := 5}  var x : int := () class x extends int {}  import "empty.tih"
function x(x : int, x : int) = x.x.x(new int, x.x())
int {x = int {x = (x()), x = int {} } } 
class x extends int {var x := 5}  function x(x : int) = let  in 5 end class x extends int {}  import "empty.tih"
int {} 
int {x = x[()].x.x.x(int {x = for x := x.x() to x("totor", break) do (5)} , if x[()].x(if break then () else (), int [break] of 5) then x.x.x())} 
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  class x {} 
if x.x.x.x := x() then for x := new int to x.x[x((), ())].x() do int {} 
class x extends int {var x := 5} 
function x(x : int) = int [if break then ()] of int {x = break, x = ()}  function x(x : int) = let  in end
var x : int := x()
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  class x extends int {}  var x := 5 var x := 5
function x(x : int, x : int) : int = for x := (5) to let  in end do if 5 then nil else ()
function x(x : int, x : int) = int {} 
let function x(x : int) : int = let  in end var x := 5 in new int ; x[nil].x() end
var x : int := int {} 
int {x = x.x.x.x()&x(for x := x := nil to -break do x.x(), x.x)} 
if x[break][int {} ][x()] := x.x.x.x() then x.x[int {x = nil} ][-let  in end] := x.x.x.x()
function x(x : int) : int = new int
if new int then x[()][int {x = 5} ][("totor" ; 5)] := int [x(x(nil, nil), x.x())] of if if () then 5 then (5) else int {} 
x(int {x = x[nil].x := for x := new int to let  in end do int {x = break, x = 5} } , x[break][(5)].x := (if 5 then break))
function x(x : int) = int {}  class x extends int {var x := 5} 
type x = int class x extends int {var x := 5} 
x.x[int {x = "totor", x = nil} ][-x.x()].x := if int {}  then for x := int [5] of nil to new int do -break/x(x.x((), "totor"), int ["totor"] of 5)/for x := while "totor" do () to 5|"totor" do new int
int {x = int {} -let import "empty.tih" var x := 5 in end} 
type x = class extends int{var x := 5} function x(x : int) : int = if break then () function x() = break var x := 5 var x := 5
function x(x : int) = (nil ; 5)
--let var x := 5 in end
int {x = int [if x(()&"totor", new int) then int [x(5, 5)] of -"totor" else x.x.x()] of if x[5].x() then let var x := 5 in end, x = new int} 
class x extends int {var x := 5 var x := 5}  type x = {} type x = int var x := 5 var x := 5
function x(x : int) : int = x[5] := int {x = "totor", x = 5}  function x(x : int) : int = x((), 5)
var x : int := if () then break var x := nil type x = int import "empty.tih"
int {} 
x["totor"].x[let var x := 5 in end].x.x(if x.x.x.x(for x := x.x("totor", nil) to int {x = "totor"}  do x, int {x = "totor", x = nil} /int {} ) then new int, x[break].x.x := let import "empty.tih" in end)
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() : int = nil var x := 5
new int
int {x = int {} } 
x[()].x[x[break].x()].x
for x := int [x.x.x] of x.x[int {x = nil} ] to int {}  do let type x = int var x := 5 var x := 5 in end
x(int {} , x.x.x[x.x].x())
if int {x = if let var x := 5 in end then int {x = while 5 do nil, x = x.x(break, break)}  else x.x.x(let  in 5 end, x)}  then if x.x.x.x(if x.x((), break) then -() else int [()] of 5, if (5) then x.x((), 5) else if 5 then "totor") then let var x := 5 var x := 5 in end else int [(() ; 5)] of if if "totor" then 5 then int {}  else if break then break else int {x = int {x = x.x.x(if 5 then 5, (5)), x = (nil ; 5)} , x = let var x := 5 in end} 
var x := while nil do nil
while x["totor"][(5)][if x("totor", "totor") then 5+break else int {x = 5} ] := x(let  in end+x, x.x.x(x.x("totor", nil), let  in end)) do if x["totor"].x then x.x[x()].x(int {x = (5)} , x.x := nil|break)
class x extends int {var x := 5}  var x : int := break class x extends int {}  import "empty.tih"
function x(x : int, x : int) : int = if let  in 5 end then int {x = "totor", x = break}  else (5) class x {var x := 5}  var x := 5
x.x.x[x(let  in end, new int)][x()] := x.x[x.x()].x.x()
class x {var x := 5} 
let type x = int in x.x[-break].x(for x := new int to let  in end do x, x.x := let  in 5 end) ; x[()].x(-5, x()) end
x(int {x = x[5].x.x(), x = let var x := 5 var x := 5 in int {x = break}  end} , -int {x = if int {x = break}  then int ["totor"] of nil} )
int {x = int [let var x := 5 var x := 5 in end] of (if break then nil else "totor" ; "totor")} 
new int
function x(x : int, x : int) : int = let var x := 5 in end var x := 5 type x = int
new int
x.x.x[if x := () then let  in end else let  in end].x.x()
int [if (x("totor", 5)) then int [let var x := 5 in () end] of x.x := new int] of let type x = int var x := 5 in end
if int {}  then x(int {} , (() ; 5))-x()&let  in 5 end|let var x := 5 in () end else x.x[let  in 5 end].x
class x {var x := 5}  type x = {}
function x(x : int) : int = x.x := x()
function x(x : int, x : int) = x.x := let  in 5 end var x := break class x {} 
type x = class extends int{var x := 5}
function x(x : int, x : int) = if x then x(5, ()) else ()&break
x["totor"].x.x.x
-int {x = int {x = if for x := 5 to nil do () then if 5 then () else break else int {x = nil} , x = x[()].x()} , x = while int [int {x = nil, x = 5} ] of new int do -while () do 5} 
function x(x : int, x : int) = x[nil] := if "totor" then 5 else break
x.x[x.x("totor", nil)].x[int {x = for x := break/() to -() do break-"totor"} ].x(x.x[if () then () else "totor"].x, --x[()].x())
if x.x[new int][if x := 5 then let  in end else int [5] of "totor"].x(while x()|if nil then break else 5 do int [int {} ] of if () then 5, x()) then x["totor"].x.x
new int
x.x.x[if nil then break+int {x = nil} ][x.x[for x := nil to break do break]]
x[break][x()][x[5].x()].x := for x := if int {}  then for x := "totor" to () do "totor"|int [x(nil, ())] of x to new int do x(if x then int {}  else ()|nil, if for x := 5 to () do "totor" then while nil do ())
function x(x : int) = if for x := "totor" to 5 do () then int {}  class x extends int {var x := 5} 
class x {var x := 5} 
function x(x : int) = let var x := 5 in break end
class x extends int {var x := 5 var x := 5} 
type x = int
let var x : int := 5 in end
function x(x : int) : int = x[break] := let  in end function x(x : int) : int = int ["totor"] of nil
function x(x : int, x : int) : int = for x := "totor" to "totor" do 5/int ["totor"] of 5 function x(x : int) : int = let  in 5 end var x := 5 var x := 5 var x := 5
new int
type x = {x : int} type x = class {} type x = int var x := 5
new int
class x {var x := 5}  type x = class extends int{}
new int
x(if int [x.x.x(if 5 then nil, (5))] of (() ; 5) then x.x.x := let var x := 5 in break ; 5 end, if if int {x = break, x = "totor"}  then break/nil else for x := 5 to break do ()*if (5) then (5) then x())
int {x = x.x.x[x[nil]]} 
int {} 
function x(x : int, x : int) = x() function x(x : int) = int {}  function x() = break
function x(x : int) = let var x := 5 in end
class x extends int {var x := 5 var x := 5} 
if x.x[x][int ["totor"] of 5+x.x()].x(x[5].x.x(x(for x := "totor" to () do "totor", -5), if x((), ()) then let  in 5 end else for x := () to break do 5), let import "empty.tih" var x := 5 in end) then int {}  else let function x() = () in if int {x = (), x = ()}  then (5) else (5) end
var x := x() class x {var x := 5} 
var x : int := int [5] of "totor" function x(x : int) : int = x.x()
function x(x : int) = int {x = x := "totor"}  type x = class {} var x := 5 var x := 5 var x := 5
class x extends int {var x := 5}  class x {var x := 5} 
class x extends int {var x := 5} 
function x(x : int) = x[break] := new int type x = class {}
type x = int type x = array of int class x {}  var x := 5 var x := 5
let class x {var x := 5}  in x() ; x[()] end
(new int)
function x(x : int, x : int) = x(let  in end, x)
if int [if int [while 5 do "totor"] of x.x(5, ()) then if (5) then x.x((), nil) else new int else -if break then "totor"] of if x["totor"].x() then if int {x = nil, x = "totor"}  then for x := 5 to () do break else let  in 5 end then int {x = int [for x := if "totor" then 5 to x("totor", nil) do x.x()] of x.x := if "totor" then nil, x = while x(int {x = nil} , int {x = break} ) do x["totor"].x()} 
let function x(x : int) = x in x(int {x = x, x = if break then ()} , if x((), break) then (5) else -()) ; -x := () ; int {x = "totor"}  end
function x(x : int, x : int) : int = -x("totor", nil) class x extends int {var x := 5}  var x := 5
if if int {}  then x[()][x()].x(int {x = for x := "totor" to () do "totor"} , int {x = int {} , x = if "totor" then ()} ) else x.x[int {x = (), x = "totor"} ].x() then if -int {} &x.x(break, ()) then int {x = x(int {x = "totor", x = nil} , int [break] of "totor"), x = if int {x = nil, x = nil}  then x.x(nil, 5) else let  in end}  else x[nil]-x() else let function x() : int = nil var x := 5 var x := 5 in end
int {} 
while int {x = for x := for x := break to () do 5 to if "totor" then 5 else break do int {} -int [x := "totor"] of let  in end, x = x[break].x.x()}  do int {x = for x := if 5 then nil else nil|int {x = "totor"}  to let var x := 5 in nil end do if while break do break then int {}  else x.x("totor", break)} 
function x(x : int, x : int) : int = x[nil].x()
function x(x : int) : int = x()
(x(while for x := () to () do 5 do int {} , let var x := 5 in nil end))
new int
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) : int = int {}  class x extends int {} 
function x(x : int) : int = if while 5 do 5 then "totor"|5 else if () then break else "totor"
function x(x : int, x : int) : int = int {x = if nil then "totor", x = new int} 
x[nil][if 5 then break][new int].x.x(x[nil].x[if if "totor" then "totor" then int {}  else let  in 5 end], int {x = x.x[nil-nil].x(if x((), 5) then while nil do break, x.x.x(x.x(break, "totor"), int {x = nil} )), x = let var x := 5 var x := 5 in end} )
function x(x : int, x : int) : int = int {x = x.x(nil, "totor")}  type x = array of int
type x = int
x[nil][x][-nil|break][if for x := let  in end to if nil then "totor" else nil do break/() then int {}  else x.x.x()].x(for x := x(if x(nil, ()) then x.x(break, break), new int) to let var x := 5 in x := break ; "totor" ; 5 end do -x(5, nil)&x := "totor", while for x := if x then while "totor" do () to int {x = new int, x = x.x()}  do let var x := 5 in nil end do int {x = int {x = new int, x = -"totor"} , x = x.x.x()} )
function x(x : int, x : int) = x(while () do (), "totor"+"totor") function x(x : int) : int = x.x(5, ())
let class x extends int {var x := 5}  class x extends int {}  in int {x = x(), x = let  in end*int {x = break, x = break} }  ; let var x := 5 in 5 end end
x[()].x.x[x()] := int {x = int {x = nil|"totor", x = new int} } -let import "empty.tih" in int {}  end
for x := if (x(5, ()) ; 5) then if while new int do let  in 5 end then int {x = x}  else for x := int {}  to int {}  do new int to let var x := 5 in end&new int do x.x[if 5 then nil].x
-int {x = x.x()/int {x = ()} /x["totor"] := int [5] of (), x = if for x := break&"totor" to x(break, "totor") do x((), "totor") then x()} 
var x := let  in end
var x := for x := 5 to break do 5 type x = class {}
x[break].x[(nil)][int {x = (break)} ] := int {x = x()} 
let function x(x : int) : int = (5) in end
type x = array of int function x(x : int) : int = ()/break class x extends int {} 
class x {var x := 5} 
x.x.x.x[int {x = int {x = x} , x = while x.x(5, nil) do int {} } ]
function x(x : int, x : int) : int = x(x(), x())
function x(x : int) = x.x := (5)
x.x.x[x.x := int {x = nil, x = ()} ][-int [()&break] of for x := 5 to () do 5]
x[nil][int [5] of break][x.x.x(x.x(), let  in end)][x["totor"].x(while () do break, int {x = break} )+if 5 then "totor"+x()].x()
-x(x(x(), x["totor"] := if break then nil else nil), let import "empty.tih" in end)
class x {var x := 5 var x := 5}  function x(x : int) = x function x() = nil
int {x = if x["totor"][x()] := x(if "totor" then () else "totor", int {x = "totor"} ) then x[break][while () do ()].x()} 
x()
type x = {x : int}
x["totor"][for x := break to () do break][for x := while break do 5 to (5) do let  in 5 end][int {x = x(), x = new int} ].x()
function x(x : int, x : int) : int = while x do -nil
x["totor"].x.x.x.x()
function x(x : int) = x[()].x()
x.x[for x := "totor" to break do 5][if (5) then x.x(5, "totor") else let  in end].x()*while let var x := 5 var x := 5 in (5) end do let var x := 5 var x := 5 in end
function x(x : int) = x[()].x(x(), int {} )
function x(x : int) = x(while () do nil, x.x("totor", break)) class x extends int {var x := 5} 
(if x("totor", break) then x(nil, ()) else x.x(break, "totor") ; -5)|let type x = int in x(if break then nil else (), if 5 then "totor" else nil) end
class x extends int {var x := 5}  class x extends int {var x := 5} 
function x(x : int) : int = x.x := if break then "totor" else nil class x extends int {var x := 5}  var x := 5 import "empty.tih"
function x(x : int, x : int) : int = let var x := 5 in break ; 5 end class x {var x := 5} 
while x() do -x["totor"][int {x = break} ]
class x extends int {var x := 5}  type x = class extends int{} function x() = "totor"
int {} 
type x = class {var x := 5}
x[nil][int {} ].x.x := int {x = if x then x((), ()), x = for x := x("totor", break) to if () then nil do x} /int [if x.x() then (5) else x()] of let var x := 5 in "totor" ; 5 end
x[nil].x[if x then (5) else x.x(break, nil)][x[nil][if "totor" then ()]]
function x(x : int) : int = int {x = x := nil, x = int {} }  class x extends int {var x := 5}  class x extends int {} 
if (for x := if 5 then "totor" to let  in end do while nil do nil ; x(5, break)) then x.x[int {} ].x := if x[nil].x() then (5)
if x(x.x.x.x(), x.x := -5-x[nil].x()) then x()
function x(x : int, x : int) : int = x[nil].x(int {x = nil, x = nil} , int [break] of break) function x(x : int) : int = for x := "totor" to () do 5
var x := x
class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int) : int = x.x.x()
function x(x : int, x : int) = x.x(nil, 5)--()
if let function x() : int = () in x[()] := int {x = ()}  end then x[5].x[int {x = let  in 5 end} ].x(int {x = -int [nil] of nil} , if new int then if x.x() then x(5, nil) else x[nil].x()) else x.x[new int].x.x()
var x := "totor"-"totor" function x(x : int) = nil/nil
-int {x = x(int {x = 5} +x.x(nil, "totor"), x[nil].x()), x = x.x[let  in 5 end].x(let var x := 5 in end, -while nil do nil)} 
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
int {x = x(x.x[5/"totor"], x[nil][new int] := for x := int {x = "totor"}  to if "totor" then "totor" else break do int {x = 5, x = nil} )} 
int {x = for x := x(x.x := x, if new int then x()) to for x := int {}  to x.x.x() do while x(5, 5) do int {x = ()}  do x["totor"][int [()] of nil].x(int {x = x.x(break, break)} , int {x = if 5 then nil else "totor", x = new int} ), x = -x["totor"][for x := "totor" to () do 5] := int [x((), "totor")] of int {x = nil} } 
x[()][for x := () to break do break].x.x.x()
x(int {x = x.x.x.x(let var x := 5 in () end, int [new int] of x(nil, 5)), x = int {} } , let var x := 5 var x := 5 in end)
function x(x : int) : int = while x := break do let  in end
var x := x
(for x := for x := while nil do () to int {}  do new int to x() do x.x)
class x extends int {var x := 5 var x := 5} 
function x(x : int) = int {x = nil|5} 
function x(x : int) : int = int {} /int {} 
int {x = new int} 
class x {var x := 5}  var x : int := "totor"
x.x.x.x[new int].x(x[5][int {x = nil, x = ()} ].x := x[5][x()] := -nil*break, x.x.x[if 5+break then int {x = break, x = ()} ].x())
int {x = int {x = for x := x(int {x = "totor", x = ()} , x) to if for x := "totor" to "totor" do nil then x else (5) do -let  in 5 end, x = let import "empty.tih" in while "totor" do nil end} , x = int {x = x.x.x.x(), x = x(let var x := 5 in end, -int [5] of 5)} } 
x["totor"].x.x.x := int {} 
type x = array of int class x extends int {var x := 5} 
let function x(x : int) = new int in end
function x(x : int) : int = if ()/5 then int {x = nil}  else if 5 then "totor"
class x extends int {var x := 5}  function x(x : int) : int = let  in end
let function x(x : int) = new int in for x := -(5) to let var x := 5 in break ; 5 end do let var x := 5 in nil end ; let var x := 5 in end ; let  in end end
x()
x()
function x(x : int) = x.x(nil, 5)|int [()] of 5
type x = {x : int} function x(x : int) = x
int {x = if x[()][x((), break)] := x() then let var x := 5 in let  in 5 end ; () end, x = let class x {}  in end} 
type x = array of int function x(x : int) : int = 5-5 function x() : int = "totor" import "empty.tih"
function x(x : int) = x() class x {var x := 5}  var x := 5 var x := 5
class x {var x := 5 var x := 5}  function x(x : int) : int = x.x() type x = int var x := 5 var x := 5
class x {var x := 5 var x := 5} 
new int
x(x.x.x.x.x(), let function x() : int = nil in x.x end)
while int [x()] of let var x := 5 in end do x[break][new int][x.x := int {} ]
int {x = x.x[int {x = "totor", x = break} ][if let  in end then if break then () else "totor"] := let var x := 5 var x := 5 in end} 
int {x = -for x := 5*nil to if break then break else break do x()} |x()
int {x = x[5].x.x, x = let class x {}  import "empty.tih" in end} 
function x(x : int, x : int) = x.x
x(x[5].x[x.x.x(x.x((), ()), x := ())].x(x(), if if (5) then if 5 then "totor" else nil then int {x = int {x = 5} } ), int [if for x := let  in end to x do let  in end then if int {}  then -5] of while new int do x())
x()
function x(x : int, x : int) : int = let var x := 5 in 5 end function x(x : int) = int {x = 5, x = break} 
let function x(x : int) : int = x(break, "totor") in int {x = x.x := let  in end, x = int {x = int {x = nil, x = break} , x = x()} }  end
if x(for x := x.x() to x() do int {x = break, x = 5} , x[nil].x(if nil then break, let  in 5 end)) then new int else x(if int {x = nil}  then let  in 5 end else while () do nil, if let  in end then int {}  else x(5, "totor"))+x.x[for x := "totor" to break do break].x := int {} 
int {x = for x := let var x := 5 in break end to x[break] do while x do int {x = ()} , x = x[nil][let  in 5 end]} |x()
x[nil][let  in 5 end].x[while x() do int [(5)] of -"totor"] := new int
x.x[int {x = ()} ].x.x
class x extends int {var x := 5}  var x := 5 var x := 5
if x.x.x[x[nil]] then for x := if -() then -break else x.x(5, "totor") to (nil ; 5) do x[()] := let  in 5 end*let var x := 5 in end
function x(x : int) : int = x.x var x : int := 5 var x := 5
new int
type x = {x : int} function x(x : int) : int = int {x = break}  function x() = "totor" var x := 5
int {x = x(), x = if x.x[int {} ] := let var x := 5 in end then -if 5 then "totor" else ()&if if 5 then 5 then let  in end} 
(int {x = int [new int] of x.x(), x = x((), ())&let  in end}  ; let var x := 5 in "totor" ; 5 end)
var x : int := (5)
x(let class x extends int {}  var x := 5 var x := 5 in x.x ; let  in end ; nil end, x(x[break][if break then nil].x(), (new int ; () ; 5)))
for x := -x[()].x.x(for x := while break do () to x() do for x := "totor" to () do 5, (break ; 5)) to let class x {}  import "empty.tih" var x := 5 in end do int {x = x[nil].x.x()} 
function x(x : int, x : int) = let var x := 5 in end
x.x[x][x()].x := x[nil].x[-(5)].x(x(), (int {x = "totor", x = nil} ))
type x = class extends int{var x := 5}
class x {var x := 5 var x := 5}  var x : int := "totor" var x := 5
var x := if "totor" then break else nil
x()
-if -int {x = nil} +int [let  in 5 end] of x() then let var x := 5 in end+let var x := 5 in "totor" end else if x[nil].x() then new int else int {x = if nil then 5, x = x.x()} 
class x extends int {var x := 5} 
x[()][x.x("totor", 5)].x[(if nil then break else break ; 5)]
type x = {x : int}
x[()].x.x[while if new int then -() else x((), "totor") do new int].x(x[5][int ["totor"] of ()][let var x := 5 in "totor" end].x(), while x.x[while nil do ()] do x())
int {} 
type x = int class x extends int {var x := 5}  function x() : int = ()
function x(x : int) = int {x = int [nil] of 5, x = let  in 5 end} 
let class x {var x := 5}  function x() = nil in x[()][x.x(5, break)] := if int [5] of "totor" then x() end
function x(x : int, x : int) : int = int [for x := () to "totor" do break] of 5|5 function x(x : int) : int = -5
class x {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) : int = let  in end function x() : int = break var x := 5 var x := 5
(let var x := 5 in end ; x.x := int {x = break}  ; x ; 5 ; 5)
function x(x : int) = let var x := 5 in break ; 5 end class x extends int {var x := 5} 
let var x := nil in let import "empty.tih" in end ; if "totor" then break-let  in end ; if 5 then 5 else 5 ; break end
var x : int := int {x = 5}  function x(x : int) : int = x := 5
int {x = x(int {x = if int {}  then for x := 5 to nil do 5 else let  in end} , x()), x = new int} 
x[()][int {x = break, x = break} ][let var x := 5 in () end][x.x.x]
function x(x : int, x : int) = int {x = new int, x = x := 5} 
class x {var x := 5}  function x(x : int) = let  in end
var x : int := int {x = "totor", x = "totor"} 
x.x.x.x[int {x = int [new int] of new int, x = for x := x.x() to -"totor" do -break} ] := int {x = x.x.x.x(let var x := 5 in break ; 5 end, let var x := 5 in end)} 
var x : int := new int class x extends int {var x := 5}  type x = int var x := 5
function x(x : int, x : int) : int = if for x := 5 to break do "totor" then new int
let class x extends int {var x := 5}  in x[5][if 5 then 5 else break] end
x.x.x[new int].x
class x extends int {var x := 5}  class x extends int {var x := 5}  class x {}  import "empty.tih"
type x = class {var x := 5}
function x(x : int, x : int) : int = x.x
type x = class {var x := 5}
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = -let  in 5 end
function x(x : int, x : int) : int = for x := let  in 5 end to "totor"*break do new int
type x = class {var x := 5} function x(x : int) : int = if break then nil var x := 5 var x := 5
function x(x : int) : int = let var x := 5 in end type x = int
class x extends int {var x := 5}  function x(x : int) = int {x = break, x = break} 
type x = class {var x := 5} function x(x : int) = let  in end
var x : int := x.x()
x[nil][x(nil, ())].x[x(x(), let var x := 5 in () ; 5 end)].x(x(), int {x = int {} } )
class x {var x := 5}  function x(x : int) : int = x.x(nil, ()) class x extends int {} 
new int
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5}  class x {var x := 5}  function x() : int = "totor" var x := 5 var x := 5
var x := let  in 5 end
function x(x : int) : int = x(let  in end, int {} ) function x(x : int) = x()
var x := let  in 5 end var x : int := 5 type x = int var x := 5 var x := 5
type x = {x : int}
let class x extends int {var x := 5}  type x = int var x := 5 var x := 5 in end
function x(x : int, x : int) = x.x.x(x := (), (5))
int [int {} ] of while int [5+()] of x()|x.x do x.x[x.x((), "totor")] := x[5].x(for x := 5 to break do "totor", if break then break else 5)
class x {var x := 5 var x := 5}  var x : int := break
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = new int
function x(x : int) = x[nil].x(int {x = ()} , if nil then "totor" else ()) class x {var x := 5} 
function x(x : int, x : int) : int = for x := -nil to int [5] of nil do while () do 5 type x = array of int var x := 5
x.x[x := 5][x.x].x.x(new int, if int {}  then int {x = int {x = let  in end, x = if break then break} , x = x[break]} )
function x(x : int, x : int) : int = x(let  in 5 end, 5|5) var x : int := () type x = int import "empty.tih" var x := 5
x.x.x.x[-x["totor"]].x(if int {x = let var x := 5 in 5 end, x = int {x = for x := break to nil do break, x = let  in 5 end} }  then x.x.x := -int {x = nil, x = break}  else x["totor"][-break].x(x(), int {x = while "totor" do break, x = x()} ), -new int)
function x(x : int, x : int) = let var x := 5 in () end function x(x : int) = x(5, nil)
function x(x : int) : int = int {x = for x := nil to 5 do ()} 
for x := int [if let var x := 5 in end then (() ; 5) else x[()]] of while (break ; 5) do x/int {x = break}  to for x := for x := x.x to if x := () then x.x("totor", "totor") do if int {x = "totor"}  then x("totor", "totor") else for x := break to 5 do nil to (x(5, "totor")) do let var x := 5 var x := 5 in end do x(for x := x["totor"].x() to for x := x := break to x do x.x(nil, ()) do -int {} , if while let  in 5 end do while "totor" do () then if int [nil] of 5 then (5) else (5))
int [int {x = x.x.x := if x() then x(), x = x[()][x.x()]} ] of if if while int {x = "totor"}  do x() then int {x = "totor"/break, x = int {} }  else int {x = int {x = ()} }  then int {}  else if let var x := 5 in end then x[5].x() else x.x.x()
if int {x = -for x := int [5] of 5 to if 5 then break else 5 do if 5 then 5}  then (let var x := 5 in end)
-x.x.x[while x.x() do let  in 5 end].x(int {} , (int [()] of 5 ; ()))
x.x[x.x(break, break)].x[x[break].x.x()]
function x(x : int, x : int) : int = -new int
let var x := "totor" type x = int import "empty.tih" in end
while new int do x[()].x.x.x(x.x[(5)], while int {}  do x.x)
int {x = for x := int {}  to x() do int {} } 
int {x = for x := x.x.x() to int {x = new int, x = while 5 do "totor"}  do int {x = for x := "totor" to "totor" do "totor", x = let  in end} } &x()
-int {x = if if int {}  then (5) then int {x = x.x(), x = new int} } 
function x(x : int, x : int) = x() var x := nil
class x extends int {var x := 5 var x := 5}  var x := "totor" function x() : int = break
int {x = x[5][int {x = 5, x = nil} ][if while 5 do break then let  in 5 end].x(int {x = new int|x := break} , x[nil].x.x()), x = x[5].x.x.x()} 
x.x.x[int [int {x = "totor", x = 5} ] of let  in 5 end][let import "empty.tih" in end] := x.x.x[let var x := 5 in end].x()
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  type x = int
int [-if x.x((), ())+x(nil, 5) then x.x.x(for x := nil to "totor" do (), new int) else int {x = if break then 5} ] of x["totor"][for x := nil to () do "totor"][x(int {x = ()} , (5))].x()
(-x[()])
var x : int := int {x = break, x = "totor"} 
x()
while if (while "totor" do () ; break) then x[break][(5)].x(-let  in end, while int {x = (), x = ()}  do x("totor", nil)) do if int {x = x(), x = x.x := for x := () to 5 do break}  then if int {x = 5, x = 5} +int {x = ()}  then x() else if while break do "totor" then (5) else x.x() else x()
for x := int {x = int {} }  to int {}  do x((x.x((), 5)), while while int {x = break, x = "totor"}  do for x := () to break do nil do int {x = x := "totor", x = let  in end} )
(if while int {x = nil}  do if break then 5 else nil then x.x.x(int [5] of nil, let  in 5 end))
int {x = let function x() = nil in end} 
if x() then if for x := int [x.x("totor", break)] of new int to x.x.x() do (nil ; 5) then x.x[int {x = (), x = nil} ] else let var x := 5 var x := 5 in let  in 5 end ; 5 end else int {x = while -let  in 5 end do for x := (5) to int {}  do x(nil, 5), x = x(for x := -break to x.x((), nil) do int {x = 5} , let var x := 5 in "totor" end)} 
function x(x : int) : int = if x.x((), break) then "totor"*break else for x := break to "totor" do () type x = class extends int{} function x() = nil
let function x(x : int) = new int in for x := (5) to x() do for x := int {}  to new int do x((), 5) end
var x := let  in end function x(x : int) : int = x()
function x(x : int, x : int) = x.x.x() class x {var x := 5}  type x = int import "empty.tih"
type x = array of int
class x extends int {var x := 5 var x := 5} 
new int
int [(x[break].x() ; int {x = ()}  ; nil ; 5)] of int {} 
class x {var x := 5}  var x : int := nil
function x(x : int) : int = let var x := 5 in end type x = array of int type x = int var x := 5
int {} 
x.x.x[if int {x = break, x = nil}  then int {} ].x.x()
int {} 
while int [if int {x = int ["totor"] of 5, x = (5)}  then let var x := 5 in end] of -("totor") do x[break].x.x := ((5))
type x = array of int
let var x : int := () in x[()].x end
type x = {x : int}
x.x[new int].x.x.x(int {x = x(if (5) then int {x = "totor"}  else let  in end, x.x.x())} , if x.x()|-5*let var x := 5 in end then (() ; 5)|x.x.x())
if int {x = int {x = int [if "totor" then break] of x.x(), x = int {x = int {x = "totor", x = ()} } } }  then x(while int {x = let  in end}  do -let  in end, int {x = new int} ) else if x[nil][x((), 5)].x(int {} , int {x = x(), x = int [5] of nil} ) then let var x := 5 var x := 5 in x end else new int
class x {var x := 5 var x := 5} 
type x = array of int var x := nil type x = int
class x {var x := 5 var x := 5} 
function x(x : int, x : int) : int = x(-nil, while () do ())
int {x = int [x.x.x.x(while break*"totor" do let  in end, while "totor" do break&int {x = nil, x = ()} )] of x()} 
let class x {var x := 5}  in end
while int {x = int {x = int {x = -break, x = let  in 5 end} } , x = x.x[x.x()].x(x(), new int)}  do x.x.x[x[()] := new int].x()
class x {var x := 5}  class x extends int {var x := 5}  function x() : int = nil
x(x.x[x := "totor"].x, int {} )
-x.x[let  in end][-x] := for x := x(x.x(), if "totor" then break else 5) to -int {x = 5}  do while x((), ()) do int {x = ()} 
x()
type x = class extends int{var x := 5}
x.x[if break then "totor" else break][int [new int] of x()].x.x(int {} , x[5].x.x)
function x(x : int) = (nil) function x(x : int) : int = int {x = 5, x = "totor"}  var x := 5
class x {var x := 5 var x := 5} 
if while x.x.x do x() then x()
function x(x : int) = let var x := 5 in end type x = class extends int{} var x := 5 import "empty.tih" var x := 5
if x() then (new int) else int [while x.x(5, ()) do let  in end] of x()&(if () then nil else break)
function x(x : int) = x(int [nil] of (), x.x()) function x(x : int) : int = ()*"totor"
type x = class {var x := 5}
for x := if if for x := (5) to x(nil, break) do new int then x.x else x.x then for x := x["totor"] := int {x = break, x = nil}  to x(x.x(), (5)) do x["totor"] else if nil then nil|x((), nil)+for x := if 5 then "totor" else break to int {x = ()}  do x() to let function x() = () import "empty.tih" in (5) ; -break ; 5 end do if for x := let var x := 5 in "totor" end to -while nil do break do int {x = (5), x = if "totor" then nil}  then int {x = x.x := int {x = ()} , x = int {} }  else -while "totor" do "totor"|break-nil
int {} 
var x : int := x
class x extends int {var x := 5}  class x extends int {var x := 5}  var x := 5 import "empty.tih"
class x {var x := 5 var x := 5} 
x(let var x := 5 import "empty.tih" in end, x[break][x()][int {} ])
type x = class extends int{var x := 5} function x(x : int) = let  in 5 end
x()
(x() ; x["totor"].x())
new int
let class x {var x := 5}  in x.x/int [if () then () else ()] of let  in 5 end end
x[()][x((), ())][int [()*"totor"] of x.x(5, break)].x
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = if 5 then nil else () class x {} 
x()
new int
function x(x : int, x : int) : int = new int class x extends int {var x := 5}  var x := 5 var x := 5 var x := 5
class x {var x := 5} 
if while x(int [x((), break)] of x((), nil), (nil ; 5)) do if int {}  then let var x := 5 in () end else if int {x = nil}  then new int else int {x = 5}  then x[break][x := ()].x.x() else (x[nil].x() ; x())
if int [if x.x then x.x.x() else -x(break, "totor")] of let var x := 5 in if nil then () end then if -x.x then x.x[x()].x(x[5], if if nil then "totor" else break then x(nil, nil)) else if (5) then x+let var x := 5 in end else (x())
class x extends int {var x := 5 var x := 5} 
x(if int {x = int {} }  then int {x = new int, x = -if nil then break} , x(for x := -let  in 5 end to int {x = for x := nil to () do nil, x = if break then 5 else 5}  do x := break-int {x = "totor"} , for x := if nil then 5+x to int {x = x.x("totor", nil), x = (5)}  do if x := 5 then new int))
type x = class extends int{var x := 5}
x.x[x.x()].x.x.x()
(x["totor"][if break then ()])
x["totor"][x.x((), nil)][int [-"totor"] of if "totor" then "totor" else 5].x.x()
class x {var x := 5}  type x = class {}
new int
x.x.x.x+int [if x() then new int] of int {x = ("totor"), x = if x(break, nil) then x := 5} 
function x(x : int, x : int) : int = x.x.x(int {x = "totor"} , x.x(break, ()))
int [x()] of if if (() ; 5) then while x.x() do x() then let import "empty.tih" in x((), break) ; 5 ; 5 end
var x := x.x("totor", nil) var x : int := nil function x() : int = "totor"
-x[nil][if break then () else nil][x()]
x[()][break&break][while x() do x.x(break, ())].x()+-if x.x.x() then let var x := 5 in () end
var x : int := x
x[()].x.x[if for x := (5) to if break then nil else nil do let  in 5 end then for x := let  in 5 end to x := break do x.x() else if x then x else x(break, 5)]
for x := if int {x = if let  in 5 end then new int}  then let var x := 5 var x := 5 in x(nil, 5) end else x.x.x := int {x = (5), x = int {x = break} }  to let class x extends int {}  import "empty.tih" var x := 5 in end do new int
while (if for x := nil to break do "totor" then int {}  else while break do "totor" ; x(break, break)) do new int
if let var x := 5 var x := 5 in end then x[5][x.x((), nil)][-int {x = nil} ] := let import "empty.tih" var x := 5 in x.x() ; 5 end
var x := x := "totor" var x := nil type x = int
class x extends int {var x := 5 var x := 5} 
for x := -new int to for x := -int [if 5 then () else ()] of int {x = 5, x = ()}  to for x := (5)*let  in 5 end to for x := if 5 then "totor" to int {x = nil, x = 5}  do if () then break else nil do x.x.x() do x[5][int {} ].x() do x((break ; 5)-int {x = new int} , new int)
x[5][let  in end][x.x][int {x = x.x} ] := x.x[let  in 5 end].x.x(new int, x[()].x := x())
x(x[()][let  in end] := x(new int, x)|(-nil), new int)
type x = array of int
class x {var x := 5}  var x : int := break
class x {var x := 5 var x := 5}  class x {var x := 5} 
if int {x = x.x.x, x = int {x = int [let  in end] of for x := nil to () do 5, x = let var x := 5 in end} }  then for x := int {x = let var x := 5 in break ; 5 end}  to for x := for x := x.x() to while 5 do () do x.x() to x[5].x() do x()|let  in end do if (break) then (5 ; 5) else x[()].x.x
class x extends int {var x := 5 var x := 5} 
var x : int := let  in end class x extends int {var x := 5}  type x = int
let function x(x : int) : int = let  in 5 end in end
let function x(x : int) : int = let  in end in for x := x(x(), let  in 5 end) to for x := int {}  to int {}  do int {}  do for x := int [break] of 5 to let  in 5 end do if nil then nil ; if x() then int {x = nil}  else while "totor" do "totor" ; (5) end
x[break].x[x.x := for x := break to "totor" do "totor"][if x.x := if break then nil else nil then x[nil] else let var x := 5 in end]
class x {var x := 5}  var x := break
int [x()] of x()
function x(x : int, x : int) = int {x = if 5 then 5, x = break|"totor"}  function x(x : int) : int = for x := nil to "totor" do nil class x {}  import "empty.tih" var x := 5
(let import "empty.tih" var x := 5 in x.x() ; break end ; x.x ; x ; () ; 5)
class x {var x := 5} 
x.x.x[let var x := 5 in end][if let var x := 5 in () ; 5 end then x.x.x() else let var x := 5 in end].x()
int {x = x[break].x[int {x = (5), x = let  in 5 end} ] := int {x = x.x.x(int [()] of "totor", -break)} , x = if for x := int {}  to if x := break then for x := 5 to "totor" do "totor" do int {}  then x.x.x.x()} 
class x {var x := 5}  type x = {} var x := 5 import "empty.tih" var x := 5
function x(x : int) = new int
var x : int := -nil
if (let var x := 5 in nil ; 5 end ; x()) then let var x := 5 in x["totor"].x() ; int {x = nil, x = nil}  end else x(x[break].x := x[break] := if 5 then 5, x.x[x])
x[()][x.x((), 5)][new int].x
var x := new int
int {x = let var x := 5 in (5) ; "totor" ; 5 end, x = for x := -x := 5 to while int {}  do x() do int {x = if nil then 5} } -int [int {} ] of if int {x = (5)}  then let var x := 5 in end else x[break].x()
x[nil][int {x = (), x = break} ].x[x()].x(x(int {x = if x.x(nil, "totor") then -"totor"} , int {} ), -int {x = let var x := 5 in end} )
let function x(x : int) : int = int {x = break}  function x() = 5 var x := 5 in -int {x = int {} , x = (5)}  end
let var x : int := break function x() = 5 var x := 5 var x := 5 in end
x[break][int [()] of 5][x.x.x(int {x = nil, x = "totor"} , if 5 then () else ())].x
function x(x : int) = x.x var x : int := 5
function x(x : int, x : int) : int = (5) function x(x : int) : int = x(break, ())
function x(x : int) = if int {}  then x.x() type x = {}
function x(x : int) = for x := int [5] of "totor" to let  in end do let  in 5 end class x extends int {var x := 5} 
x()
int {x = let var x := 5 var x := 5 var x := 5 in end, x = ((5)/if 5 then break else () ; for x := () to break do break ; break ; 5)} 
function x(x : int) : int = x.x.x(x.x(), x := 5) function x(x : int) : int = while nil do break
var x := int [()] of () function x(x : int) = for x := 5 to break do break class x {}  import "empty.tih"
for x := new int to for x := if int {x = x := (), x = int {} }  then x[break] := let  in 5 end else int {}  to if let var x := 5 in end then x["totor"] := new int else new int do if nil then "totor" else ()&let  in 5 end|int {x = new int}  do let var x := 5 import "empty.tih" in end
int {x = int {x = let var x := 5 var x := 5 in x := "totor" end, x = x.x.x} , x = if if -while "totor" do () then let var x := 5 in end then let import "empty.tih" var x := 5 in end else int [for x := x.x() to int {x = nil}  do -nil] of x()} 
class x extends int {var x := 5 var x := 5} 
x.x.x.x[if int [(5)] of let  in 5 end then (nil)].x()
x["totor"].x[int {x = (5)} ].x
class x extends int {var x := 5 var x := 5} 
let class x extends int {}  in while (5) do new int end-if -x.x := if "totor" then () then int {x = x((5), x())} 
function x(x : int, x : int) = x[()]
let class x extends int {var x := 5}  var x := 5 import "empty.tih" var x := 5 in let import "empty.tih" in x() end ; x() end
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
function x(x : int, x : int) : int = x(while nil do (), let  in 5 end)
if let class x extends int {}  in (break) ; ()+break end then x.x.x--int {}  else x[nil].x.x.x()
type x = {x : int} var x := 5
x(new int, int {} )
function x(x : int) = int {}  function x(x : int) = x.x(nil, ()) var x := 5 var x := 5 var x := 5
x["totor"].x.x.x.x()
class x extends int {var x := 5} 
function x(x : int) = x.x.x(x(), while () do ())
class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  var x : int := 5 type x = int
class x extends int {var x := 5}  class x extends int {var x := 5} 
int {x = if int [int {x = new int, x = if () then () else ()} ] of int {x = x := "totor", x = if "totor" then 5 else ()}  then x.x[while 5 do ()].x(if let  in end then let  in 5 end, if x.x("totor", 5) then new int else x()) else (int {}  ; break), x = x.x.x.x.x()} 
function x(x : int) : int = int {x = -nil}  function x(x : int) : int = x.x()
function x(x : int, x : int) : int = --break function x(x : int) = x.x()
function x(x : int) : int = int [()] of nil|x.x()
class x extends int {var x := 5 var x := 5} 
x.x.x.x[new int]
type x = int
let class x {}  in x[break].x() ; new int end&int {x = int {x = for x := while 5 do 5 to if 5 then 5 else 5 do x.x((), "totor"), x = x.x.x()} } 
new int
for x := x.x[if break then break else 5].x := if let var x := 5 in end then (nil ; 5) else x[nil] to int [let var x := 5 var x := 5 in x(nil, 5) ; 5 end] of x(x(), let var x := 5 in end) do x(let import "empty.tih" in -nil end, int [-let  in 5 end] of while if 5 then () do x.x(break, nil))
function x(x : int) : int = int {x = while () do "totor"} 
class x extends int {var x := 5 var x := 5} 
int {} 
function x(x : int, x : int) = for x := for x := break to 5 do "totor" to int [5] of nil do if "totor" then "totor" else nil
type x = {x : int} var x := "totor"
var x := x(5, "totor") var x := 5
function x(x : int) = x[nil].x(int {x = (), x = ()} , 5|break) var x : int := () var x := 5
var x := break*nil
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
function x(x : int, x : int) : int = x()
int {x = (int {}  ; x := break)} 
var x := int {x = "totor", x = break} 
type x = class extends int{var x := 5} type x = {}
type x = int
class x {var x := 5} 
x["totor"].x[x.x].x.x()
class x {var x := 5 var x := 5} 
if int {x = if let  in end then int {x = break} +(() ; 5), x = if x(new int, x) then x.x.x()}  then int {x = while (() ; 5) do int {x = x.x(), x = int {} } }  else let var x := 5 in end
function x(x : int, x : int) : int = int {x = int {x = "totor", x = 5} , x = x := ()}  function x(x : int) = x := nil class x {}  import "empty.tih" var x := 5
x.x[x()].x[int {x = x[nil] := int {x = 5, x = nil} , x = int {x = int {x = break, x = "totor"} } } ].x()
function x(x : int) : int = x.x.x() type x = class {}
function x(x : int) : int = x[break].x(if 5 then "totor" else break, x)
let type x = int function x() = break in end
function x(x : int) : int = x.x
x.x.x.x[int {x = let var x := 5 in end} ].x(if if let var x := 5 in end then x((5), x.x(break, "totor")) else x() then int [-while 5 do ()] of int {x = let  in end, x = x := ()}  else int [int {x = int {x = 5, x = "totor"} } ] of for x := let  in 5 end to new int do x("totor", break), if if int {}  then x()+new int then int {x = nil+"totor"*if break then break else "totor", x = x(for x := break to () do 5, if "totor" then "totor")} )
x[()][int {x = 5, x = break} ][x.x][for x := int [int {x = 5, x = nil} ] of x.x((), ()) to for x := int {x = nil, x = break}  to new int do (5) do new int]
x[break].x.x[x(int {} , x.x.x(-break, int {x = "totor", x = ()} ))].x(x[nil][-break].x := int {x = int [x.x()] of x.x()} , for x := x() to new int do new int)
function x(x : int, x : int) = x.x.x() function x(x : int) = int {} 
x()
if int {x = while x do while "totor" do break}  then x[nil][x := nil] else let import "empty.tih" var x := 5 in end&int {x = int {x = x(int {} , x.x())} } 
if int [int {} ] of x(x(nil, 5), let  in 5 end)/x(x[break].x(), int {x = int {} } ) then let var x := 5 var x := 5 in end-let var x := 5 var x := 5 in x.x() ; nil end else x[break].x.x.x(int [int {} ] of let var x := 5 in end, x.x.x := for x := int {}  to "totor"|() do new int)
(int {} )/(if x := nil then (5))
function x(x : int, x : int) = let var x := 5 in 5 ; 5 end
type x = class {var x := 5} type x = int
class x {var x := 5}  class x {var x := 5}  class x {} 
class x extends int {var x := 5 var x := 5} 
type x = class extends int{var x := 5}
int {} /if while int {}  do new int then x(int {x = nil-nil, x = if () then nil else "totor"} , new int) else x[5][let  in 5 end].x(x(), "totor"-5*x)
int {x = -if if x.x(nil, ()) then int {x = break, x = "totor"}  then if x.x() then x.x() else x((), break)} 
class x extends int {var x := 5 var x := 5} 
type x = class {var x := 5} class x {var x := 5}  function x() = break
if let class x {}  import "empty.tih" var x := 5 in end then ((break ; 5))
int {} 
x()
class x {var x := 5} 
int {} 
x.x[let  in end].x[if -x.x((), break) then x.x].x()
type x = {x : int}
x["totor"][x := 5].x.x.x(while new int do -while let  in end do (5), int {} )
class x {var x := 5}  class x extends int {var x := 5}  function x() : int = 5 var x := 5
function x(x : int, x : int) : int = x["totor"] := for x := nil to nil do nil var x : int := nil
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
x.x[x.x()][int [5] of 5|while 5 do ()][int {x = for x := for x := () to break do () to (5) do x(nil, "totor"), x = x()} ] := -while x() do if x := break then -nil else while break do nil
-for x := x() to while while x() do let  in 5 end do int {x = x()}  do x()
int {x = int {x = if int {x = 5, x = nil}  then (5) else x.x()/while x := 5 do (5)} } 
var x := if 5 then nil else 5
class x {var x := 5} 
var x : int := int {x = 5, x = nil}  class x {var x := 5}  function x() : int = ()
x()
function x(x : int, x : int) = int {}  var x := "totor" function x() : int = () import "empty.tih" var x := 5
function x(x : int, x : int) = (5 ; 5)
var x := let  in 5 end function x(x : int) : int = x.x() function x() = 5
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  function x() = () import "empty.tih" var x := 5
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
type x = array of int
int {} 
let var x : int := () class x {}  in int {x = let var x := 5 in end, x = --break}  end
var x := x := ()
type x = {x : int} type x = class extends int{} type x = int
for x := if new int then x(int {x = x(), x = int {} } , let var x := 5 in end) else x(for x := break to () do "totor"+x(), int {x = int [5] of break, x = x.x()} ) to while if int {x = new int}  then x.x do x() do x()
int {} 
x()+--let var x := 5 in 5 end
-int [int {} ] of -x.x()|if new int then nil+nil
class x extends int {var x := 5}  class x extends int {var x := 5} 
type x = class extends int{var x := 5} type x = {}
int [(x(let  in 5 end, (5)))] of (int {} *if () then () ; int {x = "totor"} )
if int {x = x(), x = (let  in 5 end)}  then new int
function x(x : int, x : int) = int {x = x}  function x(x : int) : int = let  in 5 end
x[()].x.x[int [x.x.x(int [nil] of 5, x.x("totor", nil))] of x[nil]].x()
type x = {x : int}
class x extends int {var x := 5 var x := 5} 
for x := (int [while "totor" do "totor"] of let  in 5 end) to x.x.x[x(if break then 5, int {x = "totor"} )].x(while if x.x(5, 5) then if "totor" then nil else "totor" do let var x := 5 in break end, let import "empty.tih" var x := 5 in end) do int {x = new int, x = int [int [if "totor" then () else ()] of int {x = 5, x = "totor"} ] of (break ; 5)} 
let function x(x : int) : int = let  in 5 end function x() : int = break import "empty.tih" var x := 5 in end
int [int {x = if if nil then break else "totor"/int {x = "totor", x = "totor"}  then for x := 5 to break do "totor"&x.x(5, "totor")} ] of for x := int {x = let var x := 5 in end, x = -x(nil, ())}  to x[5][x(break, "totor")] := int {}  do new int
type x = int
class x {var x := 5}  class x extends int {var x := 5}  function x() : int = () var x := 5 var x := 5
x()
new int
x[5][x][int {x = while break do 5} ][(x)].x(x.x.x[x()] := while int {}  do x(), x(x(), x.x.x := let var x := 5 in end))
class x extends int {var x := 5}  function x(x : int) = (5)
class x {var x := 5 var x := 5}  function x(x : int) : int = let  in end class x {}  import "empty.tih"
x[5][let  in 5 end][x.x][let var x := 5 in end+int {x = let  in 5 end} ] := -let import "empty.tih" in end
let function x(x : int) : int = -() in x.x[int {x = nil, x = nil} ] end
int [x[break][for x := nil to break do 5].x := if x["totor"] := int [nil] of () then new int else int {x = x.x(5, ())} ] of let function x() = () in end
-int {x = let var x := 5 in x() ; 5 ; 5 end, x = if ("totor" ; 5) then int {x = let  in 5 end} } 
x()
class x extends int {var x := 5}  class x {var x := 5}  type x = int import "empty.tih"
x[5].x[int {} ][if "totor" then nil*x()*let var x := 5 in end].x()
type x = {x : int} class x {var x := 5} 
(x(for x := x to for x := 5 to break do () do if nil then 5, x(for x := () to break do "totor", let  in 5 end)) ; if 5 then "totor" else 5+new int)
if if x.x[x].x(x[nil].x(x.x(), let  in 5 end), x[()].x()) then if x.x := x() then int {}  else x.x := int {x = "totor", x = ()}  else if int [x] of let  in 5 end then x[5].x(int {} , (5)) else let var x := 5 in 5 ; 5 end then if x["totor"].x := let var x := 5 in nil end then while new int do x.x.x(int [break] of (), new int) else x[nil].x := x(let  in end, int {x = (), x = "totor"} ) else x["totor"].x[-while nil do ()].x((x.x(break, nil) ; "totor" ; 5), while if x := break then let  in 5 end else (5) do if x() then int {x = 5} )
int {x = let class x extends int {}  in x[5] := x := () end, x = for x := int [int [for x := break to nil do 5] of if break then break] of x.x to new int do x[5].x} 
type x = class extends int{var x := 5}
new int
function x(x : int) = new int class x extends int {var x := 5} 
var x := x.x() function x(x : int) = (5)
int {x = for x := if if while "totor" do "totor" then new int else let  in 5 end then if for x := 5 to "totor" do 5 then x() else x() else int ["totor"] of 5*-5 to x.x[let  in end].x() do x()} 
x()
int {x = new int} 
class x {var x := 5} 
var x : int := x.x((), 5) var x := "totor" type x = int import "empty.tih"
type x = class {var x := 5} function x(x : int) : int = let  in 5 end function x() : int = nil var x := 5
function x(x : int, x : int) : int = let  in 5 end*x := break class x extends int {var x := 5}  class x {} 
class x extends int {var x := 5} 
function x(x : int) : int = let var x := 5 in () end class x extends int {var x := 5}  type x = int
for x := let var x := 5 var x := 5 in x.x() end to int {x = -if nil then ()}  do int {x = x(x.x("totor", 5), x.x()), x = x.x := x.x(5, ())} /while if (nil) then x["totor"] do int [int {x = (5), x = x(break, "totor")} ] of x[break].x(new int, x())
class x extends int {var x := 5}  class x extends int {var x := 5}  type x = int
class x {var x := 5} 
type x = int class x {var x := 5} 
type x = class {var x := 5}
x(x["totor"][x := ()].x, x[()][let  in 5 end][int {x = int {} } ].x(while let var x := 5 in end do 5&5/new int, x.x[if break then ()] := -int {} ))
x[5].x.x.x()+int [let var x := 5 var x := 5 in end] of -if (5) then (5) else x
class x extends int {var x := 5 var x := 5}  function x(x : int) = x() class x extends int {} 
-if if int {x = while nil do 5}  then x() else x(x(), x := ()) then for x := int [-nil] of if "totor" then () to x.x.x(new int, x(break, 5)) do x.x else int {x = ("totor" ; 5), x = int [x] of while break do "totor"} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = int {} 
new int
var x : int := int {} 
x[nil].x[int {} ].x
int {x = for x := x() to x.x[int {} ] := x() do if int [let  in end] of -() then -new int} 
class x extends int {var x := 5 var x := 5}  var x : int := "totor"
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  function x() : int = break
let function x(x : int) = int [()] of () in int {x = x[break]}  ; int {x = for x := break to break do 5, x = int {x = "totor", x = "totor"} }  ; new int ; 5 end
class x {var x := 5 var x := 5} 
int {x = x()} 
(let var x := 5 in "totor"/() ; break end)
if x.x[if break then 5 else ()][let var x := 5 in "totor" ; 5 end] := while int {x = while break do (), x = -"totor"}  do int {x = nil} |x(break, nil) then int [x[()] := if break then "totor" else ()+let var x := 5 in "totor" end] of let var x := 5 in ()/5 end else x.x.x[if x then let  in end].x(-new int, int [x[5].x()] of x())
x.x[int {x = "totor", x = break} ][let var x := 5 in 5 end].x := x.x.x.x
function x(x : int, x : int) : int = if x.x() then if break then break else break var x : int := break var x := 5
int {} 
var x : int := "totor"+"totor" function x(x : int) : int = for x := nil to break do () function x() = nil var x := 5
while (int [x.x()] of int {}  ; x := break ; 5) do int {x = x[()][int [()] of 5], x = x[break][x()].x(if int {x = break, x = break}  then x.x(nil, 5) else x, -int {x = (), x = nil} )} 
type x = int
-x[nil].x.x.x()
x[5][x := break][if x.x(nil, ()) then x := () else let  in end].x := for x := int {x = -x.x(5, break)}  to if for x := x() to if nil then break do new int then if let  in 5 end then x else int {x = break, x = nil}  do x(int {x = int [nil] of 5, x = x := nil} , int {x = nil} |int [()] of 5)
int {x = while let import "empty.tih" in x end do x[()].x.x(int {} , while x((), 5) do if break then 5 else ()), x = x.x.x[x[break].x()]} 
class x extends int {var x := 5 var x := 5} 
var x : int := x.x() class x {var x := 5} 
function x(x : int, x : int) = x[5] := (5)
(x[5][x] ; int {x = nil, x = nil} |let  in 5 end)
type x = class extends int{var x := 5}
function x(x : int, x : int) = int {x = x(nil, "totor"), x = x()}  function x(x : int) : int = new int
function x(x : int) : int = while -nil do nil+()
var x := 5&break
class x extends int {var x := 5}  class x {var x := 5}  class x extends int {}  var x := 5 var x := 5
int [for x := x[5] := x()|-let  in end to x[nil].x.x(new int, int {x = for x := nil to () do nil} ) do x.x[let  in end] := int [x("totor", "totor")] of 5*()] of for x := while while x() do for x := 5 to 5 do 5 do x() to -for x := x() to int [()] of 5 do "totor"+5 do (for x := nil to 5 do ())
int {x = x.x[if () then break][x[nil].x()] := x.x[(5)].x(let var x := 5 in end, for x := x to x do int [nil] of "totor")} 
function x(x : int) : int = for x := let  in end to int [nil] of "totor" do int {x = nil}  class x extends int {var x := 5}  function x() = break
class x {var x := 5 var x := 5}  type x = class extends int{} class x {}  import "empty.tih"
x.x.x.x.x.x(int {x = if while x() do int {x = nil, x = "totor"}  then (break) else new int, x = let var x := 5 in end} , x.x.x.x)
class x extends int {var x := 5} 
type x = {x : int} class x {var x := 5}  type x = int
if -x[nil].x := if int {x = nil}  then x.x(nil, nil) else int {x = "totor"}  then (x.x := if () then 5 else "totor")
x()|let function x() = 5 import "empty.tih" var x := 5 in let var x := 5 in 5 end ; int {x = "totor", x = break}  ; nil end
type x = array of int
let function x(x : int) : int = int {x = "totor", x = ()}  class x {}  in (break)-new int ; let var x := 5 in end end
x(new int+while -x.x(5, nil) do int [while 5 do 5] of (5), let class x extends int {}  var x := 5 in x() ; int [5] of "totor" end)
class x {var x := 5} 
class x extends int {var x := 5} 
if x.x.x[while while break do "totor" do int {x = "totor"} ].x(while int [let  in end] of let  in 5 end do int {x = "totor"&(), x = x := 5} , x["totor"].x) then let import "empty.tih" var x := 5 in int {x = "totor"}  ; nil end|if while x() do x.x() then -int {x = nil} 
int [if while x := 5 do x-(break ; 5) then x.x[let  in 5 end].x() else let import "empty.tih" in end] of x.x[new int][let var x := 5 in end] := if int {x = if "totor" then nil else "totor"}  then --5
type x = {x : int}
x[()][let  in end].x[for x := ()&"totor"-int [()] of 5 to x.x := x do if x.x() then int {}  else break&break] := if -int {x = "totor"/break, x = int {} }  then -x[()] := x else x.x[if nil then break else "totor"].x()
function x(x : int, x : int) = if x then (5) else if () then "totor"
type x = {x : int}
function x(x : int) = x.x.x(new int, while nil do 5)
class x {var x := 5 var x := 5}  var x : int := 5 function x() = "totor"
class x extends int {var x := 5}  function x(x : int) : int = int {x = "totor"}  function x() : int = 5
new int
int {x = x.x[-"totor"][if "totor" then ()*(5)] := let var x := 5 in nil ; 5 end-int {x = ()&break} , x = x.x.x[-new int].x(let var x := 5 in end, int [-break&5] of if x.x() then (5) else for x := break to () do 5)} 
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = x[break].x(()*nil, int {x = "totor", x = 5} )
x((let  in 5 end ; 5 ; 5), int {} )+int {x = while x["totor"].x(int [nil] of 5, if nil then () else 5) do if int {}  then new int} 
x()
new int
x(if if for x := let  in 5 end to new int do if break then break then int [(5)] of x.x(5, 5) then (int {} ), for x := x() to -x.x := if () then break else 5 do x.x[for x := "totor" to () do ()])
class x {var x := 5 var x := 5}  type x = class {} function x() : int = 5
if new int then int [for x := int {x = new int}  to new int do int [int {x = ()} ] of x := "totor"] of let var x := 5 in end
(x["totor"].x.x())
x[break][if 5 then () else break].x.x.x()
type x = class extends int{var x := 5} class x {var x := 5}  function x() : int = 5 import "empty.tih"
x.x[for x := () to "totor" do ()].x[x.x[while nil do 5].x()] := if for x := int {x = int {x = nil} }  to let var x := 5 in () end do -int {}  then for x := x[5].x() to int {x = -break, x = if "totor" then ()}  do x["totor"].x()
class x extends int {var x := 5} 
function x(x : int) : int = x[nil] := x.x(break, "totor")
new int
function x(x : int) = while break/nil do x() class x {var x := 5} 
let type x = int in end
if (if -() then (5) else int {}  ; int {x = ()} ) then if -int {x = int {} }  then x(x[5] := -break, x()) else if (5) then x(nil, nil)|x(if 5 then break, x((), 5)) else x()
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
var x := int {x = 5}  class x {var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int, x : int) : int = let var x := 5 in () ; 5 end class x extends int {var x := 5}  function x() : int = 5
function x(x : int, x : int) = x.x()/int [5] of 5
function x(x : int) : int = x.x.x(-"totor", if "totor" then break) class x {var x := 5} 
let type x = class {} in end
int {} 
int {} 
var x := int {x = "totor", x = nil} 
(-if x.x("totor", "totor") then new int)
x["totor"].x[for x := x.x() to (5) do int {x = (), x = 5} ][int [int {x = int {x = ()} } ] of let var x := 5 in end].x(int [(int {x = nil, x = 5} )] of for x := while int {}  do while 5 do nil to x() do -let  in 5 end, int {x = int {x = -x} , x = int {} } )
x(int {x = x.x[int [break] of break] := int {x = x(break, ())} , x = int {x = let  in end} *int [int {} ] of -()} , int {x = x(), x = x[5][if "totor" then break else "totor"] := x.x} )
x["totor"].x[let var x := 5 in nil ; 5 end].x.x()
function x(x : int, x : int) = x["totor"].x(while () do break, x((), 5))
var x := x := 5
x["totor"][x("totor", 5)]["totor"+nil|x(5, nil)][x()].x()
if int {x = int {} }  then let var x := 5 in while while "totor" do () do if 5 then break else 5 ; (5) ; 5 end
function x(x : int) = if x.x() then if nil then () type x = class extends int{} class x {}  import "empty.tih" var x := 5
var x := x() var x : int := () class x extends int {}  var x := 5 var x := 5
int {x = if if int [x := ()] of 5|nil then int [x("totor", 5)] of let  in 5 end then -while x do x := break else x(for x := "totor" to "totor" do break+if nil then "totor" else (), x.x := if "totor" then () else 5)} 
function x(x : int) = let var x := 5 in "totor" ; 5 end
while if x.x.x.x(while x := break do x.x(), int {} ) then x[break].x.x(x["totor"] := int {x = "totor", x = nil} , x(int {x = 5} , new int)) do int {x = for x := int {x = if () then () else ()}  to x.x.x(int ["totor"] of "totor", x.x()) do x["totor"].x(if break then (), x.x(break, 5)), x = int [int {x = if break then () else 5, x = "totor"+5} ] of x[nil].x()} 
type x = array of int
for x := -if int {}  then let var x := 5 in 5 ; 5 end to x() do x(x.x.x, x())
function x(x : int, x : int) = let var x := 5 in end
int {x = -x(int {x = x(break, "totor"), x = x.x()} , new int|int {} )} 
x[()][x()].x.x
type x = array of int var x : int := break
-let var x := 5 var x := 5 in int [int [break] of ()] of x := "totor" ; x(break, ()) ; nil end
let function x(x : int) = int [5] of nil function x() : int = "totor" import "empty.tih" in (x) ; for x := let  in 5 end to -break do (5) end
let class x {}  var x := 5 var x := 5 in end|x.x.x.x
int {} 
function x(x : int, x : int) = int [break] of nil*x.x() class x {var x := 5}  function x() : int = "totor"
function x(x : int) : int = let var x := 5 in end
var x : int := let  in end function x(x : int) = x.x(nil, nil) class x extends int {} 
x.x[for x := nil to break do ()][for x := int {x = 5, x = break}  to if 5 then "totor" do let  in end].x
class x extends int {var x := 5} 
var x := x(nil, "totor")
x()*x.x[if 5 then () else break][x(x := break, -5)] := x()
new int
x.x[let  in end].x.x.x(new int, x.x.x[x()].x())
x(x(), x()/-x(if nil then 5, -()))
x[()][x][x["totor"].x()].x.x(if for x := let  in end to x.x("totor", nil) do int {x = break, x = break}  then x() else -if 5 then () else nil&x["totor"][x()], x(int [-for x := nil to "totor" do break] of let var x := 5 in () ; 5 end, while int [x] of new int do let var x := 5 in "totor" ; 5 end))
function x(x : int, x : int) = -x.x(nil, nil) var x : int := nil
function x(x : int, x : int) : int = x["totor"].x()
function x(x : int) = x.x := while nil do 5
type x = array of int
(int [let var x := 5 in () ; 5 end] of x[break].x(x((), "totor"), (5)))
if int {}  then x.x.x[x()] else x[nil].x.x
let class x {var x := 5}  in while int {x = let  in end, x = (5)}  do let var x := 5 in end ; let var x := 5 in end end
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  var x := 5 import "empty.tih"
function x(x : int) : int = for x := 5 to "totor" do break/int {x = "totor", x = "totor"}  function x(x : int) = int {x = "totor", x = break}  type x = int
var x : int := (5)
x()
function x(x : int) = int {}  class x {var x := 5}  var x := 5
x[5].x.x.x.x((let var x := 5 in "totor" end), let class x {}  import "empty.tih" in int {x = int {x = ()} }  ; -break end)
x.x.x.x.x
int {x = let var x := 5 in end} 
var x := for x := "totor" to "totor" do () class x extends int {var x := 5}  function x() : int = break var x := 5 var x := 5
class x {var x := 5}  var x := break
x.x[if 5 then nil][(break)].x := let var x := 5 in int {x = int {} , x = int {x = 5, x = break} }  end
function x(x : int) = if if nil then "totor" else nil then let  in 5 end function x(x : int) = int {}  type x = int var x := 5
class x extends int {var x := 5 var x := 5} 
x[nil][int [()] of 5][x[nil].x(x, -break)][-x.x].x(-int {x = new int} , x())
-let class x {}  in let var x := 5 in end end
let var x : int := "totor" class x {}  in (while break do ()) end
x[break][x].x[if x() then int {x = (), x = break} +x.x() else x[5] := let  in end]
function x(x : int, x : int) : int = let var x := 5 in end
function x(x : int, x : int) : int = if 5/break then if () then () else break else int [break] of break
int {x = x.x[for x := nil to break do ()][x["totor"]]} 
class x {var x := 5}  function x(x : int) : int = int {}  function x() = break
var x : int := x.x() var x := nil function x() : int = break
x(int {x = x(), x = int {x = x()} } , x.x := -"totor"+int [int {x = ()} ] of if "totor" then nil else "totor")-int {x = x(for x := int {}  to x do int [5] of 5, x())} 
let var x : int := "totor" in -new int end
function x(x : int) : int = x[5] function x(x : int) = (5)
function x(x : int) = int [int {x = "totor", x = nil} ] of if "totor" then 5 else () function x(x : int) = break-nil type x = int import "empty.tih"
function x(x : int) = int [for x := 5 to () do break] of let  in end
function x(x : int, x : int) = x[nil].x(for x := 5 to "totor" do "totor", int [break] of "totor")
while int {x = let var x := 5 in "totor" end, x = (5 ; 5)}  do x.x.x.x()+x()
int {} 
int [x()] of x()
x[5][x].x[let var x := 5 var x := 5 in int {x = "totor", x = "totor"}  end].x()
-let type x = int in end
type x = int function x(x : int) : int = x(nil, 5)
while -x[()].x.x(while x do int {x = nil, x = break} , x.x.x(new int, int {} )) do -x()
while int {} -let var x := 5 var x := 5 in for x := 5 to 5 do 5 end do -let var x := 5 in end
int {x = new int} 
var x := if () then () function x(x : int) = int {x = "totor", x = 5}  type x = int
-for x := x[()][int {x = (), x = nil} ].x(let var x := 5 in end, (5)) to -int {}  do x()
int {} 
int [x()] of while for x := for x := x to int {x = nil, x = break}  do x() to (5 ; 5) do let var x := 5 in nil end do let import "empty.tih" in let  in end end
x()
for x := x[nil][-5] := new int to int {x = for x := x.x(nil, 5) to x((), break) do x.x(), x = x.x.x()}  do int {x = let var x := 5 in end, x = int [int {x = 5} ] of x} &x.x.x[int {x = int [nil] of 5, x = let  in 5 end} ].x(if while -() do x(nil, break) then (break) else int [int {x = "totor", x = nil} ] of let  in end, let var x := 5 var x := 5 in end)
for x := int {x = if if 5/5 then x.x(nil, nil) then for x := new int to int {x = break, x = 5}  do new int else x.x := x.x((), "totor")}  to int [while int {}  do x.x.x()] of int {x = int [x := "totor"] of (5), x = if x := "totor" then if "totor" then "totor" else nil else -break}  do for x := -for x := while "totor" do "totor" to break/break do -"totor" to if for x := x.x(nil, break) to int {}  do ()|break then x[nil].x() else int {x = x.x(), x = int {x = "totor", x = 5} }  do x[break].x.x(x.x.x(), (5)&(5))
class x {var x := 5 var x := 5} 
function x(x : int) = int [break|"totor"] of nil|break function x(x : int) = int [break] of () class x extends int {} 
function x(x : int, x : int) : int = new int var x := 5 type x = int
type x = {x : int}
function x(x : int) = x(int {x = "totor"} , for x := nil to 5 do 5)
var x : int := int [break] of "totor"
int {} 
for x := x(x[5].x(int {} , if nil then "totor"), while x.x(break, nil) do let  in end) to (x.x(break, break) ; nil ; 5) do x(x["totor"] := let  in 5 end, for x := break to "totor" do ()-new int)+x[()][while nil do "totor"][-5/for x := () to break do 5].x(while while 5&() do for x := "totor" to "totor" do "totor" do let var x := 5 in end, for x := x[()].x() to int [int [()] of "totor"] of if "totor" then break do -x)
int {} 
class x extends int {var x := 5}  function x(x : int) = -5 function x() = break import "empty.tih"
x["totor"].x[x()][for x := -nil|"totor"&5 to if int {x = break}  then if nil then break else "totor" else int {x = (), x = break}  do x.x]
x[break][let  in 5 end][x[()].x(x := break, x)].x.x(let class x {}  in end, int {x = int {x = if if "totor" then "totor" else 5 then x.x("totor", 5), x = int {} } , x = int {x = int [x.x((), 5)] of let  in 5 end, x = (nil)} } )
x[()].x.x.x.x()
class x extends int {var x := 5 var x := 5} 
let function x(x : int) = ()|5 in x.x.x.x(x(let  in 5 end, x), new int) ; let var x := 5 in end end
class x extends int {var x := 5}  function x(x : int) = if break then nil else () type x = int
function x(x : int, x : int) : int = new int
x[()][x()][if -nil then if "totor" then () else 5 else let  in 5 end].x := new int
if x.x.x[x[5].x()] then int {} 
x.x[x(nil, ())][int {x = x := break, x = x.x("totor", break)} ][int {x = let var x := 5 in 5 ; 5 end, x = x.x := x(5, break)} ].x()
type x = int function x(x : int) : int = x
type x = array of int class x extends int {var x := 5}  var x := 5 import "empty.tih" var x := 5
function x(x : int) : int = int [let  in end] of new int
class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  class x {}  var x := 5 var x := 5
function x(x : int, x : int) = int {x = int {x = (), x = "totor"} , x = x("totor", "totor")}  class x {var x := 5}  function x() = break import "empty.tih"
-while int {x = let var x := 5 in nil end}  do let import "empty.tih" var x := 5 in int {x = ()}  ; 5 end
function x(x : int) : int = let var x := 5 in break end var x := () class x {}  var x := 5
class x extends int {var x := 5 var x := 5} 
var x := x()
x(x["totor"][x].x.x(), x.x.x.x.x())
var x := new int class x extends int {var x := 5}  type x = int
var x : int := x := "totor" function x(x : int) = let  in end
type x = class {var x := 5} var x := break
x()
var x := int {x = break} 
if x.x.x.x.x() then x["totor"][5/break].x
class x {var x := 5 var x := 5} 
function x(x : int) = x[5].x() function x(x : int) : int = if () then break class x {}  import "empty.tih"
let type x = class {} in (int [()] of 5) ; x.x.x() end
int {} 
class x {var x := 5} 
x.x.x[if x then x.x(5, ())][let import "empty.tih" var x := 5 in end].x(-("totor")+let var x := 5 in end, x[5].x[-x()].x())
var x : int := x(nil, "totor")
-let var x := 5 var x := 5 in let  in 5 end ; break end|int {x = int [for x := x.x((), ()) to int {}  do 5-()] of x[5].x(), x = while x.x.x(x, int [5] of 5) do x()} 
type x = array of int class x {var x := 5}  var x := 5 var x := 5
(while int {x = if nil then "totor" else (), x = int {} }  do let var x := 5 in 5 end)
function x(x : int, x : int) = x(int {x = 5, x = nil} , if () then nil)
x.x.x.x.x.x(new int, int {x = (x.x(nil, ()) ; break ; 5)} )
let var x : int := break type x = int in new int end
x[()].x[let var x := 5 in end][x()].x(x(x["totor"].x, x.x[if nil then "totor"].x()), x())
if -let import "empty.tih" in x ; break ; 5 end then x[5].x[x.x((), break)|x()] := x.x[x] := x.x := int {x = "totor"}  else x.x[while break do ()][x[()]]
type x = class extends int{var x := 5} function x(x : int) = int {x = ()} 
function x(x : int) : int = x := 5&x()
type x = int
class x extends int {var x := 5}  class x {var x := 5}  class x {}  var x := 5 var x := 5
int {x = int {x = -int [nil] of break|x.x} , x = new int} 
int {x = if while int ["totor"] of () do x.x() then int {}  else int [int [break] of break] of x()/int {x = while for x := 5 to "totor" do nil do -break, x = int [x.x(break, nil)] of if () then nil} } 
class x extends int {var x := 5}  class x extends int {var x := 5} 
class x extends int {var x := 5}  function x(x : int) : int = int {x = (), x = break} 
int [int {x = x.x.x, x = int {x = int [x("totor", ())] of int [break] of (), x = x := "totor"&(5)} } ] of if int {}  then int [(break ; 5)] of for x := let  in end to int [break] of break do let  in 5 end
var x : int := if 5 then () else break type x = class {} function x() : int = "totor"
type x = {x : int}
x["totor"].x.x.x
int {x = while -x.x.x(x.x(), int {x = 5, x = nil} ) do int {} } 
var x : int := x := "totor" var x : int := break
type x = class {var x := 5} var x := "totor" class x extends int {} 
int [int [if if x.x((), ()) then int {x = break, x = "totor"}  else x.x() then let var x := 5 in end else if x then while () do ()] of let import "empty.tih" var x := 5 in x() ; "totor" end] of if int {x = int {} , x = x()}  then let import "empty.tih" var x := 5 in (5) end
let function x(x : int) : int = x() in if let var x := 5 in end then while if "totor" then break do int {}  ; -x := 5 end
function x(x : int) = x[()].x(let  in 5 end, x())
for x := int {}  to while x.x[while 5 do "totor"].x(x.x.x(), -x()) do if x.x.x(while nil do nil, x.x(5, break)) then int [()] of ()*if () then nil do int {x = -if "totor" then nil else ()/x.x.x(if () then "totor" else nil, int {} )} 
class x {var x := 5}  type x = {}
x[nil].x[-5/if break then ()][int {x = x["totor"].x()} ].x()
x.x.x.x[-(5 ; 5)]
class x {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5} 
int [int {} ] of x.x.x[new int].x(--for x := nil to () do nil, for x := x[nil].x(x(), for x := () to break do ()) to while -"totor" do new int do let var x := 5 in nil end)
function x(x : int) = ("totor" ; 5) class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
function x(x : int) = x(let  in 5 end, x := 5) function x(x : int) = x.x(nil, nil) type x = int import "empty.tih"
function x(x : int, x : int) = let var x := 5 in "totor" end var x : int := nil type x = int var x := 5
function x(x : int, x : int) : int = while for x := () to nil do () do while nil do nil
type x = int type x = array of int
x[break][int {x = 5} ].x[while --() do let  in end&for x := "totor" to "totor" do 5].x()
function x(x : int, x : int) = let var x := 5 in nil end
class x {var x := 5 var x := 5} 
(let var x := 5 in end)
var x := x.x(5, 5)
-5-()-(5)/let var x := 5 in end*x.x["totor"*()].x.x()
class x {var x := 5 var x := 5} 
type x = array of int type x = int
type x = class {var x := 5}
type x = class extends int{var x := 5} function x(x : int) : int = nil+nil function x() = 5
function x(x : int) : int = int {x = new int} 
x[break][nil/"totor"].x[x()]
let type x = class extends int{} in end
type x = array of int
class x {var x := 5}  var x := "totor" var x := 5
let function x(x : int) : int = int ["totor"] of 5 in new int ; if -nil then if 5 then break else "totor" ; x() end
x.x[let  in end].x.x
x[break][x()][let var x := 5 in end].x.x()
let type x = class extends int{} class x {}  in if -(5) then x.x.x(-break, nil&5) end
let class x extends int {var x := 5}  in new int end
class x extends int {var x := 5} 
x[break][while break do "totor"][int [for x := 5 to nil do ()] of x.x()][x()] := int [let var x := 5 var x := 5 in "totor"-5 end] of int {x = let var x := 5 in end, x = x[break].x(new int, while () do break)} 
type x = array of int
class x extends int {var x := 5}  var x : int := nil
x[()][int {x = break} ][if (5) then 5&5].x.x()
x["totor"].x[while int ["totor"] of nil do let  in end][if x(break-break, int {} ) then new int].x()
int {x = if x(int {} , ("totor")) then int {x = let var x := 5 in end, x = x.x.x()} , x = new int} 
int {} 
class x {var x := 5}  function x(x : int) : int = x() function x() = ()
x()
if (let  in end|x := 5) then let type x = int in end
class x extends int {var x := 5 var x := 5}  type x = int
function x(x : int) : int = int {x = x.x(nil, nil)} 
x.x.x[let var x := 5 in 5 ; 5 end][new int].x(for x := x[nil].x.x(x(x, ()+break), new int) to x.x["totor"/break] := x[nil] := int [()] of 5 do int [let var x := 5 in end] of int [-nil] of x, let function x() : int = nil in end)
var x := -"totor" function x(x : int) = while 5 do ()
class x extends int {var x := 5 var x := 5}  var x := 5 type x = int import "empty.tih"
int {x = let var x := 5 import "empty.tih" var x := 5 in x() ; if () then nil end} 
(x() ; x())
x.x[while "totor" do break][x[nil] := x.x("totor", break)][new int].x((x(x.x(nil, "totor"), x.x(break, "totor")) ; if 5 then "totor"), while x() do int {x = int [x((), break)] of x(5, nil)} )
function x(x : int, x : int) : int = int [for x := 5 to break do break] of if 5 then break class x extends int {var x := 5}  class x extends int {} 
int {x = int {} , x = if x.x["totor"*"totor"] := x[()].x(int {x = (), x = break} , -break) then int {x = new int, x = --()}  else x[()].x.x()} 
class x {var x := 5 var x := 5}  function x(x : int) : int = int {x = ()}  var x := 5
if new int then -x[()].x else x.x[x(5, nil)][new int].x(for x := x(int {x = 5, x = ()} , x.x(5, nil)) to -(5) do for x := new int to x.x() do let  in end, -if x then x.x() else x := break)
(int {x = let var x := 5 in end, x = x["totor"].x(if nil then () else 5, let  in 5 end)}  ; int {x = int {x = nil, x = break} , x = let  in end}  ; int [break] of nil)
type x = int class x {var x := 5}  function x() : int = nil import "empty.tih" var x := 5
class x {var x := 5 var x := 5} 
if if x() then (int {x = 5, x = ()}  ; nil) else -x[nil] := break*() then while int {} *if 5 then break else nil*x.x(break, "totor") do x.x.x.x() else for x := let import "empty.tih" in end to x[break][x("totor", break)].x(while (5) do int {x = nil} , (break)) do x.x[new int].x(int {x = x((), break), x = 5|nil} , int [while break do 5] of x(break, 5))
function x(x : int, x : int) = if x.x(nil, "totor") then int {x = (), x = break}  function x(x : int) = x() var x := 5 var x := 5 var x := 5
-x.x[for x := () to () do break] := for x := int [()] of nil to let  in 5 end do int {x = "totor"} +--5*"totor"+5
new int
for x := x.x[int {} ][for x := -break to int {x = nil}  do (5)].x() to (if (5) then int {x = ()}  else x := "totor" ; x("totor", "totor") ; () ; 5) do int [x.x := if break then break else nil+new int] of x.x := for x := 5 to 5 do "totor"+x.x := if "totor" then nil else 5
for x := if -let var x := 5 in 5 ; 5 end then x[()].x := while -nil do new int to if let import "empty.tih" var x := 5 in end then if x[()].x(x.x(nil, "totor"), new int) then int [for x := 5 to 5 do break] of if nil then nil else x.x[while 5 do "totor"] := int [-break] of let  in 5 end do if x.x.x then int [x()] of for x := -"totor" to -nil do if break then "totor"
-(let var x := 5 in end)
int {x = while x[5].x := int [x] of (5) do let import "empty.tih" var x := 5 in int {x = nil}  ; () ; 5 end} 
function x(x : int) = x(x := "totor", let  in end) function x(x : int) : int = int {x = nil}  function x() : int = "totor"
(int [x(int {x = "totor"} , x())] of x() ; x[()].x())
class x {var x := 5 var x := 5}  function x(x : int) : int = x.x() class x extends int {} 
function x(x : int, x : int) = x.x.x(while break do nil, int {x = break} ) function x(x : int) : int = int {x = 5, x = 5}  type x = int
x[break].x.x[int {} ]
class x extends int {var x := 5 var x := 5} 
int {x = for x := int {x = x(nil, 5)} |int {x = if break then break, x = for x := "totor" to nil do "totor"}  to if x[break].x((5), let  in 5 end) then x[break] := x() do x.x[int {x = break} ] := let var x := 5 in 5 end, x = if x() then while if x := 5 then x("totor", "totor") do x.x := (5)} 
class x {var x := 5}  function x(x : int) : int = new int class x {} 
type x = int function x(x : int) : int = for x := () to break do break var x := 5
let type x = class {} class x extends int {}  in end
var x : int := while break do ()
int [(int {}  ; "totor")] of x.x[let  in end].x(int {x = let  in end} , if new int then let  in end else x())*if int {x = if let  in 5 end then x := 5 else for x := 5 to nil do ()}  then let var x := 5 in () end|for x := x("totor", break) to if nil then () do while () do nil else int [int {x = x, x = let  in end} ] of let var x := 5 in () ; 5 end
class x extends int {var x := 5 var x := 5} 
-let var x := 5 var x := 5 in end+int [x[break].x()] of x()
x(for x := (if 5 then 5 else break ; ()) to x(int [int [nil] of 5] of x.x(break, break), x(x.x((), "totor"), x.x())) do int {} , int [for x := int [-5] of nil*5 to x[()] do x(if nil then break, x())] of x())
var x : int := if 5 then () else nil
int {x = if new int then let var x := 5 in end, x = x[nil].x.x := (x.x() ; break)} 
class x {var x := 5}  type x = array of int var x := 5 import "empty.tih" var x := 5
x["totor"].x[x()][(if "totor" then () ; nil ; 5)].x(if x.x.x.x(while () do ()/-(), x()) then x.x[let  in 5 end].x(if for x := 5 to break do 5 then x(nil, 5), if while () do nil then x() else x.x((), "totor")) else -int {} , new int)
int {x = -int {} } 
function x(x : int) : int = while x do let  in 5 end
x.x[if () then 5 else 5].x[int {x = x.x.x()} ] := x[()].x[x()] := let import "empty.tih" in int {}  end
function x(x : int, x : int) = int [-5] of for x := break to () do "totor" class x extends int {var x := 5} 
class x extends int {var x := 5}  type x = class {} class x extends int {} 
class x {var x := 5} 
type x = {x : int} class x {var x := 5}  function x() : int = 5
x(x(), x[break].x.x := int [int {} ] of int [let  in end] of int {x = "totor", x = ()} )
x[()].x.x[if x.x.x() then -int {x = "totor", x = ()} ].x()
if int {x = (if nil then 5 else 5)}  then new int else -x.x.x(for x := () to 5 do "totor", if 5 then break else "totor")&let var x := 5 in end
function x(x : int) = if x(break, "totor") then x
x()
x()
function x(x : int, x : int) = x.x := int {x = break, x = nil} 
new int
if x.x.x[x[5].x()].x(x[break].x.x(int {x = for x := break to nil do nil} , while for x := break to break do break do -nil), if x.x.x(if nil then nil, int [5] of nil) then x() else x[nil]) then let class x extends int {}  var x := 5 var x := 5 in int {}  end
x.x.x[x.x][x[break][(5)].x()].x(while x[nil].x.x(int {} , new int) do (int {x = break, x = nil}  ; "totor" ; 5), x())
x[break]|let var x := 5 in end&int {x = let var x := 5 in end, x = x(break+nil, (5))} &if x[nil][x.x(5, "totor")].x(let var x := 5 in end, int {x = if () then "totor", x = int {x = ()} } ) then int {x = int [int {x = (), x = "totor"} ] of x(break, nil), x = if "totor" then break else nil-int {} }  else let var x := 5 in end
if int {x = x[nil] := let  in 5 end-x.x.x(), x = x[5][x]}  then -int [-let  in end] of --5 else -x.x[x.x()]
type x = array of int
class x {var x := 5 var x := 5}  function x(x : int) = x(nil, break)
type x = int
class x {var x := 5 var x := 5}  var x : int := "totor" type x = int var x := 5 var x := 5
new int
let var x := "totor" in int [x[break] := if "totor" then () else 5] of ("totor") end
var x : int := for x := () to () do nil var x := nil
class x {var x := 5} 
let class x {var x := 5}  class x {}  var x := 5 in let import "empty.tih" in end ; int {x = int ["totor"] of "totor", x = x()}  end
function x(x : int, x : int) : int = (5)*while break do 5 type x = int var x := 5
function x(x : int, x : int) : int = x()
for x := for x := int {}  to int [x[5]] of if x.x(nil, ()) then new int else nil*break do let var x := 5 in ()*"totor" ; "totor" ; 5 end to while x.x.x.x() do x.x.x.x(x[break].x(x(), x.x()), x[5]) do while int [x()] of let var x := 5 in () ; 5 end do x()
--for x := -let  in end to x() do x()
class x {var x := 5 var x := 5} 
type x = int var x : int := nil var x := 5 import "empty.tih" var x := 5
if if (x.x(nil, nil) ; break ; 5) then if if (5) then (5) else x() then if x.x() then x() else x(break, 5) else int {}  then x.x[5+break]+-for x := (5) to -5 do let  in end
class x extends int {var x := 5}  class x {var x := 5}  var x := 5
x[nil][while nil do nil][if if nil then nil else "totor" then int {x = ()} ].x := new int/x.x.x.x()
class x {var x := 5 var x := 5}  var x : int := nil class x extends int {} 
int [while x[5].x := int {}  do int {x = let var x := 5 in end} ] of -((5))
if for x := x(let  in 5 end, x.x()) to x.x do int {x = x.x(nil, nil), x = new int}  then int {x = let var x := 5 in 5 end} +x()
(x[break][x] := for x := for x := 5 to () do break to while 5 do () do x(nil, 5) ; (break ; 5))
function x(x : int) : int = x[nil] function x(x : int) : int = x function x() : int = break import "empty.tih" var x := 5
int {x = if (for x := () to 5 do 5) then int {x = x()}  else x[5][x.x((), ())].x(), x = (while let  in end do int {x = 5}  ; x.x())} 
class x extends int {var x := 5}  function x(x : int) : int = x var x := 5
var x : int := if 5 then "totor" else "totor" class x extends int {var x := 5} 
int [(while int {x = "totor"}  do x())] of let function x() : int = nil in int {x = int {x = nil} }  ; nil|5 ; 5 ; 5 end
int {x = int [let import "empty.tih" in x.x() ; nil ; 5 end] of x()} 
function x(x : int) = int [if break then ()] of let  in 5 end type x = int
type x = array of int type x = {} class x extends int {} 
int [int {x = if x.x := -break then (() ; 5), x = x[()][int {} ].x()} ] of x(x.x[nil+break] := x(let  in 5 end, int {x = ()} ), int [new int] of int {} )
int {} 
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
new int
var x := x.x(5, 5)
new int
x(new int, let function x() : int = 5 in int [x := 5] of int [break] of "totor" end)
x.x[int [()] of 5][("totor" ; 5)].x
if int {x = x.x[(5)].x()}  then x.x[-break].x := (for x := nil to "totor" do () ; () ; 5) else int {x = x(), x = int {x = int [()|nil] of x.x(), x = new int&x.x(5, break)} } 
type x = int function x(x : int) : int = if "totor" then nil class x extends int {}  var x := 5 var x := 5
type x = class {var x := 5} function x(x : int) = let  in end
var x := if () then break var x := ()
type x = class extends int{var x := 5}
if for x := for x := let var x := 5 in 5 ; 5 end to x() do int [x.x()] of if () then () to x.x.x.x() do x.x.x := -for x := 5 to "totor" do break then x(-x(new int, "totor"/5), x.x[x.x()].x(x.x := x := 5, int {} ))
int [x["totor"].x[if x then x(break, "totor") else x.x()].x(x[nil][x := 5].x(for x := if nil then 5 else () to int {x = "totor", x = 5}  do while () do nil, if x.x((), nil) then let  in 5 end else if 5 then "totor"), int [if (5) then let  in 5 end] of -"totor"*nil)] of x()
var x := x.x() function x(x : int) : int = while 5 do "totor" class x {}  import "empty.tih"
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = x(break, break)
class x {var x := 5} 
class x extends int {var x := 5} 
class x extends int {var x := 5} 
function x(x : int, x : int) = int {} 
if if let var x := 5 var x := 5 in end then int {x = int {x = x} , x = int [x((), "totor")] of x()}  then while -let  in 5 end/int [nil] of break do let import "empty.tih" in "totor"-break end else int [int {x = if (5) then x.x((), 5) else let  in 5 end, x = if int {}  then int [5] of () else x()} ] of int {} 
class x extends int {var x := 5 var x := 5} 
function x(x : int) = x(int {x = break, x = ()} , -break)
type x = {x : int} var x := 5 class x {}  import "empty.tih" var x := 5
int {x = int {x = let var x := 5 in end, x = if x(int ["totor"] of "totor", x := break) then for x := x to (5) do if () then "totor" else nil else -int {x = 5} } , x = new int} 
function x(x : int) = x.x.x((5), x()) class x extends int {var x := 5} 
var x : int := x.x()
let function x(x : int) : int = x.x(nil, "totor") var x := 5 import "empty.tih" var x := 5 in end
x[break].x.x[x(let var x := 5 in end, -5|nil)]
int {x = int {} , x = for x := let var x := 5 var x := 5 in end to int {x = int [(5)] of nil+break, x = (())}  do if x() then x.x.x(int {} , x.x())} 
let type x = int in end&x[break][-nil].x
int {x = x()} 
var x : int := new int
class x extends int {var x := 5}  function x(x : int) = while 5 do () var x := 5
x[break].x.x[while let var x := 5 in break end do int {x = int ["totor"] of break, x = -"totor"} ].x()
function x(x : int) = while x.x() do if "totor" then 5 else break function x(x : int) = while break do break
class x extends int {var x := 5} 
int {x = new int, x = --x.x := let  in 5 end} 
var x : int := new int
x()
function x(x : int, x : int) = int {x = nil&"totor"}  function x(x : int) : int = int {x = (), x = 5}  type x = int
let function x(x : int) : int = let  in end function x() : int = "totor" in end
for x := for x := let var x := 5 in end to x() do int [while break do ()] of let  in 5 end/new int to int {x = let import "empty.tih" var x := 5 in end, x = let import "empty.tih" in x() end}  do new int
(for x := int {x = if "totor" then (), x = x.x("totor", "totor")}  to x.x.x() do -let  in 5 end ; for x := if () then "totor" else nil to if () then () do if nil then nil ; if () then nil)
type x = {x : int} class x extends int {var x := 5} 
function x(x : int) : int = x()
type x = class extends int{var x := 5}
new int
int [x.x.x.x := int {x = int {} , x = for x := x to while "totor" do "totor" do -break} ] of -int {x = x[break] := (5)} 
x[break][int {x = "totor", x = 5} ].x[int {x = int {} , x = int {x = -(), x = for x := nil to "totor" do break} } ] := x.x.x.x.x(new int, int [int {x = x, x = x()} ] of if while nil do nil then if () then nil)
type x = array of int type x = class {}
var x : int := new int
if x[5].x[int [for x := break to break do ()] of int [5] of ()] := if let var x := 5 in nil end then (5)-(5) then x.x.x[for x := (5) to int {x = (), x = nil}  do x.x()]
while int [x.x[-5].x()] of x() do x.x[()|nil][while x(nil, ()) do while () do nil].x(if x.x()|if () then nil else nil then int [x] of (5) else for x := -"totor" to if () then () do let  in 5 end, (while () do 5))
type x = {x : int} function x(x : int) = new int function x() : int = 5
x()
function x(x : int) : int = int [int {x = "totor"} ] of while nil do 5 class x extends int {var x := 5}  var x := 5
function x(x : int) = for x := int {x = break}  to let  in end do nil*"totor" function x(x : int) = x.x()
let var x := break in int {x = x()}  end
function x(x : int, x : int) : int = x(x.x(5, 5), let  in 5 end) class x {var x := 5} 
int {x = int {x = int {} , x = int {x = int {x = int {} , x = int {x = "totor", x = nil} } } } , x = if if x then for x := nil to break do nil else int {}  then x.x.x() else x(x(nil, ()), int {x = "totor", x = break} )-for x := let var x := 5 in "totor" ; 5 end to let var x := 5 in nil ; 5 end do while "totor" do 5*x()} 
let class x {var x := 5}  class x {}  in for x := for x := x.x((), break) to int [5] of nil do x((), 5) to x.x.x(int {x = nil, x = 5} , int {x = 5, x = 5} ) do (5) ; x() end
function x(x : int) = int {x = if "totor" then nil else (), x = let  in 5 end} 
class x extends int {var x := 5} 
var x : int := int {} 
int {x = x.x.x[let var x := 5 in () ; 5 end].x(x[break].x := for x := let  in end to int {x = "totor", x = break}  do x.x(), if new int*for x := () to break do "totor" then while x("totor", "totor") do -"totor"), x = x.x.x[-int {} ].x(if -new int then int {x = (5)} , let var x := 5 in -nil end)} 
int [x()*x()] of let class x {}  var x := 5 in int {}  ; int {}  ; 5 end
class x extends int {var x := 5} 
class x extends int {var x := 5}  type x = array of int
function x(x : int) : int = let var x := 5 in 5 end var x := 5
type x = array of int type x = array of int
int {x = if int {}  then if x(-5, new int) then int [()+()] of ()*break, x = let class x extends int {}  import "empty.tih" in if int {x = 5, x = ()}  then x.x() else -break end} 
class x extends int {var x := 5} 
(for x := x.x to x(if 5 then nil, x.x(5, 5)) do x(x("totor", 5), (5)) ; if x then (5) else while nil do ())
if x.x.x.x then let class x {}  import "empty.tih" in x(int {x = break, x = ()} , int ["totor"] of ()) ; int {x = break}  ; 5 ; 5 end
function x(x : int) = x()
function x(x : int) = int [-nil] of int {x = break}  type x = class extends int{} class x {}  import "empty.tih" var x := 5
class x {var x := 5 var x := 5}  var x : int := break class x {}  var x := 5 var x := 5
x[5][x := 5][int {x = let  in end, x = int {x = nil} } ][x.x.x(if nil then break else break, new int)&x()].x(x(x["totor"].x, let var x := 5 in if nil then break end), while while if if nil then () then if () then break else 5 else int {x = 5}  do (nil ; 5) do x.x[int {x = 5} ] := if int [break] of "totor" then x.x() else int {x = 5, x = 5} )
x()
for x := let class x {}  in for x := (5) to x() do x.x((), "totor") end to x.x[int ["totor"] of 5].x.x(int {} , int [x[5].x(int {x = nil, x = "totor"} , let  in end)] of while 5*nil do let  in end) do -x.x[let  in 5 end]
function x(x : int) : int = int {}  var x : int := () var x := 5
function x(x : int, x : int) = (nil ; 5)
new int
for x := if for x := int [for x := () to "totor" do break] of -break to x[5].x(if nil then "totor", while break do nil) do new int then new int else for x := new int to (()) do new int to for x := -int {x = x, x = x(nil, "totor")}  to int [int {} ] of int [x.x()] of int [()] of nil do let var x := 5 in end do int [int {x = int [int {x = nil} ] of while 5 do ()} ] of for x := x[5].x(new int, (5)) to if int {x = ()}  then int {x = ()}  else x do x(let  in end, int {x = 5} )
type x = class {var x := 5}
var x := (5) function x(x : int) : int = let  in end
class x extends int {var x := 5 var x := 5} 
x.x[if break then () else break].x.x.x()
if x[nil][x := "totor"][let var x := 5 in end].x() then x.x.x.x := for x := while int ["totor"] of 5 do let  in end to int [let  in end] of x do x := break|x()
function x(x : int, x : int) : int = let var x := 5 in end var x := ()
x(x[nil].x[x[5] := int {} ].x(-x[()].x(new int, int {} ), int {x = int {x = int {x = 5} , x = int {x = 5} } , x = x()} ), new int)
function x(x : int, x : int) : int = x.x
let class x extends int {var x := 5}  class x extends int {}  in (int {x = 5, x = break}  ; "totor") ; if x() then for x := break to "totor" do 5 end
class x {var x := 5} 
function x(x : int, x : int) = if x.x() then int {}  else new int
function x(x : int, x : int) : int = for x := x() to x do x class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) = int {x = break} 
-int [x()] of int {x = x.x := int {} , x = while let  in end do new int} 
int {x = -new int} 
while x.x.x.x.x(for x := int [(5)] of x((), break) to let var x := 5 in nil end do for x := () to 5 do 5&(5), -x[5].x()) do let var x := 5 var x := 5 in end
function x(x : int) = int [-break] of for x := () to () do break
type x = {x : int} type x = class {} class x {}  import "empty.tih"
new int
function x(x : int, x : int) = if let  in end then if "totor" then break else 5 else int [break] of ()
int [x()] of if int {x = x.x.x()}  then if int {x = x(), x = int {} }  then int {x = x(5, nil), x = if "totor" then 5 else "totor"}  else int {x = while "totor" do (), x = while "totor" do break}  else x[break].x.x(x[()], int {x = x()} )
-int [for x := x(int [()] of (), x()) to x.x.x() do int [int ["totor"] of ()] of new int] of let import "empty.tih" var x := 5 in new int ; "totor" ; 5 end
class x extends int {var x := 5}  class x extends int {var x := 5} 
int [x.x[new int][let var x := 5 in "totor" end].x(for x := x[()] := x.x() to let  in end&(5) do let var x := 5 in nil ; 5 end, int [new int] of x(break, 5)+while int {}  do new int)] of let class x {}  in end
type x = int type x = {}
function x(x : int) = for x := int {x = "totor"}  to -"totor" do "totor"|() class x extends int {var x := 5} 
x(new int, for x := let import "empty.tih" in x.x() ; 5 end to x() do int [let var x := 5 in end] of if x then int {}  else (5))
type x = class extends int{var x := 5}
var x := let  in end
function x(x : int) = if int {x = "totor"}  then x.x() else let  in 5 end var x : int := "totor"
type x = array of int
class x extends int {var x := 5} 
x.x[int {x = (), x = break} ].x[x.x := if "totor" then ()+int {} ].x(for x := x[()].x := x() to x[5].x := x[()] := -5 do int {x = ("totor")} , x[break].x.x)
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() = break var x := 5 var x := 5
if new int then x(-let var x := 5 in end, -int {x = ()} *x[5] := x.x("totor", 5))
function x(x : int) : int = int {x = x.x()} 
let var x := 5 in end-x()
function x(x : int, x : int) = x.x.x(-nil, x) function x(x : int) = x := ()
function x(x : int, x : int) = let var x := 5 in () end class x extends int {var x := 5}  class x {} 
let class x extends int {var x := 5}  type x = int in x.x.x.x() ; let var x := 5 in end end
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = ()|() var x := 5
x[break][int {x = ()} ].x[let var x := 5 in int [()] of break ; nil end] := x(x[5].x := x.x.x(), while let var x := 5 in end do while new int do if () then break else break)
class x {var x := 5} 
if if let var x := 5 var x := 5 in end then let import "empty.tih" var x := 5 in end then int {x = x.x.x.x(), x = let var x := 5 var x := 5 in end}  else int [x[nil].x.x()] of if let var x := 5 in end then if if nil then 5 then x := () else int {x = let  in 5 end, x = -nil} 
-let type x = int import "empty.tih" in end
function x(x : int) = -let  in end var x := ()
function x(x : int, x : int) : int = (5 ; 5)
class x extends int {var x := 5} 
var x := while 5 do nil function x(x : int) = -5 function x() : int = 5 import "empty.tih"
int {x = (new int), x = x[break][x.x()].x} 
function x(x : int) : int = --nil
function x(x : int) : int = new int
x()
x()
class x extends int {var x := 5 var x := 5} 
type x = {x : int}
class x {var x := 5}  class x {var x := 5} 
for x := if x[break][x].x() then while let var x := 5 in break ; 5 end do -x else x[break][let  in 5 end] := ("totor" ; 5) to int {x = x(), x = if while if "totor" then nil do x(break, nil) then x.x.x()}  do --int {x = nil} -let import "empty.tih" in while () do 5 ; 5 ; 5 end
function x(x : int) : int = int {x = int {x = ()} , x = if break then ()} 
function x(x : int) = for x := while 5 do 5 to int {x = "totor", x = break}  do 5-break
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  var x := 5
function x(x : int, x : int) : int = for x := x := nil to int {x = nil}  do let  in end function x(x : int) : int = x.x()
int {x = int {x = x[nil][int {x = 5} ]} } 
let function x(x : int) = -() type x = int in end
int {} 
var x := let  in 5 end class x {var x := 5} 
type x = class extends int{var x := 5} class x extends int {var x := 5} 
var x : int := int [nil] of "totor" function x(x : int) = x := break
x(x[5].x[while int {x = "totor"}  do new int].x(), x[break].x.x.x())
function x(x : int) = x((5), new int)
-x(x()+int {x = int {x = nil, x = break} } , let import "empty.tih" var x := 5 in int {}  ; "totor" ; 5 end)
function x(x : int) = let var x := 5 in end
type x = class extends int{var x := 5} class x {var x := 5}  type x = int var x := 5
function x(x : int) : int = int {x = break, x = break} --"totor"
class x {var x := 5 var x := 5} 
(x.x[x()].x(x[nil].x(int [()] of 5, int {x = break} ), x[5]) ; int {}  ; int {x = 5}  ; 5 ; 5)
x.x.x.x[if int {x = let  in 5 end, x = for x := () to "totor" do break}  then let var x := 5 in end else x.x := nil|"totor"] := x(int {x = let var x := 5 in end} , new int)
x()
type x = array of int function x(x : int) = x.x(break, "totor")
if if int {}  then while new int do int [()-break] of int {}  then for x := if int {}  then while if break then () else () do while "totor" do () to x.x.x.x() do int [x.x.x(if nil then nil, int [()] of 5)] of x[5]
class x extends int {var x := 5 var x := 5}  var x : int := "totor" class x extends int {}  var x := 5
x.x.x[let var x := 5 in end].x.x(x.x.x[x[nil]], int {} )
function x(x : int, x : int) = x[()].x(-nil, x.x())
x.x[int {x = break} ][if int {x = nil}  then int {x = break, x = 5} ].x()*if x[nil].x.x(if while nil do nil then while "totor" do "totor", if for x := 5 to 5 do () then int {x = 5} ) then while x(int {} , -()) do let var x := 5 in end
x.x[(5)].x.x := new int
while -if int [for x := nil to "totor" do break] of x((), 5) then let var x := 5 in break end else if while break do () then while "totor" do () else x.x() do let import "empty.tih" in end|int {} 
-int {x = x.x.x.x(x(for x := "totor" to break do break, x), x.x.x())} 
class x {var x := 5}  type x = class {}
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
var x : int := x.x((), break)
let type x = {} in if int {} *int {x = break}  then x() ; (nil) end
class x {var x := 5}  class x extends int {var x := 5} 
var x := let  in end class x {var x := 5}  var x := 5 import "empty.tih"
let class x extends int {}  var x := 5 in while x do int [5] of () ; if "totor" then 5 else nil end|x.x.x.x
function x(x : int) : int = x.x := break+nil
type x = {x : int} type x = class extends int{} type x = int var x := 5 var x := 5
class x extends int {var x := 5}  function x(x : int) = int {} 
x(x[break].x.x, x[()][x.x("totor", break)][x[()] := while 5 do "totor"])
int [-x.x[x].x()] of int [new int] of for x := x.x.x(let  in 5 end, x.x()) to if x.x() then -nil do int {x = x()} 
var x : int := int {x = break, x = ()}  function x(x : int) : int = int {x = "totor"}  var x := 5 import "empty.tih" var x := 5
type x = array of int
(int {x = new int, x = -x.x()} )
function x(x : int, x : int) : int = while x.x() do for x := () to () do "totor" type x = class extends int{} var x := 5
type x = class {var x := 5} type x = class extends int{}
int {x = int {x = (while nil do "totor"), x = let import "empty.tih" var x := 5 in while () do 5 ; break ; 5 end} , x = new int} 
var x := int {x = ()} 
class x {var x := 5 var x := 5} 
function x(x : int, x : int) = x[break]
if for x := if let var x := 5 in nil end then int {}  else int {}  to x() do new int then if for x := int [-break] of x := break to x.x.x(while () do nil, new int) do int [x.x()] of x then x.x.x.x()
class x {var x := 5} 
x.x.x := for x := while nil do () to new int do let  in end+int {} -new int
x[()][if "totor" then break][x[()]][let import "empty.tih" in end].x(x.x[int ["totor"] of break][x.x.x(int {x = (), x = "totor"} , let  in 5 end)].x(if let var x := 5 in "totor" end then let var x := 5 in 5 ; 5 end, x.x.x.x(x(new int, while break do ()), new int)), int {} )
class x extends int {var x := 5}  function x(x : int) = int {} 
x[break][-5][(5 ; 5)].x.x(int [int [(())] of x()] of new int, -int {x = -(5), x = x()} )
(x[()].x.x(new int, int {x = int {} } ))
class x {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = let  in 5 end function x() = break
int {} 
(while if let  in end then new int else -break do for x := for x := break to break do nil to let  in end do int ["totor"] of "totor")
var x : int := x.x()
int {x = x["totor"][while () do 5][new int].x()} 
x.x.x.x.x(new int, if x() then let var x := 5 in 5 end else (nil))*(if while 5 do () then x())
for x := let function x() : int = break in end to (int {x = new int} ) do x()
if int {x = let import "empty.tih" in int {x = break, x = ()}  ; () end}  then (while while "totor" do nil do x.x(5, "totor") ; int {x = 5, x = break} )
var x := -()
function x(x : int) : int = x() type x = int type x = int var x := 5
function x(x : int, x : int) : int = let var x := 5 in nil ; 5 end
let function x(x : int) = for x := () to nil do nil in int {x = int {x = while break do nil} }  ; nil&()|for x := () to "totor" do "totor" end
x.x[int {} ].x[x(int {x = x, x = "totor"/()} , int [if "totor" then 5 else nil] of x := ())] := x(x[nil].x, int {} )
type x = int class x {var x := 5} 
function x(x : int) : int = int [new int] of x("totor", ()) var x := nil function x() : int = nil
x()
x["totor"].x[if for x := "totor" to 5 do 5 then int [break] of "totor"].x
int {x = x(), x = let class x {}  in end} 
function x(x : int, x : int) : int = int [int {x = nil} ] of int [break] of 5 var x := nil
var x := if break then () else () class x extends int {var x := 5}  type x = int var x := 5 var x := 5
if x(x.x.x := for x := for x := break to () do "totor" to x.x() do x.x(), x.x[(5)].x(int {x = nil/break} , let var x := 5 in "totor" end)) then if x.x := while break do 5&int {x = x("totor", nil), x = -5}  then int [for x := new int to x := nil do for x := 5 to 5 do "totor"] of for x := x.x() to x() do if break then () else break else int {x = while x.x.x(if () then "totor" else nil, (5)) do int [()|5] of if break then nil else "totor"} 
let var x : int := 5 in x[5][x("totor", break)].x((5 ; 5), x/while nil do nil) end
class x {var x := 5} 
type x = class extends int{var x := 5}
if int {x = int {} }  then int {}  else int [-if x := "totor" then if nil then nil else ()] of int {x = x["totor"].x()} 
x.x.x[int {} ][x[nil][int ["totor"] of ()].x(x(x.x((), "totor"), ()/nil), x.x)]
while x.x.x[x(while nil do nil, int {} )].x() do x.x[if 5 then break].x.x()
let function x(x : int) = let  in 5 end function x() = break var x := 5 in end
class x {var x := 5 var x := 5}  var x : int := nil
var x : int := if nil then "totor" else 5
int {x = if (let  in 5 end ; nil) then x.x.x := for x := (5) to int [break] of 5 do int {x = nil} , x = int [while x[nil] do int {x = x(break, ())} ] of new int} 
function x(x : int, x : int) : int = -int ["totor"] of nil class x {var x := 5} 
for x := while int {}  do if int {}  then (break) else int {x = x(), x = x.x(5, 5)}  to x.x[if () then () else "totor"][x[nil] := let  in end] := x.x[x()] do if while x[nil] := x do if x then (5) then int {} 
x[()][int {x = nil, x = 5} ].x[int {x = x()} ] := int {x = int {x = if int [nil] of 5 then while 5 do () else int {x = "totor"} } } 
let class x extends int {var x := 5}  class x extends int {}  var x := 5 var x := 5 in end
x.x.x.x.x.x()
class x extends int {var x := 5} 
int {x = int {} , x = for x := for x := (() ; 5) to int {}  do while for x := () to () do nil do for x := "totor" to "totor" do nil to let var x := 5 in int {x = (), x = nil}  end do if if x.x() then ()+5 else x.x(5, "totor") then let var x := 5 in 5 end else while new int do if () then nil} 
while x.x.x[x(let  in end, let  in 5 end)].x(let import "empty.tih" var x := 5 in end, x.x.x) do int [while new int do while int {}  do x.x(5, break)] of new int
let var x : int := "totor" class x {}  var x := 5 var x := 5 in let var x := 5 var x := 5 in end end
int {} 
function x(x : int) = int [x.x(nil, 5)] of int {x = break} 
var x : int := int {} 
type x = {x : int} function x(x : int) = if () then 5 else () type x = int
let var x := nil in for x := for x := x.x() to x do x() to x() do -x() end
class x {var x := 5 var x := 5} 
x[5][int ["totor"] of nil][int {x = x := (), x = x := ()} ][(x)]
x[break][x].x[if new int then let var x := 5 in nil ; 5 end].x()
int {x = x[nil].x[let var x := 5 in end], x = for x := let import "empty.tih" var x := 5 in end to new int do if x.x() then x() else int {x = break, x = "totor"} -for x := ()&5 to int [nil] of () do if nil then () else break} 
class x extends int {var x := 5}  class x extends int {var x := 5} 
x.x.x[int [x((), ())] of x.x()].x.x(if int {x = let var x := 5 in 5 end, x = ("totor" ; 5)}  then if x.x.x() then let var x := 5 in end else if "totor"+nil then let  in 5 end else if x[nil] := let  in 5 end then while for x := 5 to () do 5 do int ["totor"] of break else while let  in end do let  in end, int [-let  in end-x[nil].x()] of let var x := 5 in let  in end ; break ; 5 end)
let var x : int := () class x extends int {}  import "empty.tih" var x := 5 in if while let  in 5 end do if break then "totor" then new int else int {}  end
class x extends int {var x := 5 var x := 5}  var x := 5
type x = class {var x := 5}
while x(x(), int [if x() then x.x((), break) else int [nil] of 5] of let var x := 5 in end) do x["totor"][while "totor" do break][new int]
type x = class extends int{var x := 5}
((x ; 5 ; 5) ; x.x := x := "totor" ; if break then 5)
function x(x : int) = for x := "totor" to "totor" do nil&x.x() class x {var x := 5} 
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
if if x(for x := let  in 5 end to int {x = 5}  do new int, x[break]) then int {x = int [let  in end] of x, x = x.x("totor", "totor")-5|()}  else let var x := 5 var x := 5 in end then x[nil].x.x := int {} 
function x(x : int) : int = x()
class x extends int {var x := 5 var x := 5} 
let var x := () type x = int in int {} *x() ; x.x end
var x := nil&break
int {} 
if -if x.x := 5&5 then let  in end/x() else let var x := 5 in end then int {x = if if int {x = (), x = "totor"}  then let  in end else int [5] of 5 then x.x.x()}  else int {x = x.x[x.x()].x(for x := int {}  to int [()] of nil do int {x = nil, x = 5} , int {x = int [break] of (), x = if 5 then nil} )} 
x[()].x.x[new int].x()
int [new int] of int [int {} ] of x[nil][new int] := x()*let  in 5 end
for x := -x[()][new int].x(for x := let  in 5 end to if () then "totor" else break do x, x[break] := int ["totor"] of nil) to x.x[int {} ].x.x() do int [int {} ] of for x := let var x := 5 in end to int {x = if break then (), x = x.x()}  do new int
var x : int := int {} 
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
class x extends int {var x := 5}  function x(x : int) : int = int {} 
let var x : int := 5 in if x["totor"] := -() then if -"totor" then (5) else x.x.x() ; while new int do let  in 5 end end
int {x = int {} , x = int {} } 
let function x(x : int) : int = new int in end
x()
if if x["totor"][while () do nil] := for x := int {x = 5, x = nil}  to let  in 5 end do (5) then new int else -int {x = new int}  then int [int {x = if for x := () to () do () then x(break, "totor")} ] of x(while "totor" do (), x.x(break, 5))&if for x := break to nil do break then if nil then nil
if -if x[break] := -"totor" then if x.x() then int [5] of nil else 5|() else -if break then 5 then x.x.x[x[nil] := (5)] else int {} 
int {x = let type x = int import "empty.tih" in x.x := x end} 
int {x = new int, x = x()} 
type x = array of int
-x()
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = -"totor" class x {} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = x.x() class x extends int {} 
for x := x[nil][if () then "totor" else ()][x.x] := x[break].x(int [5] of break, x.x((), "totor"))+let var x := 5 in nil end to int {x = (-nil), x = x()}  do int [if if (5) then x.x() then int {x = (5), x = let  in 5 end} ] of let var x := 5 in x.x(nil, 5) end
class x extends int {var x := 5}  function x(x : int) : int = int {x = break} 
function x(x : int, x : int) = x.x := (5)
let function x(x : int) = let  in 5 end in end
new int
type x = {x : int} class x {var x := 5} 
x()
for x := while int {x = let var x := 5 in end, x = x(x, int {x = "totor", x = "totor"} )}  do -int {}  to if x[break].x then new int else int {x = new int&new int}  do x.x.x.x
x.x[int {x = nil} ][new int].x.x(let function x() : int = 5 var x := 5 in end, x(new int, int [5] of nil&if nil then 5*while (5) do while break do 5))
if if x.x.x(5/break, let  in end) then if while "totor" do break then new int else while break do 5 else new int then int {} +int {x = -int [x()] of for x := "totor" to 5 do break, x = int {x = x(x := break, int {x = 5} ), x = int {} } } 
new int
function x(x : int, x : int) = ()-5-int {x = "totor"} 
function x(x : int) : int = while x := "totor" do nil/nil
x.x.x.x.x
while x() do int {x = let var x := 5 var x := 5 in let  in 5 end ; break ; 5 end} 
function x(x : int) = int {x = int {x = "totor"} } 
var x := let  in 5 end
for x := if x[break].x(int {x = "totor", x = break} , new int) then -(5) else if x("totor", "totor") then x else x := ()-if x() then x()|new int to if -x.x.x() then let var x := 5 in end do int {} 
(if int [x()] of (5) then int {x = int {x = nil, x = "totor"} , x = int {x = ()} }  ; x["totor"].x(x.x("totor", "totor"), while "totor" do 5))
for x := let var x := 5 import "empty.tih" in end to (if "totor" then () else 5)+(for x := break to break do "totor" ; "totor") do x[break].x.x.x(if int {}  then x[()] else int {x = x(), x = int {x = (), x = break} } , int {} )
x()
if (new int ; let  in end ; "totor") then let type x = int import "empty.tih" var x := 5 in end else let var x := 5 import "empty.tih" var x := 5 in x() ; "totor"|5 end
int [x()] of x[5].x.x.x(int {} , new int)
(x.x.x()|while int {x = 5, x = break}  do int {x = nil, x = "totor"} )
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
x[break].x.x.x := int {} 
int {x = if int [int {x = ()*break} ] of int {x = let  in end}  then int {} , x = -new int} 
int {x = (x(x(5, ()), for x := break to break do 5))} 
type x = class extends int{var x := 5} class x {var x := 5}  function x() : int = nil
for x := new int to while x(new int, new int*for x := "totor" to nil do ()) do x.x[int {x = "totor", x = 5} ] do if -let var x := 5 in "totor" end then while x[break].x() do x(let  in 5 end, x.x((), 5)) else -"totor"/break|x
(int {} )
function x(x : int, x : int) = new int
x.x[int {x = break} ].x.x
x[5][int {x = "totor"} ].x[x(x[5].x(int [nil] of 5, x := nil), x["totor"].x())] := if x() then int {}  else int {x = let var x := 5 in end} 
int [int {x = int {x = -()+for x := 5 to break do 5, x = x()} , x = x.x[int [nil] of ()] := x(let  in 5 end, int {x = break} )} ] of int {x = let var x := 5 var x := 5 in for x := "totor" to () do break end, x = int [x()] of -(5)} 
function x(x : int) = x.x.x() var x := ()
for x := x.x[int {x = 5} ].x.x() to let var x := 5 import "empty.tih" in end do x()
class x {var x := 5}  function x(x : int) = x.x(nil, 5)
new int
type x = array of int
function x(x : int, x : int) = (() ; 5) class x extends int {var x := 5}  function x() = "totor" import "empty.tih"
function x(x : int) : int = if int {x = nil, x = 5}  then if "totor" then 5 else 5 else x.x((), nil) function x(x : int) = if 5 then 5 else nil class x extends int {}  var x := 5
class x extends int {var x := 5 var x := 5}  type x = class {} class x {}  import "empty.tih"
while x.x[int {x = (), x = nil} ].x := if while x do int {x = nil, x = break}  then int {x = let  in 5 end}  do x[break].x.x.x(x[5].x := x[break], int {} )
int {x = x(x.x.x.x(), x[break].x.x(let var x := 5 in () ; 5 end, x["totor"])), x = int {x = let var x := 5 var x := 5 in if 5 then "totor" else nil end, x = if if new int then "totor"|() then x["totor"] := (5) else x.x.x()} } 
int {} 
x[5][-"totor"].x[if x.x.x(for x := nil to break do 5, let  in 5 end) then for x := if () then () else break to x := nil do new int else let var x := 5 in "totor" ; 5 end] := while if x.x.x(x.x(), x.x(5, break)) then while let  in end do -"totor" do let var x := 5 var x := 5 in -nil end
type x = class extends int{var x := 5}
var x : int := new int
function x(x : int, x : int) = if while "totor" do () then for x := nil to nil do nil
x()
function x(x : int) = x(new int, while break do nil) function x(x : int) : int = if "totor" then nil function x() = 5 import "empty.tih"
new int
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = if 5 then "totor" else nil
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = int {x = (), x = ()}  class x {}  var x := 5
x[()].x[if -5 then let  in end else int {} ].x := x.x.x.x.x(let var x := 5 in end, while while (5) do int {x = (), x = ()}  do x[break] := (5))
var x : int := x := 5 class x extends int {var x := 5} 
type x = {x : int} class x extends int {var x := 5}  class x extends int {}  var x := 5
x[nil].x[int {} ].x := for x := let var x := 5 in x((), break) end to int {x = x(), x = int [()] of break/x}  do new int
var x := x(5, ()) class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
int [x.x[new int] := int {x = x.x()} ] of x()|x[nil].x[if let  in 5 end then new int else break|break].x(while new int do x := break|int [new int] of ()/5, x(x(let  in end, x()), int {x = int {} } ))
class x {var x := 5 var x := 5}  function x(x : int) = while "totor" do nil var x := 5
var x : int := new int function x(x : int) = (5)
class x {var x := 5 var x := 5} 
class x extends int {var x := 5}  function x(x : int) = x.x("totor", 5)
class x extends int {var x := 5 var x := 5} 
class x {var x := 5} 
x.x[if () then "totor" else nil].x[let import "empty.tih" in end]
type x = class {var x := 5}
if -while -(5) do x(int [()] of nil, x()) then (let var x := 5 in end)
new int
type x = class extends int{var x := 5}
-new int|if let var x := 5 in () end then let var x := 5 in end
function x(x : int, x : int) = for x := int ["totor"] of break to x := () do -break
class x extends int {var x := 5}  function x(x : int) = int {x = break, x = ()} 
type x = array of int function x(x : int) = if "totor" then nil
int {x = -x[break][let  in end].x(if int {x = "totor", x = ()}  then let  in 5 end else if () then "totor" else (), int {x = x.x(5, 5)} )} 
int [x()] of -x[5].x.x(for x := ()+break to for x := break to "totor" do () do -"totor", let var x := 5 in end)
var x := new int
var x := int {x = nil} 
type x = int
x()
class x {var x := 5} 
var x := -break class x extends int {var x := 5} 
int {} 
new int
int {x = x.x[5*"totor"].x} 
x.x[int {x = nil, x = break} ].x.x.x()
type x = class extends int{var x := 5} class x extends int {var x := 5} 
int {x = int [x()] of int {x = -x()} } 
x[break].x.x.x.x(for x := while x[break] := -() do x["totor"] := new int to new int do new int, if let import "empty.tih" var x := 5 in 5*break ; break end then new int else int {} )
x()
class x extends int {var x := 5 var x := 5}  var x := break
x.x.x[if x.x(5, "totor") then x.x(nil, 5) else x.x("totor", ())].x.x(x.x.x[int {} ].x(), if while if (5) then let  in end else -"totor" do x(x.x(), x()) then int [x[5] := for x := nil to "totor" do nil] of for x := int {x = ()}  to -break do int [break] of "totor" else int {x = x[nil], x = let var x := 5 in end} )
class x extends int {var x := 5}  var x : int := break
var x : int := x((), ())
function x(x : int) : int = if int {x = ()}  then while "totor" do break else int ["totor"] of ()
function x(x : int) = if new int then x.x((), "totor") else let  in 5 end
new int
var x : int := for x := break to nil do "totor"
int {x = -let import "empty.tih" in end, x = int {x = (int {}  ; break ; 5), x = let import "empty.tih" var x := 5 in end} } 
int {x = x[5].x.x, x = new int} 
type x = class extends int{var x := 5}
class x {var x := 5} 
class x extends int {var x := 5}  function x(x : int) = if "totor" then ()
if new int then int [x.x.x.x()] of if if let  in 5 end then let  in 5 end else for x := "totor" to () do () then if while break do 5 then let  in end else int [break] of break else int {} 
type x = array of int function x(x : int) : int = if "totor" then nil
class x extends int {var x := 5}  var x := "totor" type x = int var x := 5
function x(x : int) : int = new int var x := "totor"
x(int {x = int {x = let var x := 5 in break ; 5 end, x = let var x := 5 in break ; 5 end} , x = for x := x(-"totor", let  in 5 end) to -let  in 5 end do -new int} , -let import "empty.tih" in end)
x.x.x.x[-let var x := 5 in end] := x["totor"].x[x[()]].x()
int {x = int {x = let var x := 5 in end, x = x[5][(5)].x()} , x = let function x() : int = "totor" var x := 5 in while x do int {x = "totor"}  ; (5) end} 
x[break].x[-break*()][let var x := 5 in break ; 5 end-for x := x(break, nil) to -nil do int [nil] of 5].x(new int, while new int do while if x.x() then -() else new int do if x := 5 then x.x(nil, 5))
class x {var x := 5 var x := 5} 
int {} 
x[5].x[("totor" ; 5)][((5) ; "totor" ; 5)].x()
if int {x = if x.x then x[break].x(new int, int [nil] of "totor"), x = int {} }  then (x[5].x() ; int [break] of "totor" ; 5)
x[nil][let  in 5 end].x[x.x.x()*int {x = if nil then break, x = int {} } ].x(int {x = int {x = let var x := 5 in () ; 5 end} } , x.x[int {} ].x.x(x.x.x.x(), x(x.x := x := (), int [-break] of if nil then 5 else break)))
let type x = int import "empty.tih" in int [if nil then "totor"] of while nil do "totor" end&int {x = x.x[int {x = ()} ]} 
for x := -x.x.x.x() to for x := if let var x := 5 in nil ; 5 end then for x := int {}  to let  in 5 end do while () do () else x() to x.x.x.x() do x(if (5) then x.x(nil, nil) else if 5 then break, int [x.x(nil, nil)] of int {x = "totor"} ) do (if if break then () else () then if break then "totor" else break else int ["totor"] of break ; new int)
function x(x : int, x : int) = ("totor" ; 5)
x()
type x = int function x(x : int) = new int
if for x := if while int [()] of 5 do (5) then x.x.x(int {} , int {x = break, x = ()} ) else -"totor"*5 to x.x.x do let import "empty.tih" in if "totor" then "totor" else () ; 5 end then (if break then ()*x.x((), nil) ; while break do 5)
function x(x : int) = new int
let type x = int in end
type x = class extends int{var x := 5}
new int
function x(x : int, x : int) = x[()].x(int {x = nil, x = break} , x()) type x = {}
type x = array of int class x {var x := 5} 
function x(x : int) = int {x = x, x = -"totor"}  class x {var x := 5} 
(if if x.x() then int {x = break, x = break}  then if int [break] of "totor" then x else for x := "totor" to nil do break)
int {} 
var x : int := if nil then "totor"
let function x(x : int) = int {x = ()}  in end
class x extends int {var x := 5}  function x(x : int) : int = -5 function x() = break var x := 5 var x := 5
-x(new int, if let var x := 5 in break ; 5 end then if x.x() then x(nil, ()))
function x(x : int) : int = int {x = x := "totor"} 
int {} 
x()
x(while if -x := "totor" then int {x = int {x = "totor"} }  else int {x = x.x(break, 5), x = while () do break}  do while int {}  do int {x = x.x(), x = x} , if int [while for x := break to () do "totor" do 5/()] of int [-5] of int {x = ()}  then if int {}  then (break) else let  in 5 end-(5) else if x(nil, nil) then for x := "totor" to break do 5 else new int*x(let  in 5 end, x()))
type x = class extends int{var x := 5} function x(x : int) = while () do "totor"
int {x = x.x[let  in 5 end][while () do ()&while nil do "totor"].x(while int {x = new int, x = x}  do int ["totor"+5] of new int, x())} 
-x[5].x[-int {x = nil, x = ()} ] := x[nil][new int].x()
var x : int := int {}  function x(x : int) : int = int {} 
x.x[for x := 5 to () do ()].x[x[5][int {x = "totor", x = ()} ].x(int {x = new int} , int [x((), nil)] of while nil do nil)].x(-let var x := 5 in if "totor" then "totor" end, x.x.x[x.x.x(new int, new int)])
int {} 
type x = int function x(x : int) = x function x() = nil import "empty.tih"
class x {var x := 5}  function x(x : int) = -break function x() = 5 var x := 5
x[nil][x.x()].x.x
function x(x : int, x : int) : int = int {x = if nil then () else 5}  type x = {} type x = int
-int {} *x()
class x {var x := 5}  type x = int
type x = class {var x := 5}
x(int {x = if new int then x[break].x() else x[break].x()} , while x(x[5].x(), int {x = x()} ) do int {x = int [if () then () else ()] of int [break] of 5, x = int {x = new int} } )
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
function x(x : int) = while new int do nil-()
int {} 
int {x = for x := int {}  to while (break) do int {x = for x := 5 to nil do ()}  do -for x := x.x((), ()) to x.x() do x.x(), x = x.x.x[new int]} 
class x {var x := 5}  function x(x : int) = ()*"totor" class x {} 
int {x = if (nil ; 5) then for x := let  in 5 end to x do (5) else let var x := 5 in end-let import "empty.tih" in x.x() end, x = x[()].x.x.x(x["totor"].x, if if x(nil, 5) then if () then "totor" else break else int [break] of 5 then int [(5)] of let  in end else x[nil])} 
class x {var x := 5} 
if x[break].x[x["totor"].x(if 5 then nil else break, let  in end)] then x()/x[break][x] else if x(x(x, x), -x.x(5, "totor")) then x.x[x()]
-x.x[new int][x.x.x()]
x[5].x.x.x.x()
class x {var x := 5 var x := 5} 
(x(-if break then "totor" else (), x()) ; while int {x = "totor"}  do -5 ; ()-break ; break)
x()
int {x = while for x := if if 5 then break then new int else if 5 then break to -x() do int {x = "totor", x = ()} &break&"totor" do let var x := 5 in end} 
function x(x : int) : int = x.x.x(if nil then break, x) type x = int
while int {x = ((5) ; () ; 5), x = new int}  do int {} 
let function x() : int = nil in end-int [int {x = (break ; 5), x = x(if nil then "totor", -())} ] of -x.x.x()
class x {var x := 5 var x := 5} 
-while x(int {x = ()/break, x = let  in end} , -break+"totor") do let var x := 5 in x := 5 ; () end
int {} 
class x extends int {var x := 5}  function x(x : int) = -"totor"
let type x = array of int in ((5) ; 5 ; 5) end
new int
function x(x : int, x : int) = int {x = if break then "totor" else 5, x = x.x(break, "totor")}  class x extends int {var x := 5} 
x()
var x := let  in end class x {var x := 5}  class x {}  import "empty.tih" var x := 5
int {x = int {x = x()+int {x = break&break} , x = int [let var x := 5 in () end] of (5)} , x = new int} 
class x {var x := 5 var x := 5} 
function x(x : int) = int [x.x("totor", break)] of x() type x = class extends int{}
class x extends int {var x := 5}  var x : int := "totor"
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  class x {} 
int [x()] of let function x() = () in let  in end&new int ; x.x() ; nil end
new int
function x(x : int, x : int) : int = x()
x.x[for x := 5 to break do break][for x := x to while nil do () do int {x = 5} ].x.x()
(x(nil, nil))&-if let  in 5 end then -break else x.x("totor", 5)-if x[break][int [nil] of ()] := while x() do let  in end then x() else if ("totor") then x["totor"] := if "totor" then break
function x(x : int) : int = x[()].x((5), int {x = break, x = break} ) function x(x : int) : int = int {x = "totor"} 
int {x = x(), x = let function x() : int = () var x := 5 in let var x := 5 in end end} 
class x extends int {var x := 5} 
int {x = x[5][x(5, nil)][x()]} 
x()
let class x extends int {var x := 5}  in new int ; if let  in 5 end then x() else while 5 do nil ; int [5] of 5 end
while let function x() : int = 5 import "empty.tih" var x := 5 in x.x ; -5 end do x[break].x.x
-for x := int {} *if 5 then break else nil&let var x := 5 in end to x[nil].x := x(while "totor" do break, (5)) do x.x[int {x = "totor", x = 5} ] := x.x.x()
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
x()
function x(x : int, x : int) = int [let  in end] of int {}  type x = {} function x() = nil
let function x(x : int) = int {}  in end
type x = class extends int{var x := 5} class x extends int {var x := 5}  type x = int
if x[()][x].x.x(x(), int {} ) then x(int {x = if if "totor" then "totor" then while 5 do break, x = x[()].x(int {x = (), x = "totor"} , x.x())} , while let var x := 5 in break end do int {} )
var x := int {x = (), x = 5} 
class x extends int {var x := 5}  function x(x : int) : int = -5
function x(x : int) = if x() then "totor"*break else x.x()
type x = {x : int}
var x := x
class x extends int {var x := 5} 
let class x extends int {var x := 5}  in end
class x {var x := 5 var x := 5}  class x {var x := 5} 
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  type x = int import "empty.tih"
var x : int := let  in 5 end
let function x(x : int) = x class x extends int {}  var x := 5 in x[5][(5)] := int {}  end
var x := x() type x = {}
function x(x : int) = int {x = int {x = break} , x = int [break] of break}  function x(x : int) = "totor"|5
type x = class extends int{var x := 5}
while new int do if x["totor"].x() then int {}  else ("totor" ; 5)/for x := new int to x+if "totor" then nil else nil do for x := "totor" to break do nil|(5)
int {} 
var x : int := while 5 do ()
class x {var x := 5 var x := 5}  function x(x : int) : int = int {x = ()}  class x {} 
int {} 
class x extends int {var x := 5} 
x()
function x(x : int) : int = x(int ["totor"] of nil, new int)
function x(x : int, x : int) = if int [()] of "totor" then int {x = break}  type x = {} function x() : int = nil import "empty.tih"
x()
-x.x.x[if int {x = break}  then int [5] of "totor" else while () do 5] := if (break) then let var x := 5 in () ; 5 end
class x {var x := 5 var x := 5} 
for x := x()+new int to x[5].x.x.x() do int {x = int {} } 
class x {var x := 5 var x := 5} 
class x {var x := 5}  class x {var x := 5} 
var x : int := "totor"&nil
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
var x := let  in 5 end
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() = nil var x := 5
for x := int {x = int {x = x.x.x(), x = x[5] := if nil then ()} }  to let class x extends int {}  import "empty.tih" in x(break, nil)|if nil then 5 else () ; nil+"totor" ; break end do x.x[(5)].x.x()
function x(x : int, x : int) = x.x.x() class x extends int {var x := 5}  function x() = 5
new int
(x["totor"].x.x(let var x := 5 in break end, x.x.x()) ; int {}  ; x(break, break))
function x(x : int, x : int) = x.x
function x(x : int) : int = int [for x := break to break do "totor"] of -"totor"
-x()
x(x[nil][(5)][int [x := "totor"] of if () then "totor" else "totor"], while while x() do while x(break, 5) do -5 do if int {x = int {x = 5, x = "totor"} }  then let var x := 5 in nil end else x.x.x(let  in end, x()))
class x extends int {var x := 5}  class x {var x := 5}  type x = int
x.x[if () then 5 else break][x[()].x()][let import "empty.tih" in x.x() ; break end] := int {x = int {x = if int [nil] of "totor" then let  in end} } 
var x := while break do 5
function x(x : int) : int = int {x = nil} *5|"totor" function x(x : int) : int = x((), "totor") function x() : int = break var x := 5 var x := 5
x()
let class x extends int {var x := 5}  in end
class x extends int {var x := 5} 
function x(x : int) = -x := 5 function x(x : int) : int = -()
var x := new int function x(x : int) = nil/5 class x {} 
var x : int := if "totor" then nil
-int {} 
if x(x(int [new int] of if () then () else break, (5 ; 5)), x[break].x.x(let var x := 5 in end, x[5])) then if let var x := 5 in end then if x.x := while () do 5 then x.x.x(x.x(5, break), if 5 then "totor") else let function x() : int = () var x := 5 var x := 5 in int {}  end
var x : int := while nil do "totor"
let function x(x : int) = x(nil, "totor") in let var x := 5 in int [break] of break end end
function x(x : int) = -int {x = "totor"}  class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
function x(x : int, x : int) : int = int [if break then ()] of int {}  type x = class extends int{} var x := 5 var x := 5 var x := 5
class x extends int {var x := 5 var x := 5} 
new int
type x = {x : int}
let class x {var x := 5}  class x extends int {}  in let var x := 5 in end*x(if "totor" then 5, new int) ; let var x := 5 in end end
if let type x = int in if int {x = 5, x = 5}  then x() else x() ; (5) end then -for x := while int {x = "totor"}  do "totor"|break to for x := x.x(nil, 5) to -nil do x := "totor" do let var x := 5 in end else let class x extends int {}  var x := 5 in end
x()
function x(x : int, x : int) = x.x.x()
class x extends int {var x := 5}  class x extends int {var x := 5} 
x()
int {x = while (int {x = 5, x = nil}  ; break ; 5) do ((5) ; break ; 5), x = int {x = x.x.x.x(), x = int {x = x.x, x = x(if "totor" then () else 5, "totor"/5)} } } 
(-if x() then if break then 5 else break else new int)
class x extends int {var x := 5}  function x(x : int) = (5)
function x(x : int) = x.x.x((5), int {x = ()} )
while if x[()].x()&int [nil] of ()--5 then while x()+-break do x() do x()
class x extends int {var x := 5}  class x extends int {var x := 5}  function x() = "totor"
int {x = (int [int [5] of 5] of break&5)} 
class x {var x := 5} 
class x {var x := 5} 
type x = int type x = array of int
new int
let type x = class extends int{} class x {}  import "empty.tih" in x[5].x end
x(x["totor"].x.x.x(x(x[break] := int {x = "totor", x = ()} , (5)|int {} ), -x[break].x(x.x("totor", "totor"), new int)), let class x extends int {}  in end)
((let  in end))
int {x = int {} , x = if x[nil].x.x(if new int then -"totor" else new int, x.x.x()) then x.x.x := int [if "totor" then nil else "totor"] of (5)} 
let class x extends int {var x := 5}  class x {}  in end
type x = array of int function x(x : int) : int = if nil then nil function x() = break
let class x extends int {var x := 5}  function x() = "totor" in end
function x(x : int, x : int) : int = let var x := 5 in end function x(x : int) = int {x = nil} 
class x extends int {var x := 5} 
function x(x : int, x : int) : int = for x := x() to x() do x.x() class x extends int {var x := 5}  var x := 5
let function x(x : int) = let  in 5 end in x((5 ; 5), x[nil].x()) ; x[5].x(x.x(), let  in 5 end) end
class x extends int {var x := 5}  class x {var x := 5}  var x := 5 var x := 5
new int
type x = class {var x := 5}
int [x["totor"][new int].x] of x.x.x.x(for x := -break to new int do new int, for x := (5) to while "totor" do break do x(5, ()))/int [for x := if "totor" then "totor" to if "totor" then 5 do x.x(5, "totor")] of int {x = x := ()} 
type x = int function x(x : int) : int = if 5 then nil
function x(x : int, x : int) = int {x = int {x = break} }  class x {var x := 5}  class x extends int {}  import "empty.tih"
(x.x.x.x())
class x {var x := 5} 
function x(x : int) = if x() then let  in 5 end
int {x = ((5) ; "totor")+x.x[int {x = nil} ] := -for x := () to break do ()} 
class x {var x := 5}  class x extends int {var x := 5}  var x := 5
var x : int := x(5, "totor")
x.x.x[int {} ][x[break][break|nil].x()].x()
(x[5].x.x())
let type x = array of int function x() : int = 5 import "empty.tih" in int {x = for x := let  in end to let  in 5 end do (5)}  ; -x := () end
type x = int
x[break][x(break, 5)][x[()].x(x(), new int)][let import "empty.tih" var x := 5 in end]
class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) : int = x((), 5)
var x := int {x = (), x = "totor"}  type x = array of int
let function x(x : int) = int {}  in end
let function x(x : int) = (5) in end
var x := x
class x {var x := 5 var x := 5}  class x {var x := 5}  function x() = "totor"
let class x {var x := 5}  in end
function x(x : int, x : int) = let var x := 5 in end
let class x {var x := 5}  in int {x = for x := -"totor" to if () then nil else break do x := 5}  end
int {x = if -x() then int [x.x := x(5, "totor")] of x["totor"] else int [int {x = for x := 5 to 5 do "totor"} ] of int {x = x(5, "totor")} } 
class x {var x := 5 var x := 5} 
(while x(5*"totor", int {} ) do x.x.x(int [nil] of break, let  in end) ; for x := let  in end to if "totor" then () do new int)
var x : int := "totor"/() class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
x.x[while break do ()][int {x = if "totor" then 5 else break, x = x.x()} ].x()*int [if let var x := 5 in end then x[nil] := while () do break else x()] of while x[5].x(int {x = break, x = 5} , x()) do let var x := 5 in end
int [if x(while int {}  do int [()] of break, new int) then let var x := 5 in end else x.x[x := 5].x(-new int, while x := break do (5))] of let type x = int in end
class x extends int {var x := 5}  class x extends int {var x := 5}  function x() = () var x := 5 var x := 5
function x(x : int) : int = int {x = x()}  class x {var x := 5} 
function x(x : int, x : int) = let var x := 5 in nil end var x : int := break
var x := x
int {x = if new int then new int} *int {} 
new int
int {x = new int, x = x.x[break|nil]-if x() then x[()] := x} 
let function x(x : int) : int = new int in if x.x.x() then x(x, let  in end) end
while let type x = int in end do while (x(break, ()) ; nil ; 5) do x.x.x.x(if int [5] of break then int {x = "totor", x = break}  else x := 5, if for x := break to break do "totor" then x(5, break))
if x.x.x.x.x(int [x.x((), nil)|int {x = nil} ] of if "totor" then break else break|int {} , int {x = x[break]} ) then x[()].x[int {x = for x := break to "totor" do 5} ]
class x extends int {var x := 5}  function x(x : int) = break/5
class x extends int {var x := 5 var x := 5} 
class x {var x := 5} 
x.x[()*"totor"] := if x.x() then if 5 then ()+int {x = int {x = while break do "totor", x = let  in end} , x = (5 ; 5)} /while int {x = x()}  do if x(x.x("totor", 5), if 5 then ()) then x["totor"]
x["totor"][x()][int {} ][int {x = let var x := 5 in () ; 5 end, x = x["totor"].x()} ].x(int {} , let function x() : int = break var x := 5 var x := 5 in end)
type x = int class x extends int {var x := 5}  class x {}  import "empty.tih"
x(x[nil].x.x.x(int [int {x = x()} ] of x(let  in end, let  in 5 end), x[5].x.x(let var x := 5 in end, int {x = x := break, x = x.x(break, break)} )), x())
for x := x() to new int do while let import "empty.tih" var x := 5 in end do x.x[int {x = nil} ].x()
x[break].x.x.x := x["totor"][int {} ][x(x(), int {x = (), x = ()} )].x(x.x.x.x(), let import "empty.tih" var x := 5 in for x := 5 to nil do break end)
if if x("totor", nil)&x-x[nil].x() then int {} +let  in 5 end-(5) else -int {x = x()}  then x[nil][if break then "totor" else nil][if break-"totor" then x := "totor" else let  in end].x() else for x := x(int [x()] of 5-break, x(x.x(), x)) to x[5][x.x((), "totor")] := x(int ["totor"] of 5, x.x()) do let import "empty.tih" var x := 5 in end
function x(x : int) = (5)*if break then nil else "totor" class x extends int {var x := 5} 
x["totor"][x.x()].x.x.x(x(), x[5][let  in 5 end][x.x].x())
var x : int := let  in end class x {var x := 5} 
int {x = x()/x[break].x, x = let function x() = nil in x[break].x(if () then "totor", int {x = nil, x = "totor"} ) end} 
x.x.x[x[()].x(break+"totor", let  in end)].x := (-x.x() ; x := 5)
class x {var x := 5} 
type x = int class x {var x := 5}  var x := 5
class x {var x := 5} 
x.x[(5)][x.x := x("totor", nil)].x.x()
class x extends int {var x := 5 var x := 5}  var x : int := 5 function x() = "totor"
class x extends int {var x := 5}  class x extends int {var x := 5} 
type x = {x : int} class x {var x := 5}  function x() = "totor"
-if int {x = int [x((), break)] of let  in 5 end}  then new int
(x(int {x = x.x(nil, 5), x = -break} , let var x := 5 in () end))
for x := let function x() = () var x := 5 in end to int [new int] of x.x[new int] := -x("totor", 5) do for x := new int to int [int {x = if nil then break} ] of if new int then new int else int [break] of nil do x(x.x.x(if nil then break, let  in 5 end), for x := int {x = nil, x = break}  to x.x(5, nil) do -nil)
x[break].x.x.x := (x.x.x())
class x {var x := 5 var x := 5}  function x(x : int) = new int
function x(x : int) = x.x function x(x : int) : int = new int var x := 5 import "empty.tih" var x := 5
var x : int := x type x = class {} class x {}  var x := 5 var x := 5
new int
type x = int
type x = array of int
let class x {var x := 5}  class x {}  import "empty.tih" var x := 5 in end
class x {var x := 5}  class x extends int {var x := 5}  class x extends int {}  var x := 5 var x := 5
let function x() = "totor" in if int {}  then break-() ; let  in end ; () end|while x.x.x.x(-x, for x := int {}  to x.x() do let  in end) do int [if new int then break-() else new int] of int [x := "totor"] of new int
x.x.x[x[()]][new int].x()
x(if int {x = new int, x = x.x}  then int {x = x.x()&x} , -x.x.x.x(int [nil/"totor"] of x := nil, x()))
let function x(x : int) : int = new int in end
function x(x : int) = x.x.x(x.x(), ()|5)
type x = class {var x := 5} function x(x : int) : int = (5)
function x(x : int) = (5 ; 5)
var x := x("totor", nil) class x extends int {var x := 5}  function x() = nil var x := 5
x.x[x.x("totor", break)].x[int {x = if int {x = ()}  then -()} ].x(int {x = x.x.x.x(if while "totor" do nil then if nil then "totor" else x, let var x := 5 in () ; 5 end)} , x())
int {} 
type x = array of int var x : int := "totor" type x = int import "empty.tih" var x := 5
var x := x := () class x {var x := 5}  function x() = ()
class x {var x := 5}  function x(x : int) : int = (5)
type x = int
if if if new int then for x := for x := 5 to 5 do 5 to ()-() do int {x = break, x = ()}  then int {x = int {x = let  in 5 end} , x = x(x.x((), "totor"), let  in 5 end)}  then int [let var x := 5 in int [5] of () end] of int {}  else if for x := while for x := "totor" to break do break do x(5, 5) to int {}  do int {}  then x[()][5&break]
type x = array of int var x : int := "totor"
let function x(x : int) = x var x := 5 in -for x := let  in end to x((), break) do x.x(break, "totor") ; x(while 5 do nil, for x := break to break do "totor") end
x()
function x(x : int) = new int
x.x[int {x = "totor"} ].x.x.x()
var x : int := if break then "totor" type x = class extends int{}
class x extends int {var x := 5 var x := 5} 
function x(x : int) : int = x[nil].x(-nil, int [5] of ()) class x extends int {var x := 5} 
function x(x : int) : int = for x := -5 to for x := "totor" to "totor" do break do (5)
new int
type x = class {var x := 5} function x(x : int) = new int
x(-if while while break do () do if () then "totor" then let var x := 5 in end, -int {} )
new int
x[()][x.x(break, 5)].x.x
int {x = int [if x.x then int {x = int [5] of nil, x = x} ] of x[()][int {x = break} ].x()} 
type x = class extends int{var x := 5}
function x(x : int, x : int) : int = x[()].x() function x(x : int) = break|"totor"
let function x(x : int) : int = while break do () in end
function x(x : int, x : int) = new int class x extends int {var x := 5}  function x() = 5 var x := 5 var x := 5
function x(x : int) = x()
x(if if int {x = int [nil] of 5}  then int [while nil do nil] of while () do break then let import "empty.tih" in end, let class x {}  in end)
class x {var x := 5}  var x : int := ()
function x(x : int, x : int) = int [int {x = "totor"} ] of new int
-for x := x[nil][int {} ].x() to x.x[if nil then nil] := new int do int {x = int {x = int {x = "totor", x = ()} , x = if nil then nil} , x = --break} 
class x {var x := 5}  function x(x : int) : int = x.x()
class x extends int {var x := 5 var x := 5}  function x(x : int) = (5)
class x extends int {var x := 5} 
if while let var x := 5 in if "totor" then 5 else "totor" end do int [("totor")] of x() then int [x.x[x.x(nil, "totor")].x(x(), for x := x.x() to for x := () to "totor" do nil do int {x = "totor", x = "totor"} )] of if x := nil+if "totor" then nil else break then let var x := 5 in 5 ; 5 end
type x = int
function x(x : int) : int = x(if nil then "totor" else (), x()) function x(x : int) = int [()] of break
function x(x : int, x : int) : int = if x.x() then x() else while () do 5
new int
class x extends int {var x := 5} 
function x(x : int) : int = if if 5 then 5 then int {x = 5} 
type x = array of int class x {var x := 5} 
let function x(x : int) = new int type x = int import "empty.tih" var x := 5 in end
x[break].x[int {x = if break then () else 5} ][int {x = int {x = if 5 then "totor" else break, x = x := ()} } ] := (x.x ; int {}  ; () ; 5)
function x(x : int) = for x := let  in 5 end to if "totor" then () else break do if 5 then () else 5
function x(x : int) : int = x.x := -()
class x extends int {var x := 5 var x := 5}  function x(x : int) = x.x(5, "totor")
x()
int {x = int [x.x.x := x(x := break, x := 5)] of x["totor"].x := int {} , x = int {x = x.x.x} } 
int {x = int [int [let var x := 5 in () ; 5 end] of -if "totor" then 5 else 5] of x((() ; 5), let var x := 5 in end), x = x()} 
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5} 
type x = {x : int}
function x(x : int, x : int) = if x() then if "totor" then "totor" else () else -nil function x(x : int) : int = int {} 
type x = {x : int} class x {var x := 5} 
if x[nil][-"totor"].x then new int
x()
x.x[(5)][x()][x[5].x] := x.x.x.x := int [new int-x] of x.x := for x := nil to () do nil
function x(x : int, x : int) : int = x.x.x()
var x : int := int {x = (), x = ()} 
class x {var x := 5}  type x = class extends int{}
int [x()] of while x.x[let  in end].x(x.x := x.x(), let var x := 5 in end) do int {x = int {x = if 5 then 5 else break, x = int {x = (), x = "totor"} } , x = x[5].x()} 
function x(x : int, x : int) : int = int {x = -nil}  function x(x : int) : int = while "totor" do break
x(x[()][if break then break else 5].x := x.x[new int].x(), int {x = let var x := 5 var x := 5 in int {x = break}  ; break end} )
x(new int, let class x extends int {}  var x := 5 var x := 5 in int [for x := () to () do break] of x := "totor" ; x(nil, break) end)
class x {var x := 5}  class x {var x := 5} 
function x(x : int) = x.x class x extends int {var x := 5} 
x.x[let  in 5 end][x := nil-new int].x := let type x = int in end
x.x.x.x.x.x(let function x() = break var x := 5 var x := 5 in if int [nil] of break then 5&break else x.x() ; int {x = (), x = nil}  ; break end, x[5][(5)].x := x[()][int [break] of nil].x())
while x() do if let import "empty.tih" var x := 5 in end then let import "empty.tih" var x := 5 in -5 ; "totor" end
int {} 
new int
for x := int {}  to if -let var x := 5 in "totor" ; 5 end then x[()].x.x() else (while 5 do () ; break) do let class x extends int {}  in end
class x {var x := 5 var x := 5} 
(x.x[if "totor" then 5 else ()])
if x() then if new int then for x := int {}  to while nil-nil do x() do for x := (5) to while "totor" do "totor" do int {}  else x()
let function x(x : int) = x := 5 class x extends int {}  var x := 5 var x := 5 in end
let type x = {} function x() : int = 5 import "empty.tih" in end
-let class x extends int {}  import "empty.tih" in end
class x extends int {var x := 5}  class x {var x := 5} 
x()
let function x(x : int) : int = x var x := 5 import "empty.tih" in end
let var x := nil var x := 5 var x := 5 var x := 5 in end
while while -int [int [break] of break] of let  in 5 end do int [while break|break do let  in 5 end] of x(-"totor", x.x(nil, "totor")) do let function x() : int = () import "empty.tih" in for x := let  in 5 end to -nil do new int ; x(nil, nil) ; "totor" ; 5 end
class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
int {x = int {} } 
(-(5))*new int
x()
class x {var x := 5 var x := 5} 
x(x(x.x.x.x(), (break)&x[5] := x), if if while int {x = nil}  do -() then if if break then break else break then x.x() then let import "empty.tih" var x := 5 in end)
(let var x := 5 in () end*x[()])
class x extends int {var x := 5} 
if -if x() then x() else int {x = int [break] of break, x = x()}  then x.x.x[x(x, for x := break to break do "totor")].x()
int {x = let var x := 5 in nil end} &let import "empty.tih" in if break then nil end*let class x {}  var x := 5 var x := 5 in end
int [int {x = let import "empty.tih" in end, x = if while x do for x := 5 to nil do nil then x.x.x() else x()} ] of x.x[let  in end].x := int {x = if (5) then int {x = 5, x = 5} } 
function x(x : int, x : int) : int = x(new int, x.x()) class x {var x := 5}  class x extends int {}  var x := 5
x()
let var x := "totor" in int [x.x()*x()] of int [x := nil] of new int ; (break ; 5) ; while break do () ; "totor" ; 5 end
function x(x : int) = x[nil].x(x(), let  in end) class x extends int {var x := 5}  var x := 5 import "empty.tih" var x := 5
function x(x : int, x : int) : int = int {x = int {} }  function x(x : int) = int {} 
for x := if int {x = -let  in end}  then int [while x.x() do -break] of let var x := 5 in end to -x(x, for x := 5 to break do 5)/-x[5].x() do x.x.x.x.x(let var x := 5 in end/x[()] := x, x())
x["totor"][let  in end][x.x.x(let  in 5 end, x := nil)][(x(5, break) ; break ; 5)].x(int {x = int {x = let var x := 5 in end} , x = int {} } , (int {x = int {} , x = x := 5} ))
let function x(x : int) = if 5 then "totor" in x.x[int {x = (), x = "totor"} ].x(x[nil].x(nil*break, let  in end), let var x := 5 in end) ; -if "totor" then break else nil ; while break do 5 ; "totor" end
type x = class {var x := 5}
while let type x = int import "empty.tih" var x := 5 in x[5] ; let  in end ; nil end do new int
if x.x[x.x()].x := x[break].x := x[()].x() then x(for x := x.x.x(x((), nil), let  in end) to x[()] := int {x = ()}  do if nil then ()*x.x(nil, 5), let import "empty.tih" var x := 5 in end) else (x[nil] := while nil do nil)
function x(x : int) : int = x.x.x(new int, let  in 5 end) function x(x : int) : int = new int
type x = class {var x := 5}
class x extends int {var x := 5 var x := 5} 
class x {var x := 5} 
x[nil][x][int {x = x := break, x = for x := "totor" to 5 do 5} ].x.x()
x(let class x {}  var x := 5 in end, x(int {x = x(), x = (break)} , x[nil].x.x(if 5*break then if 5 then (), while int {x = nil, x = ()}  do int {x = 5, x = "totor"} )))
type x = {x : int} class x extends int {var x := 5}  type x = int
class x extends int {var x := 5 var x := 5}  function x(x : int) = x.x("totor", "totor") type x = int
function x(x : int, x : int) = int [x()] of x.x() class x {var x := 5}  function x() : int = () import "empty.tih"
function x(x : int, x : int) = x[nil].x(x(), x())
var x : int := for x := "totor" to 5 do "totor"
x[break].x[(break ; 5)][-let var x := 5 in end].x(while if if x then int {x = 5}  else while break do 5 then x() do x["totor"][for x := nil to () do ()], x[break][x.x(break, break)][let var x := 5 in () end].x())
let class x {var x := 5}  function x() : int = nil import "empty.tih" var x := 5 in end
x()
x(while int [x(x, new int)] of while x.x((), break) do x.x() do x.x.x.x(let var x := 5 in end, -new int), -x.x[int {x = nil} ] := let var x := 5 in end)
int {x = x.x.x.x.x(if int {x = nil, x = nil}  then x.x(nil, break) else for x := nil to nil do nil/int [while "totor" do nil] of x.x(break, "totor"), int {x = x.x.x(), x = x()} ), x = (x(x := "totor", x) ; if "totor" then break else "totor" ; "totor")} 
x(if x["totor"][for x := () to () do break] then x.x[-"totor"], x.x[x := ()].x.x(new int, if while int {x = nil, x = nil}  do x.x() then int {x = new int, x = new int} ))
x[break].x[if x := nil then let  in 5 end][new int].x()
class x {var x := 5} 
new int
function x(x : int, x : int) : int = int [int {x = "totor"} ] of break|()
class x extends int {var x := 5}  function x(x : int) = x
function x(x : int, x : int) : int = int {x = x := nil} 
var x := (5)
-int {x = int [x.x(break, ())] of (5), x = if x() then new int else new int} -let import "empty.tih" var x := 5 in end
while if let var x := 5 in new int ; 5 ; 5 end then -x[nil] := 5|nil do (int [x.x()] of if () then () ; x() ; ())
-x.x.x.x.x()
function x(x : int) = let var x := 5 in end
int {x = x.x[let  in 5 end][int [int {x = "totor"} ] of x], x = int {} } 
x()
x.x[let  in 5 end][x[break].x()].x.x()
while int {x = (int {x = "totor"} )}  do x[nil].x&x[()][for x := "totor" to () do 5].x(x.x.x(x.x((), break), x()), x["totor"].x())
class x extends int {var x := 5 var x := 5}  type x = {} function x() : int = break
while (while if break then break else () do int {x = nil, x = ()}  ; while nil do () ; nil ; 5) do int {x = (int {} )} 
x["totor"].x[x.x.x()].x
var x := x.x(nil, "totor")
int {x = x.x.x.x := -int {x = x} } 
function x(x : int, x : int) = x.x := for x := 5 to break do break var x := break
class x {var x := 5}  function x(x : int) : int = x := nil class x extends int {}  import "empty.tih"
type x = int class x extends int {var x := 5} 
class x {var x := 5}  function x(x : int) = (5) function x() = "totor"
var x := x := "totor" var x : int := "totor"
function x(x : int, x : int) = new int
type x = {x : int} var x := () class x {}  var x := 5
let class x {var x := 5}  class x extends int {}  in while x[()].x() do if let  in 5 end then if 5 then "totor" else new int end
function x(x : int) : int = x.x := break*"totor"
int [int [while let var x := 5 in break end do x[nil]] of x[break][nil*break].x()] of x.x[int [break] of "totor"].x
function x(x : int) : int = int [while () do ()] of while 5 do break function x(x : int) = for x := () to () do break class x extends int {} 
var x := (5) var x : int := () class x extends int {} 
function x(x : int) = for x := (5) to -() do x.x(break, 5)
var x := let  in end
function x(x : int, x : int) : int = int [if nil then 5] of if nil then () class x extends int {var x := 5} 
int {} 
while while x["totor"].x do int {x = if let  in end then x else x.x(), x = if x := nil then if break then 5 else nil else int {} }  do -(x := "totor" ; ())
var x := x.x((), ()) class x extends int {var x := 5}  function x() : int = nil
class x {var x := 5}  class x extends int {var x := 5}  type x = int import "empty.tih"
for x := x.x[x(nil, 5)].x := x(int {} , int {x = new int, x = new int} ) to x((let  in end), if let var x := 5 in end then x[()].x() else -while "totor" do "totor") do if (x.x(break, "totor")) then int {x = x.x.x(int {} , -())}  else -int [int {} ] of -5
class x extends int {var x := 5}  type x = class {}
function x(x : int) : int = x.x := x()
new int
let function x(x : int) : int = let  in 5 end in new int ; int {x = new int}  end
var x := int {x = nil, x = 5}  class x {var x := 5} 
function x(x : int) : int = int [x("totor", ())] of x(5, break) class x {var x := 5}  class x extends int {} 
function x(x : int, x : int) = int [-break] of break*5
type x = {x : int}
let class x extends int {var x := 5}  in x.x.x.x(x(int {x = "totor"} , x("totor", ())), if int [()] of 5 then while nil do 5) end
function x(x : int, x : int) : int = x.x.x(for x := "totor" to nil do 5, x.x((), break)) class x extends int {var x := 5} 
x((if new int then let  in 5 end else let  in 5 end), let class x extends int {}  var x := 5 var x := 5 in end)
function x(x : int) = x["totor"] := new int
x((int {x = int {} } ), x[break].x[for x := int [break] of "totor" to int {x = 5}  do let  in end])
function x(x : int, x : int) = int {x = x()}  type x = array of int
new int
type x = int
type x = array of int class x extends int {var x := 5} 
type x = int class x {var x := 5} 
x()
x[()][let  in end].x.x := int [x(int {x = new int, x = let  in 5 end} , x[nil].x())] of x[5][if "totor" then 5 else "totor"]
function x(x : int) : int = x[5] class x extends int {var x := 5} 
function x(x : int, x : int) = int {x = x(), x = x(break, break)} 
x.x[int {x = (), x = "totor"} ][int {x = int {} , x = int {x = ()} } ][x["totor"][int {x = 5, x = ()} ] := x(for x := "totor" to () do break, new int)].x(int {} , int {x = x(x.x := x.x(), (break ; 5))} )
x[break][while break do ()][x[nil].x()][int {x = new int, x = x()} ].x(x(x(new int, (break ; 5)), int {} ), x.x[int [break] of ()]/for x := for x := if 5 then "totor" else () to x := break do int {x = ()}  to x.x do x.x.x(while () do "totor", x := nil))
class x extends int {var x := 5}  class x extends int {var x := 5} 
type x = array of int function x(x : int) = if break then () else break
new int
int [let class x {}  in end] of if let var x := 5 in -break end then int {} 
x.x.x.x[while x.x.x(int {x = "totor"} , if 5 then 5 else break) do while x(break, nil) do -5].x(x["totor"].x&(())+int {x = int {x = "totor", x = "totor"} } , new int)
function x(x : int) = int [int {x = (), x = break} ] of let  in 5 end
let class x {var x := 5}  in if x() then x.x.x() else while x.x() do new int end
class x extends int {var x := 5} 
type x = int
for x := -int [for x := if break then "totor" else break to x() do let  in 5 end] of while if 5 then nil do x := nil to while (for x := 5 to "totor" do "totor" ; "totor" ; 5) do x() do x[()].x[int {x = nil, x = break} -let  in end]
class x {var x := 5}  type x = class {} function x() : int = break
int {x = let class x extends int {}  import "empty.tih" in end} 
function x(x : int) : int = for x := if 5 then nil else () to (5) do let  in 5 end
type x = class extends int{var x := 5}
type x = {x : int}
(let var x := 5 in end)
x[break][-nil][int {x = x()} ][int {x = let var x := 5 in 5 end} ].x()
-int {x = x()/x, x = let var x := 5 in break ; 5 end} &for x := x.x[let  in end].x() to x["totor"].x do x(int {x = int [()] of (), x = x(break, break)} , for x := x := nil to int {x = nil}  do -break)
x["totor"].x[let var x := 5 in end][let import "empty.tih" in end]
function x(x : int, x : int) = x.x.x()
let type x = class extends int{} class x extends int {}  in x.x[x.x()].x(x.x, int {} ) ; x.x := (5) ; x.x() ; "totor" end
type x = class extends int{var x := 5}
function x(x : int) = ("totor")
class x extends int {var x := 5 var x := 5}  var x := break
function x(x : int, x : int) : int = x.x.x(int {} , int [nil] of 5)
while x["totor"][x.x(5, nil)].x do x.x.x[if x then (5) else -"totor"].x(x.x[(5)].x(), (x((), 5)))
x.x.x[-int {x = "totor"} ].x
function x(x : int) : int = let var x := 5 in end
class x extends int {var x := 5} 
class x extends int {var x := 5} 
class x extends int {var x := 5} 
x["totor"].x[int {} ].x := int {x = for x := if nil then nil else nil&x to x() do x.x.x()} 
class x {var x := 5}  var x : int := nil function x() = "totor"
new int
class x extends int {var x := 5} 
int {x = int {x = int {x = if x.x() then int {} , x = for x := while break do nil to int {x = "totor", x = ()}  do int [nil] of ()} , x = let var x := 5 in new int end} , x = x[break][(5)].x := x.x[x.x(5, nil)].x()} 
-x[break][x := 5].x.x()
while for x := (()) to if (5) then x.x(nil, nil) do x(nil/break, x(break, nil)) do int [(nil)] of x[5] := new int/x(x[5].x(x.x(), int {} ), (break))&x(x.x := if 5 then (), while for x := 5 to 5 do break do x.x())
int {} 
if int {x = int [x.x.x()] of x[break].x(int {x = 5} , int {x = ()} ), x = let import "empty.tih" var x := 5 in new int ; 5 end}  then x.x[int {x = nil, x = ()} ][let var x := 5 in () ; 5 end].x()
function x(x : int, x : int) = x.x := if 5 then "totor" else 5 type x = class extends int{} class x extends int {} 
class x extends int {var x := 5 var x := 5}  type x = {}
function x(x : int, x : int) : int = x.x.x() var x : int := nil
int {x = for x := if for x := let  in end to -"totor" do int {}  then int [int [()] of nil] of let  in end else for x := -nil to int {x = 5, x = break}  do while break do 5 to int {x = for x := x := "totor" to for x := 5 to 5 do break do int {x = 5} , x = int {} }  do (int [()] of () ; 5 ; 5)} 
type x = int
let function x(x : int) : int = new int type x = int in end
function x(x : int) : int = x() function x(x : int) = while 5 do 5 class x extends int {} 
var x : int := int {x = (), x = "totor"}  type x = class {} type x = int
new int
int {} &let function x() = nil import "empty.tih" in if x then nil/"totor" else let  in 5 end end
type x = array of int
function x(x : int, x : int) : int = new int class x {var x := 5}  var x := 5
var x := x.x(break, 5)
x(int [x[break][int {x = nil, x = ()} ].x()] of for x := int {x = 5} +x.x() to int {x = int {x = 5, x = "totor"} , x = x := break}  do int {x = int {x = ()} , x = if () then 5} , x.x[if nil then break else ()].x := int {x = int {x = x.x()} , x = -x} )
class x {var x := 5 var x := 5} 
(if x.x.x() then (5))
function x(x : int) : int = x(int [5] of (), x(5, 5))
int [int {x = let var x := 5 in int {x = break, x = nil}  end} ] of x[()].x.x
class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5} 
int [x(int [int {x = int ["totor"] of break, x = while 5 do break} ] of new int, x())] of int {x = x.x.x.x(), x = let import "empty.tih" var x := 5 in x.x(5, break) end} 
function x(x : int, x : int) = int {x = nil, x = "totor"} &let  in end
x.x[if () then 5][if x() then int [break] of nil].x := while new int do int {x = int [while break do ()] of int [5] of 5} 
class x {var x := 5 var x := 5} 
x[break][int {x = break, x = break} ][int {x = if break then break else break, x = int {} } ].x := new int
var x := x type x = {} var x := 5 var x := 5
if x() then x() else int {x = x(int {x = int {x = nil, x = break} , x = x.x(nil, "totor")} , while -5 do let  in end), x = x()|int {} } 
(x() ; int {x = 5, x = ()} |-"totor")
var x : int := x
class x {var x := 5}  function x(x : int) : int = int {}  class x extends int {}  import "empty.tih"
var x : int := int {x = ()}  type x = {} function x() : int = 5
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() : int = "totor"
class x extends int {var x := 5} 
x.x.x[int {x = int {x = nil, x = ()} } ][x[nil][x.x("totor", nil)].x()] := while new int do x.x.x.x(("totor" ; 5), int {x = while break do nil, x = x(break, ())} )
function x(x : int, x : int) : int = let var x := 5 in end
function x(x : int) = let var x := 5 in end
x()&int {x = x.x.x.x(if let  in 5 end then int {x = nil, x = nil} , x())} 
var x : int := new int
int {x = x.x.x := x[()] := int [nil] of "totor"/-int {} , x = -if break then "totor"*x.x()/x[break].x.x()} 
function x(x : int) : int = while x.x((), ()) do if "totor" then () else break
type x = {x : int} class x {var x := 5}  function x() : int = 5 import "empty.tih" var x := 5
while for x := (x() ; ()) to new int do x(()&(), int {x = "totor"} )+x.x do int [if if x := "totor" then "totor"+"totor" then while new int do x := "totor" else x[5].x(for x := () to "totor" do 5, int {x = break, x = break} )] of int {x = x.x} 
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  class x {}  import "empty.tih" var x := 5
type x = int
x()
class x extends int {var x := 5 var x := 5}  type x = array of int
function x(x : int) : int = int [int {x = ()} ] of -nil type x = array of int
var x := int {x = break, x = nil} 
var x : int := "totor"&break type x = class extends int{}
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() : int = 5
function x(x : int, x : int) = int {x = new int, x = if 5 then 5}  var x := 5
x[nil][if () then "totor"].x.x.x(while int [x.x(5, 5)*break-5] of x(while nil do break, x(break, ())) do int {x = int {x = if "totor" then nil else break, x = x} } , x.x[int [()] of "totor"].x.x())
class x extends int {var x := 5} 
var x : int := int {} 
x.x.x.x.x
int [new int] of int {x = -x.x.x()} 
if -x[break] := -nil then if x.x then for x := () to () do "totor"*break*"totor" else -x("totor", ())-(if new int then int {x = (), x = nil} )
int {x = if if if int {x = nil}  then for x := break to "totor" do nil then for x := "totor"&nil to new int do x := 5 else let var x := 5 in nil end then if -for x := break to 5 do nil then for x := while nil do nil to x := "totor" do new int, x = if x.x.x.x((() ; 5), x.x.x()) then int {x = x(), x = for x := int {}  to let  in end do x(break, "totor")} } 
-while ((5) ; "totor") do new int
let function x(x : int) = let  in 5 end function x() : int = "totor" in end
function x(x : int, x : int) : int = if int {x = (), x = break}  then int [break] of "totor" else x.x() class x {var x := 5} 
-while int {x = --()}  do x()
int [(new int ; int {x = break, x = nil}  ; nil ; 5)] of x[nil].x[while x.x() do "totor"-"totor"] := x.x.x.x()
x.x.x[x["totor"] := int {x = nil, x = "totor"} ].x := int {} 
function x(x : int) = x.x := new int
((let  in end))
class x {var x := 5}  function x(x : int) : int = "totor"-nil
x()
class x extends int {var x := 5} 
function x(x : int) = int {x = new int, x = int {} } 
function x(x : int) = new int
for x := x() to let type x = int import "empty.tih" in end do int [int {} ] of if (5) then x(break, "totor") else for x := nil to break do nil-x.x.x
let class x extends int {var x := 5}  in end
class x {var x := 5} 
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5}  var x := ()
var x : int := if 5 then 5
function x(x : int) : int = x() var x : int := break
for x := if x.x[int [nil] of "totor"].x() then x[break][()-5] to x() do -int {} 
function x(x : int) : int = int {x = let  in end, x = x.x("totor", "totor")}  class x {var x := 5} 
(x[break] := int {}  ; x.x(break, 5) ; ())-int {x = x.x[int {x = ()} ].x(let var x := 5 in nil end, int {x = x((), "totor")} )} 
int {x = x["totor"][int {} ].x := let import "empty.tih" var x := 5 in end, x = for x := if while let  in end do break/nil then int {}  else if for x := "totor" to "totor" do break then x.x("totor", ()) to x.x[if () then () else 5].x(if x(5, nil) then x.x("totor", ()), x[nil] := -break) do if while int {}  do new int then for x := -nil to if () then nil do int {} } 
function x(x : int, x : int) : int = int {x = while "totor" do nil, x = int {x = nil, x = ()} }  type x = class {}
if let function x() : int = "totor" var x := 5 in end then let class x {}  var x := 5 var x := 5 in end else if -x() then x.x[if 5 then () else ()] := if if "totor" then break else () then x.x("totor", "totor")
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
function x(x : int, x : int) = int {x = new int} 
x.x[x.x()][new int].x := int {x = (break)*x.x.x()} 
new int
-int {x = int {} , x = (nil ; 5)|int {x = x()} } 
function x(x : int) : int = if let  in 5 end then x.x((), nil) else x.x()
type x = class extends int{var x := 5} type x = {}
x.x[let  in 5 end].x[for x := x.x to (5)-(5) do x()].x(let class x {}  in end, int {x = x(new int, x(nil, ())), x = (5)} |new int)
class x {var x := 5}  function x(x : int) = if nil then break else () function x() = 5
x.x[int {} ][x.x := int {} ][if let var x := 5 in end then int {x = let  in 5 end} ] := x.x[int {x = 5} ][new int].x(int {x = while -() do int {x = 5, x = nil} , x = x()} , int {x = x(5&(), x)} )
for x := while for x := x[5] := -5 to x() do new int do x.x.x.x(x.x.x(), let var x := 5 in break ; 5 end) to (int {x = for x := () to nil do "totor"}  ; int {x = nil, x = nil} ) do x.x.x.x()|x(for x := x() to x() do int [()] of 5, for x := x to -5 do let  in end)
(x[break][while () do 5].x((() ; 5), if let  in end then int [5] of 5 else if break then ()))
function x(x : int, x : int) : int = int {x = if break then 5 else break} 
function x(x : int, x : int) = x() function x(x : int) = if 5 then "totor" class x {}  var x := 5
class x {var x := 5 var x := 5}  var x := 5 function x() : int = nil
int {x = x.x[int {x = 5} ], x = x[5][if 5 then () else break]} *if for x := let var x := 5 in end to x.x.x(if 5 then "totor", x) do while if 5 then 5 do x then x.x.x.x(x(if break then break, (5)), int {} ) else if -let  in end then break*()|x.x(break, break) else int [if nil then nil] of x(break, "totor")
type x = class extends int{var x := 5} function x(x : int) = x := ()
int {x = (new int)} +(int {x = "totor", x = "totor"}  ; 5)*while while x do int {x = break}  do if while "totor" do "totor" then x(break, ())
x.x[let  in 5 end].x[(if () then nil else 5)].x(if int [x()|x(nil, "totor")] of int {x = int {} , x = if "totor" then break}  then x["totor"].x, x.x[x(break, break)].x.x(-x(new int, let  in 5 end), (while () do 5)))
function x(x : int, x : int) = let var x := 5 in nil end
int {x = if new int then -x(if () then 5 else break, ()&break)} 
class x {var x := 5}  class x extends int {var x := 5}  class x extends int {} 
x["totor"][x := break].x[x[nil][let  in 5 end]]
type x = array of int
type x = class {var x := 5} type x = {} class x extends int {} 
int {x = x.x[int {} ].x.x(), x = let function x() : int = () in end} 
x[()].x.x[x.x.x := -()+if () then nil] := x()
x(new int, x[5][int {x = ()} ][int {x = let  in 5 end} ])
function x(x : int) = x()
type x = array of int
new int
int [new int&while x.x(nil, "totor")-x do x.x.x()] of x[nil].x[x.x].x()
int {x = x(let import "empty.tih" var x := 5 in x.x(5, nil) end, for x := int {x = new int, x = x := nil}  to if int {x = nil, x = break}  then x else for x := nil to nil do nil do for x := for x := break to break do nil to for x := () to nil do nil do if "totor" then break), x = x.x[new int].x := int [new int] of int [let  in 5 end] of int {x = ()} } 
function x(x : int, x : int) : int = let var x := 5 in "totor" end function x(x : int) : int = while 5 do 5
type x = class {var x := 5}
var x := for x := nil to break do break class x {var x := 5}  class x {}  var x := 5 var x := 5
if let import "empty.tih" in end+int {}  then int {x = x[break][x()] := (nil), x = int {x = int [break*()] of x, x = while "totor" do "totor"/int {} } }  else (int {x = let  in end}  ; x())
function x(x : int, x : int) : int = if for x := "totor" to "totor" do break then for x := 5 to break do break class x {var x := 5} 
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5}  class x {var x := 5} 
type x = {x : int}
x[()][x := break].x.x := int [int {x = int {x = x} , x = let var x := 5 in 5 ; 5 end} ] of int [for x := while break do break to x(nil, 5) do x := "totor"] of int {} 
for x := (if int {x = 5}  then x() ; "totor"|() ; 5 ; 5) to x[5].x[for x := let  in 5 end to x.x((), break) do x("totor", ())].x(while for x := (5) to new int do int {x = 5}  do ("totor" ; 5), x.x[let  in 5 end] := x.x.x()) do int {x = x(int {} , let var x := 5 in nil ; 5 end)} 
var x := int {}  function x(x : int) : int = for x := nil to () do nil
x.x.x[for x := int ["totor"] of "totor" to x() do for x := "totor" to break do break][x.x.x := x[break]].x((x.x.x() ; break+() ; ()), int {x = while int {}  do if (5) then if nil then break else 5 else nil*break, x = x.x.x.x(-if break then nil else nil, x[break].x(for x := () to break do break, 5/5))} )
class x extends int {var x := 5}  function x(x : int) = x := break type x = int import "empty.tih" var x := 5
let class x extends int {var x := 5}  var x := 5 in let var x := 5 in break ; 5 end+x.x(5, "totor")&let  in end end
class x extends int {var x := 5 var x := 5} 
var x := x.x((), break)
var x : int := x := "totor" type x = class {} function x() : int = "totor" import "empty.tih"
class x {var x := 5}  var x : int := nil
class x {var x := 5}  class x {var x := 5} 
if int {x = int {x = int {x = x := "totor", x = x((), 5)} , x = while x.x() do x := ()} }  then x()
let function x(x : int) = int {}  function x() : int = "totor" var x := 5 in if int {}  then int {x = 5, x = 5}  else 5/break/int {}  end
x.x.x[int {x = int {x = "totor"} , x = "totor"*5} ][if x.x.x() then for x := () to "totor" do 5--5 else if int [5] of nil then x("totor", break) else x((), nil)].x(-while x.x do int {} , let class x {}  import "empty.tih" var x := 5 in let var x := 5 in 5 ; 5 end ; x end)
function x(x : int) = x.x := int {x = 5}  function x(x : int) = int {x = 5}  function x() = 5 import "empty.tih"
class x extends int {var x := 5 var x := 5}  var x : int := "totor"
x(for x := new int to if x[()] := x.x((), 5) then while for x := () to () do 5 do new int do if if nil|"totor" then -"totor" then x(x.x(break, break), x.x()) else x(if "totor" then break, x()), x(x(if x() then int {} , x(int {x = nil} , x(break, nil))), (for x := break to () do ())))
x[nil].x[x()][x.x[x(break, 5)]] := if new int then -int {} 
class x {var x := 5 var x := 5}  class x {var x := 5} 
function x(x : int) : int = x()
new int*x.x.x.x.x()
x.x.x.x.x.x()
int {} 
while x.x[let  in end][if int [nil] of nil then let  in 5 end] := let var x := 5 in 5 ; 5 end&-for x := break to "totor" do () do int {x = x[5].x, x = if int {x = x := 5, x = (5)}  then x()} 
(x.x.x.x())
(x(int {x = break} &x := (), x.x := x.x(break, nil)) ; x.x.x(x(break, nil), (5)) ; let  in end ; nil)
int {x = for x := int [x[break]] of while x.x() do -break to while x.x do int {}  do while int {}  do (() ; 5)} 
var x : int := while () do () class x {var x := 5}  var x := 5
class x extends int {var x := 5 var x := 5} 
while if let var x := 5 var x := 5 in if () then break else () end then x() do x.x.x[-(5)]
(int {}  ; int {x = for x := break to () do "totor"} )
var x : int := if 5 then 5
function x(x : int, x : int) : int = let var x := 5 in end
x[break][x][x.x.x(x((), ()), for x := () to "totor" do ())].x
new int
function x(x : int) : int = int {x = x.x(break, nil)}  class x {var x := 5} 
function x(x : int, x : int) : int = x.x := x(5, "totor") type x = array of int class x extends int {} 
while new int do -x()
let type x = class extends int{} in for x := int {x = new int}  to new int do if if () then 5 else () then int {}  end
type x = array of int
new int
x.x.x.x.x.x()
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5} 
int {} 
function x(x : int, x : int) : int = int {x = x := break}  type x = {} function x() = "totor"
for x := let var x := 5 import "empty.tih" in int [int {} ] of if 5 then nil else 5 end to x() do x(let import "empty.tih" var x := 5 in end, if for x := while 5 do () to let  in 5 end do (5) then let var x := 5 in end)
function x(x : int, x : int) = for x := let  in 5 end to for x := nil to () do "totor" do int {x = nil}  class x extends int {var x := 5}  function x() = "totor"
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() : int = () import "empty.tih" var x := 5
type x = array of int class x {var x := 5}  type x = int var x := 5
(x(int {x = x.x(), x = x := 5} , int [int {x = "totor", x = ()} ] of x.x()) ; int {} )
int {x = int [int {x = int {} } ] of x()} 
function x(x : int) = x[nil].x()
type x = array of int class x extends int {var x := 5}  function x() : int = nil
class x {var x := 5 var x := 5}  var x := 5
var x := nil+"totor"
function x(x : int) = while x do (5)
var x := for x := () to nil do "totor"
int [x["totor"].x.x := -int [if break then () else 5] of x := "totor"] of if if let var x := 5 in end then int [-()] of while break do 5 then int {} 
if x[break][int [5] of 5].x := x.x.x := int {x = x.x(), x = -nil}  then while if x.x then int {}  do int {x = if break*break then x() else int {x = 5, x = break} , x = int {x = if "totor" then break, x = nil+5} } 
-int [x.x[()|()].x(x*x, while int {}  do x := break)] of x()
x[nil].x[let var x := 5 in end].x
-let class x extends int {}  in end
class x extends int {var x := 5 var x := 5} 
new int
var x := (5)
let function x(x : int) : int = if () then 5 in end
type x = class {var x := 5} function x(x : int) = x.x() function x() : int = 5 import "empty.tih"
type x = {x : int} function x(x : int) = -"totor" class x extends int {} 
int {x = int [let import "empty.tih" var x := 5 in end] of if int {}  then x() else x()} 
function x(x : int, x : int) = x.x type x = array of int
function x(x : int) = int {} 
function x(x : int) = (5 ; 5)
while x.x.x[new int] := (x.x(break, 5)) do if let import "empty.tih" var x := 5 in end then int {x = x[nil]} 
class x extends int {var x := 5}  type x = class {}
type x = int
class x extends int {var x := 5}  function x(x : int) : int = (5) function x() = 5 var x := 5 var x := 5
class x {var x := 5}  class x extends int {var x := 5}  type x = int var x := 5 var x := 5
function x(x : int, x : int) = int [x()] of 5&()
type x = array of int type x = class extends int{} var x := 5 import "empty.tih"
if for x := -int {x = if nil then break else "totor", x = x((), 5)}  to int [x[nil]] of let var x := 5 in () end do (int {}  ; nil) then x.x[if break then nil].x else int {} 
(x[5][x()])
function x(x : int, x : int) : int = if for x := 5 to 5 do 5 then x := 5 else int {}  var x := nil class x extends int {} 
class x {var x := 5}  var x := nil function x() = "totor"
var x : int := int [nil] of () function x(x : int) = int {}  type x = int import "empty.tih"
if for x := int {x = let var x := 5 in nil end, x = (nil ; 5)}  to (new int ; 5 ; 5) do -if int {}  then (5) then while (x ; () ; 5) do int {x = let var x := 5 in () ; 5 end} 
type x = {x : int}
var x : int := let  in 5 end function x(x : int) : int = x(5, break)
x[()][int [nil] of break][let var x := 5 in () end].x
x[nil][x.x(break, break)].x.x
class x extends int {var x := 5}  class x extends int {var x := 5}  var x := 5 var x := 5 var x := 5
class x {var x := 5} 
x.x.x[int {} ].x.x()
let type x = {} in x[()][x()] end
new int
x[break].x.x[let import "empty.tih" var x := 5 in new int end].x()
int [-x(new int, -while break do "totor")] of if while x[5] := x.x() do let var x := 5 in end then if for x := for x := nil to "totor" do "totor" to if break then break do x.x((), nil) then x.x.x() else x(x["totor"].x((5), while 5 do nil), x.x.x())
type x = {x : int} function x(x : int) : int = let  in 5 end function x() = nil
class x {var x := 5} 
function x(x : int, x : int) : int = if new int then int [nil] of break else x((), nil) type x = int
class x {var x := 5}  type x = class extends int{}
let function x(x : int) : int = x := break in int [let  in 5 end] of x.x()*let var x := 5 in end end
type x = int
var x := -nil
new int
let var x := "totor" in end
x[5][x].x[int {x = int {} , x = new int} ].x(int {x = x(), x = let import "empty.tih" in end} , int {} )
function x(x : int, x : int) : int = while x(break, "totor") do int {x = 5, x = break}  type x = class extends int{}
class x extends int {var x := 5 var x := 5}  type x = array of int
(if if x(5, nil) then let  in end else int {x = 5, x = break}  then int {} )
for x := int {x = if int [x.x((), nil)] of x := nil then int [for x := "totor" to break do nil] of x.x() else (() ; 5), x = let import "empty.tih" var x := 5 in end}  to while while x do (5)|let var x := 5 in "totor" ; 5 end do let var x := 5 var x := 5 in int {x = nil, x = "totor"}  end do -int {x = x(nil, ())*int {x = break, x = break} , x = while if () then () do if nil then ()} 
-if int {}  then if int {x = x, x = x()}  then x.x("totor", "totor")|"totor"|break else let import "empty.tih" in end
function x(x : int, x : int) = if if 5 then break then x := "totor"
(if if "totor" then () then let  in 5 end&(nil ; 5) ; let var x := 5 in "totor" ; 5 end)
(while new int do x(-5, if break then "totor"))
function x(x : int) = x[()].x() function x(x : int) = x type x = int var x := 5 var x := 5
int {x = new int, x = x[5][-()].x.x(int {x = x[nil].x(x := break, -break)} , let import "empty.tih" var x := 5 in x.x() ; "totor" end)} 
let function x(x : int) = int {x = "totor"}  in int {x = while x(break, break) do if () then "totor" else (), x = let var x := 5 in break end}  end
x["totor"].x[x.x].x.x()
let var x := "totor" in end
var x : int := x(nil, break) class x extends int {var x := 5} 
while x[5][x := nil].x.x(int [x.x] of if if () then () then x := "totor" else x(), if x() then x["totor"].x(-nil, x()) else if let  in end then break-nil) do let class x {}  in x[()] end
var x := int {x = nil, x = ()}  class x extends int {var x := 5} 
function x(x : int, x : int) = int {x = let  in 5 end}  function x(x : int) : int = while break do nil function x() = nil
x[break][int [()] of "totor"][if x.x() then int [()] of nil]-if int {}  then int [x()] of if for x := nil to break do break then int {x = break, x = nil}  else let import "empty.tih" in x.x((), ()) ; break ; 5 end
int {x = if int {x = (5), x = let  in 5 end}  then new int, x = int {} } +let function x() : int = nil in end
new int
function x(x : int, x : int) : int = int {x = if 5 then nil, x = x}  function x(x : int) : int = if 5 then "totor" else () var x := 5
class x {var x := 5} 
x[break].x[int {x = let  in 5 end, x = x} ][x()*(() ; 5)].x(x["totor"].x[int {} ] := if int [x()] of int {x = break, x = break}  then new int, x()/5-break-int {x = nil} +if x.x(nil, "totor") then let  in end)
new int|x[break][new int].x
var x := int {x = ()} 
if int {x = let import "empty.tih" in for x := break to nil do "totor" end, x = x.x.x.x()}  then int [let var x := 5 in "totor" end] of 5+nil*x()+int [int [int {} ] of while 5 do "totor"] of (5) else int {x = x(let var x := 5 in 5 ; 5 end, x()), x = x.x.x.x(-if nil then () else "totor", int {x = -()} )} 
x.x.x.x[int [x.x.x(int [nil] of (), x())] of let var x := 5 in break ; 5 end]
function x(x : int) : int = x.x
class x extends int {var x := 5 var x := 5}  type x = array of int class x {}  import "empty.tih" var x := 5
class x {var x := 5 var x := 5} 
type x = array of int class x {var x := 5} 
(int {} )
for x := new int to if int {x = (nil)}  then new int else while let var x := 5 in end do x.x := x do int {x = x.x, x = (5 ; 5)} -int {x = x()} 
x(x[()].x[x()], int [x()|for x := let  in end to int [break] of nil do x.x(break, break)] of while let var x := 5 in end do if int {}  then let  in end)
for x := -x.x.x := let var x := 5 in break end to if if -x() then if -break then while nil do 5 else int {}  then for x := new int to x[5] do let var x := 5 in end else int {} &x[nil].x((5), x := 5) do for x := int {}  to while let var x := 5 in end do x(int {x = ()} , let  in 5 end) do let import "empty.tih" in x.x() ; break end
x(x[5].x[while let  in end do for x := break to 5 do break], x.x[(5)][if new int then x()].x(x[()].x := for x := "totor"-nil to x.x(nil, 5) do int {x = "totor"} , x[()].x := if while break do 5 then for x := () to "totor" do ()))
int {x = x()} 
while let type x = int import "empty.tih" in end do for x := x.x[x.x(5, break)].x(while int [()] of break do int {x = ()} , new int) to while if (5) then int {x = 5, x = "totor"}  do (break) do int {x = x[nil]} 
x.x.x.x[new int].x(let class x extends int {}  in end, if new int then for x := () to () do "totor"-int [-nil] of int {x = "totor", x = ()} *x(for x := for x := nil to "totor" do () to x(break, 5) do x, int {} ))
function x(x : int) : int = new int
int {} 
x(while x[()].x() do if new int then if "totor" then () else () else while 5 do "totor", let var x := 5 var x := 5 in let  in end end)+if int {}  then new int else int {x = new int} 
function x(x : int, x : int) = int {x = x("totor", break), x = "totor"|break}  function x(x : int) = int [()] of break
function x(x : int, x : int) = int [x := nil] of int ["totor"] of 5
x(x[break].x.x.x(), while x[break][x((), break)] := if while () do 5 then if () then () else break do int [int {x = if nil then nil else ()} ] of x[nil])
x[break].x[x(break, nil)-int {} ][-x.x := new int] := if while ("totor") do if -break then x.x() else if 5 then "totor" then int {} 
type x = {x : int} var x := nil var x := 5
var x := "totor"&"totor" class x {var x := 5} 
(for x := x.x.x((5), -5) to x.x := let  in end do x[break] ; x.x.x(x := (), if () then 5))
x(while new int do (-5 ; "totor"), -int {x = -x.x((), "totor"), x = int {x = x(), x = for x := () to break do ()} } )
for x := x[5][while nil do break].x.x() to x.x[x((), nil)].x do x(if if "totor"|() then while break do "totor" else if nil then "totor" else () then for x := x(break, nil) to let  in end do while 5 do () else int {} , let import "empty.tih" var x := 5 in "totor"*nil ; break ; 5 end)
var x : int := x()
int {x = x[5].x, x = let import "empty.tih" in end} &let function x() = () import "empty.tih" var x := 5 in end
int {x = int {} , x = for x := int {x = new int}  to x[nil][if () then nil else "totor"].x() do let var x := 5 in end/x()} 
function x(x : int, x : int) = int {} 
function x(x : int, x : int) = x.x class x extends int {var x := 5}  var x := 5 var x := 5 var x := 5
int {x = x(x["totor"].x.x(-x(), x[nil].x(nil&break, new int)), if x(x(), while break do nil) then x(x(), new int) else int {x = x.x("totor", "totor"), x = (5)} )} 
let type x = int in end
(x[5][5+break].x(x[5], int {} ))
function x(x : int, x : int) = if -5 then x(break, ())
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = while break do break class x {} 
function x(x : int, x : int) = int [x := break] of x := "totor"
class x extends int {var x := 5 var x := 5}  var x := break class x extends int {}  var x := 5
class x {var x := 5} 
int {x = if new int then for x := let var x := 5 in 5 end to -x.x() do new int, x = int {} } 
for x := let var x := 5 import "empty.tih" var x := 5 in if -nil then x else if () then 5 else nil ; x(break, "totor") end to x.x["totor"+"totor"][x.x()*if nil then nil] do new int
if int [int [-for x := 5 to nil do break] of x["totor"].x()] of if if if nil then () else () then if nil then "totor" else () then new int then -((5)) else x.x.x[let  in 5 end*x] := int {x = (break)} 
int [int {} ] of x()-if x() then int {x = if if 5 then "totor" else break then if "totor" then nil else if () then () else ()}  else if int [x()] of int {x = 5, x = ()}  then x["totor"]
class x extends int {var x := 5}  function x(x : int) : int = x(5, nil) type x = int import "empty.tih"
let function x(x : int) = x(nil, ()) function x() : int = 5 in end
class x {var x := 5} 
class x extends int {var x := 5 var x := 5} 
int {} 
let class x {var x := 5}  type x = int in while x[nil].x() do if for x := break to () do "totor" then int {}  ; if break-5 then x.x("totor", break) ; x(break, ()) ; "totor" ; 5 end
x.x.x.x[for x := while int [nil] of 5 do new int to let var x := 5 in end do int {} ] := (x.x.x() ; x := nil)
class x extends int {var x := 5}  class x {var x := 5} 
int {x = for x := for x := new int to let var x := 5 in "totor" ; 5 end do let var x := 5 in end to (int [()] of nil ; "totor") do x.x.x.x(x.x := (5), x[break])} 
class x extends int {var x := 5}  class x extends int {var x := 5} 
function x(x : int) = if ()+nil then while "totor" do "totor"
function x(x : int) = int {x = ()} -int [()] of () function x(x : int) = int {}  function x() : int = () import "empty.tih" var x := 5
class x extends int {var x := 5 var x := 5} 
if x.x.x[x.x].x(new int, (int {x = "totor"} )) then int {x = if -x := 5 then for x := if 5 then break else break to while nil do 5 do x else while let  in end do x := "totor", x = if x.x.x(int {x = nil} , for x := break to () do ()) then new int} 
var x : int := x() class x {var x := 5}  class x extends int {} 
x(x[5][int {x = nil, x = break} ][(() ; 5)].x(x[()][x(break, ())], int {x = x(let  in 5 end, x.x())} ), x.x[int {x = nil} ][x(let  in 5 end, let  in 5 end)] := x[break][x((), break)].x())
x.x.x[("totor")][while new int do if x.x() then x.x() else (5)].x(while x.x[x()].x(for x := x("totor", 5) to -() do if "totor" then "totor" else 5, int [for x := () to break do "totor"] of x.x()) do (new int ; nil ; 5), let class x {}  in end)
for x := let function x() : int = "totor" var x := 5 var x := 5 in if new int then break|5 end to x["totor"].x[x[5].x()] := x[()].x do int [x[5][for x := 5 to nil do "totor"].x()] of int {x = (()), x = while while "totor" do nil do while nil do ()} 
function x(x : int) : int = int [int {} ] of nil+5
if while if x := nil then int ["totor"] of break else new int do int {x = x.x(), x = x.x((), "totor")} /x[()][(5)].x(while x("totor", break) do let  in 5 end, let  in end&if break then "totor" else ()) then x()
function x(x : int, x : int) : int = -int {x = "totor", x = "totor"}  type x = array of int
type x = {x : int} var x := ()
type x = array of int function x(x : int) : int = x() function x() = break
x.x[while "totor" do break].x.x := int [x["totor"].x := while int {x = (), x = nil}  do new int] of -x[5].x(if () then 5 else (), int [()] of "totor")
class x extends int {var x := 5}  function x(x : int) = int {x = "totor", x = "totor"} 
class x {var x := 5 var x := 5}  type x = class {} class x {}  var x := 5
type x = array of int
class x extends int {var x := 5} 
if x[break][while nil do 5][new int].x() then -int {} 
x.x.x[(break ; 5)][-x.x] := x(int {x = int {x = -break, x = if 5 then "totor" else ()} } , if (5 ; 5) then new int)
new int
int {} 
for x := x.x[if nil then 5 else "totor"].x(while for x := break to () do break do int [break] of break, x.x)*x(x.x, -x.x()) to if new int then -if x.x() then int {}  else let  in end else int [int [if 5 then nil else break] of if 5 then break] of int [x()] of x() do if new int then if for x := while 5 do "totor" to x.x() do if nil then nil else 5 then if let  in 5 end then int {x = ()}  else x[break] := x(5, "totor")
if let type x = int in x["totor"] ; while break do 5 end then int {x = int {x = if x then for x := break to "totor" do 5 else int [break] of ()} , x = x[()][int {} ].x()}  else -let import "empty.tih" in x() end
let function x(x : int) : int = break+5 in x[5][x()] end
type x = {x : int}
class x {var x := 5} 
function x(x : int) : int = x.x.x() var x := 5 class x {}  var x := 5
let class x extends int {var x := 5}  in int {}  ; x.x.x(new int, x) ; let  in 5 end end
int {} 
x()
class x {var x := 5 var x := 5} 
if int {x = if x.x.x(x(), while "totor" do break) then let var x := 5 in end, x = if if new int then x.x() else -() then int {}  else int {x = for x := 5 to 5 do break} }  then int {} 
if x[break][x((), "totor")].x then int {}  else x(int {} , x.x.x.x())
type x = class extends int{var x := 5}
if x[5].x[-for x := "totor" to nil do ()].x() then x[nil][int [()] of 5][int {x = let  in 5 end} ] := x() else x()
let class x extends int {var x := 5}  type x = int import "empty.tih" var x := 5 in end
int {} 
x(int [int {x = let var x := 5 in end, x = let var x := 5 in end} ] of -x(nil-"totor", x.x()), while x.x.x do let var x := 5 var x := 5 in x((), 5) end)
int {x = x.x[new int][while (5) do int {x = nil, x = nil} ].x(let var x := 5 in x.x(5, "totor") end, -int [x.x((), 5)] of -break), x = for x := new int|if 5 then nil else ()|x[5] to x.x[while 5 do break] := let var x := 5 in end do int {} } 
-let class x {}  in x["totor"] := if nil then () else break ; x := nil ; nil ; 5 end
int {} 
(x["totor"].x(break|break, let  in 5 end) ; int [nil] of () ; 5)&-x[nil].x.x(x.x := x(), while int {x = nil, x = break}  do x(5, break))
class x extends int {var x := 5} 
var x : int := (5)
type x = class {var x := 5} function x(x : int) = while "totor" do nil
new int
function x(x : int, x : int) = x.x.x(int {x = break, x = ()} , int {} )
if int {x = x.x.x := x.x := x}  then (("totor" ; 5) ; x.x() ; 5 ; 5)
for x := int {x = int {} , x = x[5][-nil] := x(let  in end, if "totor" then break else nil)}  to while int {x = x.x.x(while break do (), while break do nil)}  do int {}  do x[break][x][x.x.x(int {x = ()} , x.x(5, nil))]
class x {var x := 5} 
x(new int, new int/x[5]+int {x = for x := () to () do 5, x = break+5} )
var x := x.x() class x extends int {var x := 5} 
type x = class extends int{var x := 5} type x = int class x {} 
x()
var x : int := for x := () to "totor" do 5
var x := (5) class x {var x := 5}  function x() = "totor"
x.x[int [()] of ()][let var x := 5 in end].x := for x := for x := x.x.x() to if int {x = break, x = nil}  then if nil then 5 else (5) do if x() then let  in 5 end to int {x = x(while "totor" do 5, while () do nil)}  do int {} 
if int {x = int [x(int {x = break, x = ()} , x)] of x.x, x = int {} }  then new int else let class x extends int {}  var x := 5 in let var x := 5 in end end
function x(x : int) = x[5] := int [break] of 5
class x extends int {var x := 5} 
(x[break][break/5] := int {x = int {x = nil, x = nil} , x = int {x = "totor", x = ()} } )
var x : int := x.x()
function x(x : int, x : int) : int = -for x := () to break do break
type x = {x : int}
function x(x : int, x : int) = x(for x := () to "totor" do nil, let  in end) class x extends int {var x := 5} 
function x(x : int, x : int) : int = x := nil+x("totor", break) function x(x : int) = x.x() function x() = break
if x.x.x[x(x(), if () then break else ())].x(if break-()+if break then () else "totor" then int {}  else if x := break then for x := () to break do nil, int {} ) then int {}  else x.x[(5)].x := int {x = x.x := if () then nil, x = for x := if "totor" then "totor" to while break do "totor" do x := ()} 
function x(x : int, x : int) : int = x[()] := int {x = 5}  var x : int := () function x() : int = nil
function x(x : int, x : int) = if break|break then int {x = nil, x = break}  type x = class {} class x extends int {} 
x(while -let  in 5 end do x.x.x(x.x(), if nil then 5), x.x[if "totor" then () else break])/int {x = let import "empty.tih" var x := 5 in end} 
x.x[x := break][while 5 do nil*new int].x
int {x = x.x.x[(break)]} 
x.x.x[int {x = int {} } ][while x["totor"].x() do let var x := 5 in break end] := int [let var x := 5 var x := 5 in if "totor" then 5 else () end] of int {x = -x, x = x.x.x()} 
x.x.x[while int [break] of break do x := 5][-int [x(nil, break)] of (5)].x()
x.x[x][int {x = x.x()} ].x := if x[nil].x := x() then if x(int {x = nil, x = break} , (5)) then if int {x = nil}  then x else -x()
if int {x = let import "empty.tih" var x := 5 in end}  then int {x = if x(x(), x()) then int {} , x = new int}  else x(int [x(int {x = "totor", x = "totor"} , int {} )] of -let  in end, x.x.x(if 5 then (), x.x())&x(let  in 5 end, int {x = 5} ))
x[5][x][if (5) then let  in end].x.x(let class x extends int {}  in end, for x := int {x = let var x := 5 in nil ; 5 end}  to x(if -nil then int {x = ()} , for x := int {}  to if nil then "totor" else break do let  in end) do x())
while let class x extends int {}  var x := 5 var x := 5 in end do int {x = if let var x := 5 in () end then while while "totor" do "totor" do if 5 then "totor", x = (int {x = break} )} 
function x(x : int) : int = if int {}  then int ["totor"] of "totor"
function x(x : int, x : int) = for x := nil&break to for x := () to () do nil do x() var x : int := nil
let var x := 5 var x := 5 in let var x := 5 in end end-int [let import "empty.tih" var x := 5 in -nil ; nil end] of while x[nil] do x()
var x : int := int {x = (), x = 5} 
while if -x((5), int {x = break, x = 5} ) then x.x[if "totor" then nil else 5] := let var x := 5 in end do -let import "empty.tih" in x.x() ; 5 end
class x {var x := 5 var x := 5} 
function x(x : int) = if x(break, "totor") then nil-"totor" class x {var x := 5} 
class x extends int {var x := 5}  type x = array of int
function x(x : int, x : int) = if let  in 5 end then int {x = break, x = 5} 
-int {x = let var x := 5 in end} 
class x extends int {var x := 5}  class x {var x := 5}  var x := 5
x[()][x].x.x.x(x.x[for x := "totor" to break do break].x := x.x[if 5 then 5].x(), x.x[(5)][let var x := 5 in end].x(if int [int {x = "totor", x = ()} ] of if nil then nil else () then if x := nil then -nil else let  in end else -if nil then () else (), let import "empty.tih" var x := 5 in new int ; break ; 5 end))
class x {var x := 5} 
var x : int := new int type x = {}
function x(x : int, x : int) = let var x := 5 in end type x = class extends int{}
-let function x() = break in end
function x(x : int) = x[break] var x := "totor" class x extends int {}  import "empty.tih"
var x : int := x(nil, ()) type x = class {} class x {}  var x := 5
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
var x := 5/()
x[break][if nil then 5].x.x.x(int {} , let function x() : int = break var x := 5 var x := 5 in end)
type x = class extends int{var x := 5} function x(x : int) = int [nil] of 5 function x() : int = "totor"
(if (5) then for x := 5 to nil do nil else let  in end|x.x)
function x(x : int, x : int) = x.x := let  in end
-x.x.x.x := let var x := 5 var x := 5 in if 5 then 5 end
class x {var x := 5} 
x[break].x.x.x(int {} , x.x.x := if while break do 5 then (5))|let var x := 5 import "empty.tih" in int [-()] of x.x() ; while "totor" do 5 end
x(int [for x := x.x.x(int [()] of 5, x) to new int do if x() then let  in end else int {x = ()} ] of x(), int {} )
if (int {x = new int, x = x.x("totor", ())} ) then int {}  else let function x() = nil import "empty.tih" var x := 5 in let var x := 5 in end end
class x extends int {var x := 5}  class x extends int {var x := 5}  class x extends int {} 
class x {var x := 5 var x := 5} 
function x(x : int) = if (5) then if break then nil else nil
var x : int := while "totor" do nil
x(x(x.x[x(break, nil)] := -while break do 5, int [int {} ] of for x := new int to let  in 5 end do for x := 5 to () do ()), if x[5][while "totor" do ()].x() then x["totor"][5&"totor"] else for x := int {x = nil} -for x := break to 5 do "totor" to while if break then nil do while break do 5 do let var x := 5 in "totor" ; 5 end)
type x = array of int function x(x : int) : int = int ["totor"] of () class x extends int {} 
function x(x : int, x : int) = x() var x := break
int {x = new int} 
class x {var x := 5} 
function x(x : int, x : int) : int = new int function x(x : int) = new int class x {} 
x(let class x extends int {}  in end, let import "empty.tih" var x := 5 in x ; nil ; 5 end*(int {x = 5, x = ()} ))
int {x = let class x {}  in end} 
class x {var x := 5 var x := 5} 
var x := let  in 5 end
type x = int
class x extends int {var x := 5} 
function x(x : int) = --nil
type x = int
var x := for x := "totor" to break do 5
type x = {x : int} function x(x : int) : int = let  in end
function x(x : int) = x.x := int ["totor"] of break class x {var x := 5}  type x = int
function x(x : int, x : int) : int = let var x := 5 in end function x(x : int) = int {x = ()} 
int {x = int {} +for x := x.x := x() to int {x = -nil}  do if if () then () else nil then x else -5, x = x.x[x.x("totor", 5)]*int {x = int {} } } 
class x extends int {var x := 5} 
class x extends int {var x := 5} 
x.x.x.x.x.x(x.x.x[new int] := x(-for x := nil to break do nil, (())), x.x.x[if x.x(nil, nil) then let  in end else (5)])
class x extends int {var x := 5 var x := 5}  function x(x : int) = int {x = break, x = break}  function x() = "totor"
function x(x : int, x : int) : int = (5 ; 5) var x := nil
class x {var x := 5} 
int {} 
(while for x := int {x = 5}  to x do x() do int {x = int {} , x = nil|5}  ; x[()])
int {x = x()} 
int {} 
var x : int := let  in end
class x {var x := 5}  function x(x : int) = -"totor" class x {} 
class x {var x := 5} 
let type x = {} class x {}  in end
function x(x : int) = int {x = 5, x = "totor"} |x
function x(x : int, x : int) : int = new int
x()|-x()
function x(x : int) : int = for x := for x := break to 5 do 5 to (5) do (5) function x(x : int) : int = x.x()
new int
if for x := let var x := 5 var x := 5 in end to x["totor"].x do ("totor"/()) then x(x(), x.x[break&()].x(let var x := 5 in end, if x then int ["totor"] of "totor")) else x((let  in end ; break), int {x = int {x = for x := 5 to () do nil, x = x()} } )
function x(x : int, x : int) : int = int {} 
while int [x[5].x(int {x = nil, x = 5} , while 5 do break)] of int [x := nil] of new int&x(int {} , x(if 5 then nil else (), new int)) do -while int {x = int [break] of nil}  do if let  in 5 end then let  in end else new int
x()
function x(x : int) = int {x = -break, x = for x := nil to 5 do nil} 
int [let type x = int in int [let  in end] of let  in end ; x := nil ; 5 end] of if let import "empty.tih" var x := 5 in new int end then int {x = x(), x = x()}  else int {x = let var x := 5 in 5 ; 5 end, x = x[break]} 
class x extends int {var x := 5 var x := 5}  type x = class extends int{}
function x(x : int, x : int) : int = x[nil]
let class x {var x := 5}  var x := 5 import "empty.tih" var x := 5 in let var x := 5 in if 5 then nil else () ; break ; 5 end end
function x(x : int, x : int) = x[()].x()
function x(x : int) : int = int [x()] of let  in 5 end
while int {x = while new int do while x do x}  do int {} 
var x := int [break] of () function x(x : int) = x := nil function x() = () var x := 5
function x(x : int, x : int) : int = x() type x = class extends int{} type x = int var x := 5
int {x = if let var x := 5 var x := 5 in end then x["totor"][new int].x() else for x := x.x.x(x(break, ()), break*nil) to x.x.x() do let var x := 5 in end} 
function x(x : int) = for x := new int to int {x = "totor"}  do let  in 5 end
int {x = new int} 
int {} 
var x := for x := () to 5 do 5 class x extends int {var x := 5} 
x[()].x.x[let var x := 5 in end].x(x.x.x[int [x] of -5].x(), x(x[5][let  in 5 end], int [let var x := 5 in end] of -let  in 5 end))
new int
function x(x : int) = new int var x := ()
class x {var x := 5 var x := 5} 
function x(x : int, x : int) : int = (nil ; 5) class x {var x := 5}  type x = int import "empty.tih" var x := 5
while int {x = if let  in end-while () do "totor" then (() ; 5)}  do if int {}  then int {}  else int {x = break} *x.x()/x[()][x := break].x()
type x = {x : int} var x : int := nil type x = int import "empty.tih" var x := 5
if -let var x := 5 in end then x["totor"].x.x.x(let var x := 5 in 5-"totor" end, x.x := if nil then break else nil-x.x) else new int
int {x = -for x := if x.x(5, ()) then while () do "totor" else (5) to x.x do new int, x = x["totor"].x[int {} ].x()} 
x.x[let  in 5 end][int [x(nil, nil)] of x.x()].x.x(new int, x[5].x[x.x := nil&"totor"].x(x.x[int {x = nil} ].x(), while x[nil].x(while break do (), let  in 5 end) do x[break].x(for x := break to break do (), x("totor", break))))
class x {var x := 5 var x := 5} 
type x = int function x(x : int) : int = let  in end class x extends int {}  import "empty.tih" var x := 5
class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5} 
new int
int {} 
int {} 
x.x[x := 5][let var x := 5 in end].x.x()
let function x(x : int) : int = new int function x() = "totor" var x := 5 in end
type x = int function x(x : int) : int = x.x(nil, 5)
function x(x : int) : int = x() class x {var x := 5}  class x extends int {} 
new int
(new int)
x()
if if x["totor"][for x := 5 to 5 do break] then let import "empty.tih" in end else int {x = x.x, x = for x := 5 to 5 do 5/int ["totor"] of break}  then x(let import "empty.tih" var x := 5 in end, if if x := () then (5) else int {x = 5}  then if let  in end then (5))
x[nil].x.x[int {x = new int} ] := if int {x = x.x}  then -let var x := 5 in 5 end else x[()].x.x(x(int {x = nil, x = nil} , let  in end), x[5].x())
class x extends int {var x := 5}  function x(x : int) : int = new int type x = int import "empty.tih" var x := 5
x[nil][int [break] of break].x[x["totor"].x].x(int {} +(if "totor" then nil else "totor" ; nil ; 5), int {} )
class x extends int {var x := 5}  class x {var x := 5} 
function x(x : int, x : int) : int = for x := x := break to -() do x := () function x(x : int) : int = 5/"totor" class x extends int {} 
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
var x : int := int [5] of nil class x {var x := 5} 
class x {var x := 5}  class x {var x := 5} 
class x {var x := 5} 
function x(x : int, x : int) = -x()
(x.x.x.x(x[5] := let  in 5 end, x()))
function x(x : int) = int {}  function x(x : int) : int = (5) function x() = 5 import "empty.tih" var x := 5
let type x = {} in end
int {} 
int [while new int do int {x = x(), x = for x := x(nil, break) to x := nil do int {x = break} } ] of new int
if new int then while int {x = int {} }  do new int
int [int {x = let import "empty.tih" var x := 5 in end} ] of if x.x[while break do nil].x() then -(() ; 5) else x["totor"].x.x()
function x(x : int) = if while "totor" do 5 then (5) else x.x(break, 5)
x(int {} , if for x := -new int to int {x = x}  do let var x := 5 in end then x())
int {x = int {x = let var x := 5 var x := 5 in (5) end} , x = for x := int {}  to int [(nil ; 5)] of x[5].x() do if x("totor"+5, int [break] of ()) then ("totor" ; 5) else let var x := 5 in end} 
x.x[if "totor" then () else "totor"][for x := for x := () to break do "totor" to new int do -()].x
int {x = int [x()] of x(), x = x["totor"][x].x := x.x[for x := () to "totor" do 5].x()} 
var x := x.x() class x extends int {var x := 5} 
var x := if () then () class x extends int {var x := 5} 
int [int {} ] of let class x extends int {}  in int {x = x("totor", break), x = if () then ()}  end
int [int {} ] of while x((()), x["totor"]) do int [-"totor"] of int ["totor"] of "totor"/int {x = x.x(), x = int {} } 
int [if -if break then break else ()&for x := nil to "totor" do nil then let import "empty.tih" in end] of let function x() = 5 in new int&let  in end ; if "totor" then break else 5 ; "totor" end
function x(x : int) : int = int {x = x := (), x = let  in 5 end}  class x {var x := 5}  var x := 5
for x := int {}  to x(int {x = new int} , let import "empty.tih" var x := 5 in int {x = 5, x = "totor"}  ; break end) do int {x = x.x.x} 
-let class x {}  in x := 5-for x := "totor" to nil do break ; x.x((), 5) ; break ; 5 end
int {} 
class x extends int {var x := 5}  var x : int := "totor" class x extends int {} 
class x {var x := 5 var x := 5}  function x(x : int) : int = x((), ()) var x := 5 import "empty.tih" var x := 5
(x.x.x ; x.x.x(nil&nil, -"totor") ; (5))
int [let function x() = 5 import "empty.tih" in x["totor"] end] of x.x[int {x = "totor", x = break} ][int {} ] := if if if () then nil else "totor" then let  in 5 end else for x := () to nil do break then x.x.x(if break then (), let  in 5 end) else int [let  in end] of x()
while int [-while if nil then nil else break do x := nil] of let import "empty.tih" var x := 5 in (5) ; 5 ; 5 end do if while let var x := 5 in end do int {}  then (if "totor" then "totor" ; "totor")
class x extends int {var x := 5 var x := 5}  var x := () function x() = "totor" var x := 5 var x := 5
function x(x : int, x : int) : int = while let  in end do int {x = nil} 
x["totor"][new int].x[x.x.x.x(x := "totor"*(5), if -() then for x := 5 to 5 do "totor" else let  in end)]
type x = {x : int}
x["totor"][int {x = "totor"} ][new int] := int {x = for x := -nil to let  in 5 end do int {x = ()} } -let function x() : int = "totor" import "empty.tih" in x(5, "totor")|if "totor" then 5 end
int {x = if int {x = x.x()}  then ("totor")/if for x := () to break do "totor"|int {x = nil, x = 5}  then x.x := (5) else new int} 
type x = {x : int} type x = {}
function x(x : int, x : int) : int = while if "totor" then () else 5 do if () then 5 else break class x extends int {var x := 5} 
int {} 
class x {var x := 5} 
var x : int := x.x()
class x {var x := 5} 
function x(x : int, x : int) : int = int {x = x(break, nil)}  var x := 5 function x() : int = "totor"
function x(x : int) : int = x(int {x = break} , x := ())
var x : int := 5&"totor" function x(x : int) : int = let  in end type x = int var x := 5 var x := 5
if x.x[if 5 then () else 5][int {x = "totor", x = ()} &x(break, 5)].x(x.x[if "totor" then ()].x(), let import "empty.tih" var x := 5 in end) then x[break][int [nil] of nil].x.x()
class x {var x := 5 var x := 5}  function x(x : int) = -"totor" class x extends int {}  var x := 5 var x := 5
int {} 
function x(x : int, x : int) = new int
new int
type x = array of int
class x extends int {var x := 5} 
x.x.x[if int [break] of 5 then if () then "totor" else x(nil, 5)].x.x()
function x(x : int) = int {} 
function x(x : int) = for x := x.x(nil, "totor") to let  in 5 end do int {x = break} 
for x := x.x.x[x.x.x(let  in end, int {} )].x() to int [int [x.x := int {} ] of x[()].x()] of new int do x(while x() do int [-()] of int {x = ()} , if (nil ; 5) then new int else -if "totor" then break else ())
x()
var x : int := -break var x : int := nil
class x extends int {var x := 5}  class x extends int {var x := 5}  class x {} 
function x(x : int, x : int) = x[break].x() function x(x : int) = x.x(nil, ())
x.x[x.x()][x.x.x(int [break] of (), x(5, nil))].x
while int {x = x[break][x()]}  do if int {x = x[nil].x(int [()] of break, if 5 then () else 5), x = let var x := 5 in nil ; 5 end}  then int [x(-(), (5))] of x[break].x()
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = if 5 then ()
let var x := 5 class x {}  in if new int then let var x := 5 in end end
((int {x = nil, x = nil} ))
int {x = let type x = int import "empty.tih" in x.x end} 
let class x extends int {var x := 5}  function x() : int = 5 import "empty.tih" in let var x := 5 var x := 5 in end end
class x extends int {var x := 5 var x := 5} 
class x {var x := 5}  class x extends int {var x := 5} 
int [if int [x(if () then (), int [nil] of nil)] of (() ; 5) then while x.x.x(int {x = "totor", x = nil} , int {x = "totor", x = break} ) do --nil else -for x := -"totor" to int {}  do new int] of let function x() : int = "totor" in end
type x = int
-if (int {x = 5, x = break} ) then if x.x(nil, 5) then if break then 5 else x := 5+new int else -int [for x := "totor" to "totor" do "totor"] of x := break
function x(x : int, x : int) : int = x.x
x()
function x(x : int, x : int) = x.x
var x := let  in 5 end
type x = int var x := nil type x = int
int {x = x.x.x[if x.x(5, 5) then new int else x.x(nil, "totor")]} 
-for x := new int to let import "empty.tih" in end do if let var x := 5 in end then int {x = while () do break, x = int {x = "totor", x = ()} } 
int [int {x = int {x = x(x((), 5), let  in end), x = int {x = x.x()} } , x = if let var x := 5 in nil ; 5 end then x/int {x = "totor", x = nil} } ] of if if while x := nil do "totor"&nil then x.x else x.x := int {}  then -(5 ; 5) else if (5 ; 5) then -if break then ()
type x = int type x = class {}
if int [x.x.x] of int {x = x[nil] := new int}  then (-if "totor" then break ; int {x = nil, x = nil} ) else x()
x[5].x.x.x
x[5][x.x()][if () then "totor"/x()].x.x(x[()].x.x.x(int {x = int {x = x.x(break, ()), x = let  in end} , x = int {} } , x()), let var x := 5 var x := 5 in end)
class x {var x := 5}  class x {var x := 5}  class x extends int {} 
if if int {x = x(x.x(), (5)), x = x((5), x.x(break, 5))}  then int {x = x.x.x(), x = x((5), if 5 then ())}  else if for x := break to nil do () then x := 5 else x|new int then for x := x.x[let  in 5 end] := while int {x = break}  do for x := "totor" to () do 5 to if int [if nil then "totor" else break] of int {}  then new int do x[()].x.x(if nil then 5 else "totor"-new int, int {} ) else if let import "empty.tih" var x := 5 in x() ; break ; 5 end then (while () do break)
type x = array of int type x = array of int
type x = {x : int}
x((("totor" ; 5)), let function x() : int = nil in new int end)
function x(x : int, x : int) : int = x[nil] := (5)
class x extends int {var x := 5}  class x extends int {var x := 5}  class x extends int {}  import "empty.tih"
new int
function x(x : int) : int = int {x = if () then ()}  var x : int := 5 function x() = 5 var x := 5 var x := 5
int {x = x.x.x[x.x.x()].x(int {} , (x.x()))} 
(("totor")+x.x.x())
for x := x() to int {x = x["totor"].x := if int {x = nil}  then x() else int {x = 5, x = break} , x = x(int {x = x.x(), x = while () do break} , if let  in 5 end then break+break else if nil then nil)}  do x.x[(5)][x(int [5] of nil, x.x())].x((int {x = (), x = nil}  ; break ; 5), int [int [x.x((), "totor")] of if break then 5] of int {x = if "totor" then "totor" else break, x = x(nil, "totor")} )
x[nil].x[int [(5)] of new int].x
x()
function x(x : int, x : int) = -int {x = 5}  class x {var x := 5}  function x() = () var x := 5
function x(x : int, x : int) : int = int {x = (5), x = int {x = 5, x = nil} } 
let function x(x : int) = x.x("totor", 5) in x.x|for x := x := "totor" to x((), "totor") do x := () end
let class x {var x := 5}  var x := 5 var x := 5 var x := 5 in x.x.x := let var x := 5 in break ; 5 end end
let class x {var x := 5}  in end
int {} 
while x.x.x[int {} ].x(-x.x()-x, x(while while 5 do 5 do new int, x[()].x(5&break, (5)))) do let function x() : int = nil var x := 5 in for x := x() to int ["totor"] of () do new int end
function x(x : int, x : int) = if () then 5/let  in 5 end class x extends int {var x := 5} 
x()
type x = array of int var x := "totor" function x() = break var x := 5
class x extends int {var x := 5 var x := 5} 
while let var x := 5 import "empty.tih" in end do for x := x((nil ; 5), int [while 5 do "totor"] of 5/5) to let import "empty.tih" in end do -int {x = let  in 5 end} 
function x(x : int, x : int) = int {}  type x = class extends int{}
class x extends int {var x := 5 var x := 5}  type x = array of int var x := 5
int {x = x[nil][-5][while for x := nil to nil do nil do if () then break]} 
function x(x : int, x : int) = for x := x to int {x = ()}  do int [5] of "totor"
var x := if break then 5 else ()
class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5} 
if x() then new int else x[nil].x.x := int {x = if (5) then x(break, ()), x = x.x := x} 
while (let var x := 5 in () ; 5 end ; int {x = (), x = 5} ) do x[()].x.x := x()
class x {var x := 5}  type x = array of int
class x {var x := 5} 
x.x.x[if while "totor" do break then int {}  else int [5] of "totor"].x.x(x.x.x[while int {x = break, x = 5}  do x.x()].x(), new int)
x()
if int [while x(let  in 5 end, new int) do while int {}  do x.x()] of x["totor"].x then (for x := nil to () do "totor")|x[()][if "totor" then 5 else nil] := let var x := 5 in end else let var x := 5 in int {}  end
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() = 5
function x(x : int, x : int) = x.x.x() class x extends int {var x := 5}  type x = int
x.x.x.x[int {} ].x(new int, -x())
type x = class {var x := 5} class x extends int {var x := 5} 
-int [new int] of let import "empty.tih" in end
x["totor"][int {} ][(nil ; 5)].x.x()
int {x = for x := int {}  to let var x := 5 var x := 5 in let  in 5 end end do x(int {} , x(x := nil, for x := "totor" to nil do nil)), x = x(let import "empty.tih" in end, (int {} ))} 
type x = array of int
let function x(x : int) = for x := break to nil do () in end
let class x {var x := 5}  in int {}  end
x.x[(5)][int {} ].x.x((let var x := 5 in end ; x("totor", 5) ; break), -x.x.x.x())
var x : int := int {x = break, x = "totor"}  function x(x : int) : int = x.x()
var x := int {} 
class x {var x := 5} 
while while (if nil then 5) do x() do for x := new int to (x.x(nil, ()) ; break ; 5) do int {x = int {x = while nil do nil} } 
var x := if () then break
function x(x : int, x : int) = int {x = (), x = 5} -if () then () else "totor" class x extends int {var x := 5} 
int {x = x()} 
new int
class x {var x := 5 var x := 5}  function x(x : int) : int = for x := break to "totor" do "totor"
class x {var x := 5 var x := 5}  function x(x : int) = int {}  function x() = nil
class x {var x := 5 var x := 5}  var x := ()
function x(x : int) : int = -x.x() function x(x : int) : int = x(5, 5) class x {}  import "empty.tih" var x := 5
type x = array of int function x(x : int) = x.x() type x = int
x[break].x.x[x(let var x := 5 in 5 end, int {x = x()} )].x()
function x(x : int) : int = (() ; 5) type x = array of int function x() = "totor"
function x(x : int) : int = int {x = int {} , x = let  in end}  function x(x : int) = int {}  var x := 5 import "empty.tih" var x := 5
type x = {x : int}
x[()].x[x[nil].x()].x
type x = int class x {var x := 5}  type x = int
-x.x.x[-int {x = "totor"} ].x(x(), x.x.x)
class x {var x := 5}  class x extends int {var x := 5} 
x[break][x()][if int {x = break}  then x := "totor"][new int].x()
class x extends int {var x := 5}  function x(x : int) : int = if 5 then 5 else break
function x(x : int, x : int) : int = new int
class x {var x := 5}  class x {var x := 5}  class x extends int {}  var x := 5 var x := 5
x.x[break|break].x.x.x(x["totor"][x.x()][for x := "totor" to nil do break/x()], -int {x = let var x := 5 in () end} )
for x := -int {x = x.x.x(), x = (5)}  to x(x["totor"][x()] := int [int ["totor"] of break] of for x := 5 to () do break, x()) do int [x.x[x.x(5, 5)].x()] of while if x.x(break, nil) then if 5 then 5 else let  in 5 end do int {} 
x[nil][int ["totor"] of ()][if x.x("totor", 5) then if 5 then break else if "totor" then ()].x.x()
if x[nil].x.x() then ("totor")*x[5]-if x[nil][5-"totor"].x() then for x := if new int then new int else x := nil to let var x := 5 in nil ; 5 end do if () then "totor"+int {x = "totor"}  else int {x = let var x := 5 in 5 end, x = if x := break then -()} 
function x(x : int, x : int) = let var x := 5 in break end
while (x.x := x := nil ; x.x((), break)) do int {x = int {x = x.x := for x := "totor" to break do break, x = while ()&"totor" do if break then ()} } 
type x = {x : int}
class x extends int {var x := 5}  type x = class extends int{} function x() = ()
function x(x : int, x : int) = (nil) function x(x : int) : int = for x := () to () do 5
let function x(x : int) = x() function x() : int = break in let var x := 5 var x := 5 in end end
int {x = new int} 
let var x := break in let import "empty.tih" in x := nil ; "totor" ; 5 end ; let var x := 5 in () end end
var x : int := if () then break
type x = int
int {} 
x()
var x : int := x.x(nil, "totor")
x(x((int {x = (), x = "totor"}  ; nil), if x[break] then x.x.x() else for x := int {x = break}  to x := nil do x(nil, break)), int {x = (x.x() ; 5 ; 5), x = (if nil then "totor" else nil ; "totor" ; 5)} )
x.x.x.x.x.x(int {} , int {x = int {x = int {x = nil} , x = int {} } /-for x := "totor" to () do break} )
function x(x : int) : int = x["totor"] := int {}  var x : int := nil
type x = class extends int{var x := 5}
x[break][int [()] of ()][int {x = while break do "totor"} ][int {x = x.x(nil, ())-x.x(nil, "totor")} ]
class x {var x := 5 var x := 5}  class x {var x := 5}  class x {} 
class x extends int {var x := 5 var x := 5} 
type x = class {var x := 5} class x extends int {var x := 5} 
new int
int [x.x[if nil then () else "totor"][let var x := 5 in nil ; 5 end].x(x(x["totor"].x(if () then 5 else break, x := "totor"), for x := -nil to x := "totor" do int {x = nil, x = 5} ), x["totor"][x])] of while int [for x := (5) to x() do x] of for x := int {}  to while () do 5 do x.x("totor", "totor") do x.x[int {x = (), x = break} ].x()
class x {var x := 5 var x := 5} 
function x(x : int) : int = if int {x = "totor", x = "totor"}  then -5
x["totor"].x.x.x := int {x = int [if int {x = nil}  then (5) else int {x = break, x = "totor"} ] of if -5 then x := 5} 
type x = class {var x := 5}
x.x[-break].x[x.x.x.x((nil ; 5), int [let  in end] of int {x = nil, x = ()} )] := let class x extends int {}  in int [-"totor"] of int {x = ()}  ; int [()] of () ; 5 ; 5 end
int [x.x.x.x] of if int {}  then while if let  in 5 end then x.x(nil, "totor") else if break then nil else nil do int [int [break] of ()] of x(nil, "totor")
int {x = if -int [int {} ] of break+5 then -int {x = (5), x = x.x()}  else let import "empty.tih" var x := 5 in while 5 do nil ; 5 end} 
var x : int := int [break] of ()
-int [while int {x = int ["totor"] of break}  do let var x := 5 in end] of x["totor"][for x := "totor" to break do break] := while int {x = (), x = "totor"}  do (5)
type x = {x : int}
-x()
int {x = let function x() : int = () import "empty.tih" in end} 
x(let function x() : int = () in int [let  in 5 end] of x.x() end, (while let  in 5 end do for x := break to 5 do 5 ; int {}  ; ()))
x(int {x = while while for x := break to 5 do break do for x := 5 to break do "totor" do int {x = nil-break} } , let class x {}  var x := 5 in end)
class x {var x := 5}  class x extends int {var x := 5}  function x() : int = "totor"
class x {var x := 5 var x := 5} 
(new int ; ("totor" ; 5))
var x : int := new int class x {var x := 5}  var x := 5 import "empty.tih"
if int [x()] of while int {}  do int {x = x.x((), "totor"), x = x := ()}  then -int {x = x()/x.x(), x = int [if "totor" then nil else "totor"] of int [nil] of ()}  else let class x {}  in int {x = x.x()}  end
x()
int {} 
class x {var x := 5 var x := 5}  type x = array of int var x := 5 var x := 5
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
x[nil].x[new int].x
x(x(x["totor"].x := x(), int {x = let  in end|(5), x = let var x := 5 in break ; 5 end} ), int [int [int {x = int [()] of break, x = "totor"/5} ] of while while () do "totor" do int {x = ()} ] of int {} )
var x := int [()] of break
function x(x : int) : int = x[break].x(int {x = ()} , x)
int {x = if int [int {x = int {} } ] of x() then for x := let var x := 5 in () end to x[()].x(x, x.x((), "totor")) do x[5] := x := () else for x := new int-nil*5 to -int {x = break, x = ()}  do int {x = int {x = nil, x = 5} } , x = int {x = x(), x = -if while 5 do 5 then (5)} } 
function x(x : int, x : int) = while let  in 5 end do 5*"totor"
var x : int := x.x("totor", break) var x := ()
function x(x : int) = int {x = int {x = break, x = nil} } 
function x(x : int) = x[5].x()
int {} 
var x := x.x("totor", break) var x := ()
while int {}  do int {} 
type x = int
class x {var x := 5} 
function x(x : int) : int = x() class x extends int {var x := 5}  function x() = nil
type x = array of int
x.x.x[int [for x := break to 5 do "totor"] of int {} ][new int].x(x[()][int {} ][x(if () then nil, while break do 5)].x(), for x := let var x := 5 in end to int {}  do for x := let var x := 5 in "totor" ; 5 end to int {}  do new int)
int [x(int [if x(break, "totor") then int [()] of break] of x.x()-x(break, "totor"), int {x = new int, x = int {x = for x := nil to () do "totor"} } )] of -x.x[x()]
for x := x((break|break ; nil), x()) to let var x := 5 in end do int {x = if x[()].x(int {x = 5, x = ()} , if 5 then 5) then x[nil] else int [int {} ] of int [5] of break, x = x.x.x := x()} 
function x(x : int, x : int) : int = x.x.x()
class x extends int {var x := 5}  function x(x : int) : int = new int function x() = () var x := 5
for x := -x.x[(5)].x() to int {x = (while nil do () ; nil), x = x.x.x := x.x}  do x.x[new int][x[5] := while nil do break].x()
if for x := int [int [int {x = "totor"} ] of x.x()] of new int to x["totor"][for x := nil to () do nil].x() do if (nil) then x["totor"] := for x := () to 5 do nil else x(let  in end, new int) then for x := let import "empty.tih" var x := 5 in end to for x := x((5), while () do nil) to if nil&5 then int {}  else x("totor", "totor") do int {x = break, x = 5} |x() do for x := if int {x = break, x = 5}  then x.x(5, nil) else if "totor" then break to let var x := 5 in "totor" ; 5 end do let var x := 5 in end
class x {var x := 5 var x := 5}  var x : int := nil
var x := ()-() class x extends int {var x := 5} 
for x := new int to if int {x = -x(break, break), x = x(x.x(5, nil), (5))}  then int [x.x.x(int {} , int {x = nil, x = "totor"} )] of int {x = if 5 then break else (), x = new int}  do let function x() = () var x := 5 in end
x()
x.x[let  in end].x.x
function x(x : int) : int = new int
x(new int, int {x = x()} )
class x extends int {var x := 5 var x := 5} 
let type x = class extends int{} in end
function x(x : int) = ("totor")
type x = array of int function x(x : int) = let  in 5 end
class x {var x := 5}  function x(x : int) : int = 5*nil class x {} 
function x(x : int, x : int) = x.x.x() function x(x : int) : int = int [5] of nil
x.x[x(5, "totor")].x[let var x := 5 var x := 5 in int {}  ; "totor" end] := int {} 
(int {x = if int {x = 5, x = nil}  then while nil do () else x("totor", break)} )
let var x : int := "totor" type x = int in let import "empty.tih" var x := 5 in end end
--new int
(-5&int {} |x.x := int [5] of nil)
type x = class extends int{var x := 5} function x(x : int) : int = if 5 then nil else () class x {} 
class x {var x := 5}  type x = class {}
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5} 
x.x[x].x[let import "empty.tih" in end].x()
if x[()][let  in 5 end][(break)] then int {} 
type x = class extends int{var x := 5} class x {var x := 5}  class x {} 
while x[5][x.x((), 5)].x := int {x = x.x.x()}  do x()
class x extends int {var x := 5}  class x {var x := 5} 
x()
function x(x : int, x : int) = int {} 
x()
(if int [x()] of x then -let  in end else int {x = if break then 5, x = while "totor" do nil}  ; new int ; x := "totor" ; nil ; 5)
function x(x : int) = int [if nil then break] of (5)
type x = class {var x := 5}
class x extends int {var x := 5} 
class x extends int {var x := 5}  function x(x : int) = int {} 
let function x(x : int) : int = int [break] of "totor" in x[()][let  in end] ; let var x := 5 in "totor" end ; let  in end end
function x(x : int, x : int) : int = let var x := 5 in end
function x(x : int) = if x := break then (5) class x extends int {var x := 5}  class x extends int {}  var x := 5 var x := 5
-x[break].x[if x then int [5] of "totor" else x.x(5, 5)] := x(let var x := 5 in break end, x.x)
class x extends int {var x := 5} 
for x := int [for x := if let  in end then let  in end else x := break to x() do (break)] of if int {}  then int {x = let  in end}  to new int do x()
x.x.x[if int {}  then x].x := (int {x = "totor"&()}  ; -5)
class x extends int {var x := 5 var x := 5} 
let function x(x : int) : int = -break function x() = break import "empty.tih" var x := 5 in x[break][int {x = "totor"} ].x() ; int {x = if break then nil}  ; x.x() ; break ; 5 end
class x extends int {var x := 5} 
-x(int {x = int {x = x(), x = x.x()} } , x.x[-break] := for x := break to 5 do nil/-nil)
if x.x[x(nil, break)][let var x := 5 in nil end] then x["totor"].x.x.x() else (if x := nil then if 5 then 5 ; for x := () to "totor" do () ; nil)
if if let import "empty.tih" var x := 5 in let  in 5 end ; break ; 5 end then -while let  in 5 end do int {x = "totor", x = nil}  else int [for x := x() to if nil then break else "totor" do x := 5] of int {x = x.x()}  then (int {} )/if x[()] then x[5] := if break then "totor" else int {} 
x()
x()
while int {}  do if int {x = while int [break] of "totor" do if 5 then break}  then while -x do int [5-5] of x
-x.x.x.x
type x = class {var x := 5} function x(x : int) : int = while "totor" do () function x() : int = nil import "empty.tih"
function x(x : int) : int = if x := nil then x.x()
let class x {var x := 5}  function x() : int = nil in end
int {x = for x := x.x.x := for x := for x := 5 to 5 do () to (5) do -() to if x.x.x() then let var x := 5 in end else let var x := 5 in end do x.x[int ["totor"] of 5] := if int {}  then x.x(), x = ((5))&(int {x = 5}  ; "totor" ; 5)} 
x()
function x(x : int, x : int) : int = x.x.x(int [5] of 5, nil-5) function x(x : int) : int = int ["totor"] of "totor" class x {}  import "empty.tih" var x := 5
class x {var x := 5 var x := 5}  var x := 5
class x {var x := 5}  function x(x : int) : int = int {x = break}  class x {} 
type x = int
for x := int [let import "empty.tih" in end] of x() to for x := let var x := 5 in end-x(x(), x.x(break, 5)) to if x[nil].x() then int {x = (), x = break} |int {x = break, x = nil}  do x.x.x.x() do int {x = x.x[int [nil] of "totor"].x()} 
int {} 
x(x(let var x := 5 var x := 5 in end, int {} ), x(let var x := 5 in x.x() end, x()))
class x {var x := 5 var x := 5} 
while -new int do if x.x.x.x() then x.x.x := x.x.x(x := break, while 5 do ()) else int {} 
class x extends int {var x := 5} 
x[5].x.x.x.x(let var x := 5 in int {}  ; nil ; 5 end+x.x[x()] := x.x.x(int {} , (5)), int [int {x = x[break] := x.x("totor", 5), x = x[()] := new int} ] of x[5][let  in end].x())
while if while (5) do x[5].x() then x.x[new int].x() else x["totor"].x do int {x = if if nil/5 then new int else x := "totor" then x.x else while for x := () to () do nil do let  in 5 end, x = x()} 
-if int {}  then let import "empty.tih" in x() ; "totor" end else -x.x.x()
(while x.x := let  in end do let var x := 5 in () end)
var x : int := (5) type x = class extends int{}
int {} 
class x extends int {var x := 5}  var x : int := "totor" type x = int
var x : int := new int class x extends int {var x := 5}  var x := 5
function x(x : int, x : int) : int = x.x class x extends int {var x := 5} 
var x := while break do "totor"
class x {var x := 5}  class x {var x := 5} 
for x := int [x[5].x] of for x := int {} |let  in 5 end to x["totor"].x() do -int {x = 5}  to x.x.x.x do int {x = let import "empty.tih" var x := 5 in end, x = x[()].x} 
class x extends int {var x := 5} 
while x.x[int {} ] := int [5] of "totor"+x-x[()].x.x() do for x := if int {x = int {} }  then let var x := 5 in end to x() do if int {x = int {x = "totor"} , x = x}  then x[()].x(-(), let  in 5 end)
if x() then x[break][int [5] of nil].x(let var x := 5 in end, let var x := 5 in end)+x[nil]&if if nil then nil else () then x.x((), 5) else x.x() else x(int [x.x((), ())/int {x = break, x = 5} ] of int {} , for x := x["totor"] := (5) to int [(5)] of if 5 then nil do (()))
function x(x : int) = int [break] of break/int {}  type x = array of int
let type x = {} in let var x := 5 var x := 5 in let  in end end ; int {}  ; 5|() end
((for x := "totor" to nil do 5 ; "totor"))
x["totor"].x[-x.x()][new int].x()
function x(x : int) : int = (nil)
int {} 
class x extends int {var x := 5 var x := 5}  var x : int := nil
class x extends int {var x := 5 var x := 5}  var x : int := nil
type x = class extends int{var x := 5}
function x(x : int) = (5 ; 5) class x {var x := 5}  var x := 5
new int
type x = class extends int{var x := 5} function x(x : int) : int = int {x = "totor"} 
var x : int := ()*5 type x = array of int
type x = int
class x {var x := 5} 
(for x := int [()/()] of if 5 then break to x() do x() ; for x := x("totor", ()) to if 5 then "totor" else break do ()/break)
(int [int {} ] of while while () do 5 do while "totor" do 5 ; x() ; int {x = break}  ; nil)
new int
function x(x : int) = let var x := 5 in end
class x extends int {var x := 5} 
int {x = -x(let var x := 5 in nil ; 5 end, x.x.x(for x := nil to "totor" do break, x))} 
type x = array of int var x : int := break class x {} 
x["totor"][int {x = (), x = break} ][int [x((), nil)] of int {x = (), x = "totor"} ][x.x.x.x(int {x = x.x("totor", ()), x = x.x(break, break)} , x())].x()
var x := int {}  class x extends int {var x := 5}  var x := 5 var x := 5 var x := 5
function x(x : int, x : int) = new int class x {var x := 5}  class x extends int {}  var x := 5 var x := 5
type x = class extends int{var x := 5}
function x(x : int, x : int) : int = let var x := 5 in end class x extends int {var x := 5} 
x(x[nil][let  in end].x.x(), x.x[let  in end][-int {} ].x(let var x := 5 in end, x()))
function x(x : int) = for x := break to break do 5*if () then nil
int {x = x(), x = -let var x := 5 in end|-if x() then if () then break} 
int {x = x[()].x[x[()].x(x.x(), int {} )] := x[nil].x.x(x.x.x(), let var x := 5 in "totor" ; 5 end), x = x[break][let  in end].x.x(if int {}  then int {}  else for x := if break then "totor" to if break then () else "totor" do -"totor", x.x.x.x(x[break].x(), let var x := 5 in end))} 
-for x := x(x["totor"], for x := x := break to x do -5) to if while let  in end do int ["totor"] of 5 then int {x = x()}  else x.x := x := break do new int
var x := int [()] of break
-while if while int [()] of "totor" do if break then 5 then (nil ; 5) else new int do x[nil][x]
class x {var x := 5} 
class x extends int {var x := 5}  class x {var x := 5}  function x() : int = () import "empty.tih"
function x(x : int, x : int) : int = if int {x = nil, x = ()}  then new int else x() type x = array of int function x() : int = nil
let class x extends int {var x := 5}  class x {}  var x := 5 var x := 5 in x(if (5) then x.x(5, "totor") else new int, x.x) ; x() end
let type x = class {} function x() : int = nil var x := 5 var x := 5 in x(new int, x.x.x((5), x(5, "totor"))) ; x*while 5 do 5 ; if 5 then 5 ; "totor" end
let class x {var x := 5}  in end
x[break][x.x()][while int [break] of "totor" do int [break] of ()][int {} ] := new int
var x := let  in 5 end
function x(x : int) = if () then break else ()|for x := "totor" to break do break function x(x : int) : int = let  in end
function x(x : int, x : int) = let  in 5 end/if 5 then 5 else break
new int&x.x[int {x = ()} ]/x["totor"].x.x()
x()
class x extends int {var x := 5 var x := 5} 
new int
function x(x : int) = if x := "totor" then int [()] of nil else new int type x = int
class x extends int {var x := 5} 
int {x = x(for x := if x(nil, 5) then int [nil] of "totor" to int {x = x.x(), x = break-nil}  do new int, x["totor"][x(5, ())].x()), x = x[()].x.x.x()} 
int {} 
type x = class extends int{var x := 5} type x = class {} var x := 5
int {x = x()} 
class x extends int {var x := 5 var x := 5} 
(while x[()] := x.x((), nil) do for x := x((), nil) to int {x = "totor", x = "totor"}  do int {x = break} )
x["totor"][x.x()].x[x[5][int {} ].x(int [x(5, ())] of x(break, nil), if 5 then 5 else nil-let  in end)]
x["totor"].x.x[let import "empty.tih" in end]
var x := let  in 5 end var x := break function x() : int = "totor"
class x {var x := 5} 
x[5].x[x(x(), new int)].x.x(x.x[x((), nil)].x := int [(())] of -for x := "totor" to "totor" do break, x[5][int ["totor"] of ()][x[nil] := int {x = nil, x = nil} ] := int [x-x.x()] of new int)
int {x = while while int {x = x.x(), x = int {x = (), x = 5} }  do x[5].x() do let import "empty.tih" var x := 5 in end, x = let class x {}  var x := 5 var x := 5 in let  in 5 end/x.x() end} 
class x extends int {var x := 5} 
x.x.x.x[x["totor"][if 5 then nil else ()] := x.x := let  in 5 end]
type x = class extends int{var x := 5} function x(x : int) : int = (5)
class x {var x := 5 var x := 5} 
type x = {x : int} function x(x : int) : int = (5)
class x {var x := 5} 
x.x[int {} ][x()].x
function x(x : int) : int = int {}  var x : int := 5 var x := 5
for x := let function x() = "totor" in if -"totor" then int {}  else int {}  end to new int do x[break].x.x.x(int {x = int [x()] of (5)} , x.x.x.x(let var x := 5 in end, int {x = break&()} ))
int {} 
var x : int := int {x = break, x = "totor"} 
class x {var x := 5 var x := 5}  function x(x : int) = (5) function x() : int = break
x.x.x[if int {}  then new int else -break].x := for x := let import "empty.tih" var x := 5 in end to x.x[x()].x(x[()], while let  in 5 end do (5)) do int {x = let var x := 5 in break ; 5 end, x = int {} } 
int {x = int {x = if x() then x(x.x(), x) else (() ; 5), x = int {x = if (5) then x} } , x = x()} 
x.x.x[x := ()/-break].x := x()
(int {} )
int {x = let var x := 5 var x := 5 var x := 5 in if new int then while () do () else int {}  end, x = -int [x[break] := (5)] of new int} 
new int
x(let var x := 5 import "empty.tih" var x := 5 in x["totor"] ; nil/() ; nil end, if x.x[for x := break to () do nil] := int {}  then int [(5 ; 5)] of let var x := 5 in () end)
int {} 
x[()].x[new int].x.x((int {x = if "totor" then "totor" else break, x = let  in 5 end}  ; let  in 5 end), int {} )
let function x(x : int) : int = x() type x = int in x(let var x := 5 in end, new int) end
x[5][int [nil] of "totor"].x[(-"totor" ; break)].x(int [int [x(if () then () else break, new int)] of (() ; 5)] of new int, x[()][int {x = nil, x = 5} ].x)
type x = array of int
class x {var x := 5}  class x extends int {var x := 5} 
function x(x : int, x : int) : int = let var x := 5 in nil end
class x extends int {var x := 5} 
type x = class extends int{var x := 5} function x(x : int) : int = let  in end
while x.x.x[x.x].x() do x()
x[break][if () then "totor" else nil][(5)][int {x = int [x.x("totor", 5)] of x.x()} ].x()
function x(x : int) = x["totor"].x()
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5} 
function x(x : int, x : int) = for x := (5) to int [()] of break do int {} 
new int
x.x.x[x[()] := if "totor" then nil].x
-x.x[int {} ].x.x()
(int {x = x((5), if nil then 5)} )
class x {var x := 5} 
function x(x : int, x : int) : int = x(-nil, new int) function x(x : int) = let  in end
let class x {var x := 5}  type x = int import "empty.tih" var x := 5 in if int {x = (5), x = int {x = break, x = nil} }  then x.x.x() ; while if break then () do x() end
x[5][let  in 5 end].x[-int {} ] := x()
let type x = int type x = int var x := 5 var x := 5 in x() ; -int {x = break}  end
let class x extends int {var x := 5}  in int {x = if -"totor" then x}  ; x[()].x(x.x(), x()) end
var x := x
int {x = new int, x = int {x = int {} } } 
function x(x : int, x : int) : int = (5) function x(x : int) : int = x.x(break, "totor")
(x(x(), x.x.x(new int, x.x(nil, "totor"))) ; let  in end-int {} )
function x(x : int) : int = int {x = while 5 do nil}  function x(x : int) : int = int {x = ()}  function x() : int = 5 import "empty.tih" var x := 5
var x := -break var x := nil function x() : int = "totor"
class x extends int {var x := 5} 
function x(x : int, x : int) : int = new int function x(x : int) : int = while break do 5
function x(x : int, x : int) = int {x = x.x()}  class x {var x := 5} 
if if x.x[int {x = break, x = "totor"} ] then x() else let import "empty.tih" var x := 5 in x() end then let function x() : int = break in x.x := (5) end
class x {var x := 5}  type x = array of int var x := 5
if int {x = x.x[if "totor" then break]}  then x.x.x+-x["totor"].x() else int {} 
function x(x : int) = x.x.x(-break, int {} ) class x {var x := 5} 
int {} 
int {x = if new int then if x[break].x() then x(x := break, while 5 do break) else while if () then () do for x := 5 to 5 do 5} 
var x : int := new int class x extends int {var x := 5}  type x = int var x := 5
if x[()][x.x()][x.x.x(x := 5, let  in 5 end)].x() then x(let var x := 5 in x.x() end, x.x[x])
class x extends int {var x := 5}  class x {var x := 5}  class x extends int {} 
x["totor"].x[("totor")][int {x = (5), x = int {x = x()} } ] := let var x := 5 var x := 5 in end|x.x.x.x(x[nil].x(x(), x()), new int)
type x = class extends int{var x := 5} function x(x : int) : int = let  in 5 end class x {} 
class x {var x := 5}  function x(x : int) = nil-nil var x := 5
int {x = x[()][if 5 then ()][x["totor"].x()].x()} 
int [x[()].x.x] of int {x = if int ["totor"] of 5 then int {x = "totor"} } /-let var x := 5 in end
function x(x : int) : int = int {x = if break then nil else 5, x = int {x = 5} }  class x {var x := 5} 
(x.x["totor"/break].x() ; x() ; for x := "totor" to nil do "totor")
if int {x = -int [x] of int {} , x = x.x[x := "totor"] := if int [5] of break then x.x(break, nil)}  then let import "empty.tih" var x := 5 in int {x = (), x = 5}  end+for x := x["totor"].x() to x[nil].x() do int [x.x(nil, 5)] of int {} 
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
function x(x : int, x : int) : int = if int {x = 5, x = nil}  then x := ()
int {} 
var x := for x := 5 to 5 do 5 class x {var x := 5}  class x extends int {} 
function x(x : int, x : int) = let var x := 5 in "totor" ; 5 end var x : int := () var x := 5 var x := 5
class x {var x := 5 var x := 5} 
int [int {x = -for x := x := break to if "totor" then () do if 5 then 5 else nil} ] of new int
var x : int := for x := () to "totor" do nil var x : int := break var x := 5
var x : int := x.x() function x(x : int) = x function x() = () import "empty.tih"
class x {var x := 5 var x := 5}  type x = class extends int{}
function x(x : int, x : int) = x.x.x(if break then "totor" else 5, -break)
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
function x(x : int) : int = x.x class x extends int {var x := 5} 
int {x = int {x = -x()} } 
(x[5][x].x() ; x.x := if break then "totor" else () ; if () then () ; break ; 5)
while x() do int {x = x[()].x.x(let var x := 5 in end, x[nil].x())} 
class x extends int {var x := 5 var x := 5} 
type x = class extends int{var x := 5}
function x(x : int) : int = x[()].x(x := break, let  in 5 end)
type x = {x : int} function x(x : int) : int = x("totor", ()) type x = int
class x {var x := 5} 
type x = array of int function x(x : int) = x("totor", nil)
type x = class {var x := 5}
function x(x : int, x : int) = x[nil] class x extends int {var x := 5} 
function x(x : int) : int = x.x class x {var x := 5} 
var x : int := int {}  class x extends int {var x := 5} 
int {x = x[break].x.x.x(let var x := 5 var x := 5 in end, x.x.x := -if () then () else ())} 
class x extends int {var x := 5} 
for x := x.x[(5)][int {x = let  in 5 end, x = if nil then () else "totor"} ] to new int do -x["totor"][int {} ].x()
class x {var x := 5}  var x := 5
let class x extends int {var x := 5}  in end
if for x := int [if ()/break then let  in end] of let var x := 5 in end to int {x = int {x = int {x = ()} } , x = -x(nil, nil)}  do if x[5] then x.x := for x := break to nil do nil then let class x extends int {}  in end else x(x.x.x := if while () do break then if break then nil else let  in end, int {} )
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int, x : int) = x() function x(x : int) : int = int [break] of () class x extends int {}  var x := 5 var x := 5
for x := int {x = x(), x = int [x.x(break, ())-int {x = nil, x = 5} ] of (() ; 5)}  to x() do x["totor"].x[let var x := 5 in end] := let var x := 5 var x := 5 in int {x = 5}  ; nil ; 5 end
for x := new int to x.x.x.x do if int {}  then -x[5] else -x(nil, "totor")|for x := int {x = nil}  to x do if break then break else 5
function x(x : int) : int = let var x := 5 in end
x.x.x.x.x.x()
-while new int do for x := x.x := int ["totor"] of break to while for x := break to 5 do () do x() do int {x = x(), x = x()} 
x[nil][x.x(nil, ())][for x := x := break to if nil then () do x.x(break, break)][x[break][int {} ].x(x+-5, x[nil])] := while (int ["totor"] of 5 ; nil) do x(int {x = 5|()} , if int [nil] of () then int {x = 5, x = ()} )
x[()].x[(5)][while let var x := 5 in "totor" ; 5 end do x.x := -break].x(x[()].x[let var x := 5 in () ; 5 end].x(x.x[if nil then "totor" else 5].x(x(), int {x = x.x()} ), x(x(int ["totor"] of nil, if 5 then nil), let var x := 5 in nil ; 5 end)), let var x := 5 in end-if int {x = for x := 5 to () do nil, x = while "totor" do ()}  then let var x := 5 in end else int {x = if 5 then "totor" else 5, x = if 5 then break else "totor"} )
function x(x : int) = int {x = x.x(nil, 5)}  var x := "totor" type x = int var x := 5
class x {var x := 5 var x := 5} 
type x = array of int function x(x : int) : int = let  in end
function x(x : int, x : int) : int = x.x
class x {var x := 5} 
-x()
new int
function x(x : int, x : int) : int = while int {x = nil, x = break}  do let  in end class x extends int {var x := 5}  var x := 5
x[5].x[--nil].x
class x extends int {var x := 5 var x := 5} 
let class x extends int {var x := 5}  class x extends int {}  in end
class x {var x := 5 var x := 5} 
while let class x {}  import "empty.tih" in while int {x = break, x = break}  do if break then break else "totor" ; int [()] of () ; nil end do int {x = if x.x.x(int {x = 5, x = break} , for x := () to nil do "totor") then x[break].x() else x[()].x(), x = x.x[let  in end].x()} 
var x := x type x = array of int
function x(x : int, x : int) = x[nil] class x extends int {var x := 5}  var x := 5 import "empty.tih"
type x = int class x extends int {var x := 5} 
new int
function x(x : int) : int = let var x := 5 in end
let class x {var x := 5}  var x := 5 var x := 5 var x := 5 in end
x()
x()
x()
if x() then while int [int {x = x.x()} ] of while break&"totor" do if break then "totor" do x[5][int {} ]
let class x {var x := 5}  function x() : int = "totor" in let import "empty.tih" in if break then break end end
let type x = int var x := 5 import "empty.tih" in end
function x(x : int, x : int) : int = -x()
class x extends int {var x := 5} 
x(x["totor"][5+()].x.x(), if x(x[nil] := if () then break else nil, x[nil].x()) then let var x := 5 var x := 5 in x() ; break ; 5 end)
function x(x : int) : int = (())
x.x[x.x()][x(int {x = nil, x = ()} , while break do break)].x.x(x.x[while "totor" do break].x := x[5][x()].x(x.x := let  in end, let var x := 5 in end), let var x := 5 in end)
class x {var x := 5 var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) : int = new int
int [-int {x = if let  in end then if break then 5 else int [nil] of 5, x = x((5), int {x = "totor", x = 5} )} ] of int {} 
type x = array of int
var x := new int
type x = class {var x := 5} class x {var x := 5} 
function x(x : int) : int = if new int then (5) var x : int := "totor"
class x {var x := 5 var x := 5}  type x = array of int
let class x {var x := 5}  var x := 5 var x := 5 var x := 5 in -int {x = x.x("totor", 5)}  end
x[()].x.x.x(for x := if x.x() then if nil then "totor" else break else x(nil, ()) to int {x = "totor", x = ()} -x := 5 do if for x := 5 to 5 do () then for x := "totor" to break do () else x.x(), int [("totor" ; 5)] of if x.x(nil, nil) then new int else nil+break)*int [(for x := 5 to 5 do break)] of int {} 
function x(x : int) : int = let var x := 5 in end
let class x {}  in end|x[break][let  in end][while x.x() do let  in end]
int {x = int [int {} ] of int {} , x = for x := --x("totor", 5) to x[()][(5)].x() do x(new int, x[nil])} 
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
if if x.x[int [break] of ()].x() then int {}  else int [new int] of let var x := 5 in end then if let var x := 5 in (5) end then if x(int {} , x(break, nil)) then x(int {x = "totor", x = "totor"} , x((), break)) else x[5]["totor"*nil] := x.x("totor", nil)-let  in 5 end else x[nil].x[int {x = x := ()} ].x(if x.x.x(-(), x.x()) then int {} , (x := 5 ; "totor" ; 5))
x(x(), while int {}  do int {x = x(), x = x()} )
function x(x : int) = ("totor" ; 5) var x := nil
x[5][int {} ].x[int {} ].x()
int [int {x = int {x = x[break] := x.x(), x = x()} , x = if int {}  then int [if "totor" then 5 else "totor"] of let  in 5 end} ] of x["totor"][new int].x.x()
for x := int {}  to x(x["totor"][x()], while x.x := while 5 do break do int {x = -()} ) do while int [x()] of (break) do x.x.x := x["totor"]
type x = class {var x := 5}
var x := for x := 5 to 5 do nil type x = class extends int{} class x {} 
(if int {x = (5), x = if () then nil}  then int {}  else let var x := 5 in 5 ; 5 end)
class x {var x := 5} 
x.x.x.x[if new int then let  in 5 end+-()&"totor"].x(int [if let var x := 5 in end then int {}  else let  in end|5|"totor"] of let import "empty.tih" in let  in end end, let function x() = "totor" var x := 5 var x := 5 in end)
function x(x : int, x : int) : int = int {} 
while x["totor"].x.x := int {x = x[nil].x(x := "totor", new int), x = x.x}  do int {} 
int [int {} ] of int {x = let var x := 5 in let  in 5 end ; "totor" end, x = for x := int {}  to int {}  do int {x = x.x(break, ()), x = -"totor"} } 
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  function x() = break import "empty.tih" var x := 5
new int/if while int {}  do int {}  then int [int {x = nil} ] of let  in end*x[5].x() else let var x := 5 in end
var x : int := x := ()
if x.x[int [()] of 5][(5)/int {x = "totor", x = 5} ] then x(while int {x = "totor"}  do -break&int {} , new int)
let class x extends int {var x := 5}  type x = int import "empty.tih" in end
class x {var x := 5} 
type x = {x : int} type x = class extends int{} var x := 5
function x(x : int) : int = x(int [()] of nil, x(break, "totor"))
function x(x : int, x : int) : int = x(int {} , if break then () else break) class x {var x := 5}  function x() : int = 5 var x := 5
-x.x[-()].x()*x[nil].x := x()*-x()
var x := new int
for x := int [x()] of (x) to new int do if x.x.x.x(x(), int {x = int {x = ()} , x = x()} ) then let import "empty.tih" var x := 5 in (5) end else int {x = x.x := new int, x = x.x} 
for x := for x := x.x.x := let var x := 5 in end to int [x.x := int {x = ()} ] of (5 ; 5) do (for x := "totor" to () do nil) to let function x() = () in x[()] := int {x = 5}  end do x(x.x.x.x(), int {} )
function x(x : int) = x() function x(x : int) : int = new int
type x = class {var x := 5} class x extends int {var x := 5} 
new int
int [if new int then x.x.x.x() else new int] of x()
x["totor"].x.x[x(let var x := 5 in break ; 5 end, int [let  in end] of let  in end)] := (int {x = x(break, 5)}  ; x(5, 5) ; break)
x()
function x(x : int, x : int) = x() class x {var x := 5} 
if while int {}  do if new int then x.x then -if x[nil].x((5), x()) then while for x := "totor" to () do nil do new int else if x[()][x((), break)].x() then x["totor"]["totor"-break] := x[break].x()
class x extends int {var x := 5}  class x {var x := 5}  function x() = () import "empty.tih" var x := 5
x()
let function x(x : int) = int {x = 5}  var x := 5 var x := 5 in end
x.x.x[int [new int] of x((), 5)][x(int [int {} ] of int {x = ()} , int [for x := 5 to "totor" do 5] of x.x())].x((x() ; if 5 then "totor" else 5), int [while let var x := 5 in 5 ; 5 end do let var x := 5 in end] of x())
while while let import "empty.tih" in 5*() ; 5 end do int {}  do x["totor"][new int][x()].x()
x(x(let var x := 5 var x := 5 in end, for x := x["totor"].x(int {x = 5, x = ()} , let  in 5 end) to x.x.x((5), x()) do let var x := 5 in end), x.x.x[let var x := 5 in end].x())
class x {var x := 5 var x := 5}  var x := 5 function x() : int = break
class x {var x := 5 var x := 5} 
x()*if x.x[let  in 5 end] := int [int {x = ()} ] of int {x = "totor", x = nil}  then x(x.x := -nil, for x := x := "totor" to x.x((), "totor") do new int) else x.x.x
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = let  in 5 end function x() = "totor" var x := 5 var x := 5
x.x.x[x[nil] := for x := () to "totor" do "totor"].x.x(if let import "empty.tih" var x := 5 in end then for x := new int to x.x(nil, 5) do int {} |x(new int, new int), if (int {} ) then --if "totor" then () else break)
function x(x : int, x : int) = for x := int {x = nil}  to x := nil do int {}  type x = array of int
int {} 
if x[break].x[for x := int {x = "totor", x = "totor"}  to int {x = break}  do x()].x(x[break][x.x()], (x(nil, nil) ; nil)) then x[nil].x[(nil)].x()
function x(x : int) : int = int {x = let  in end}  class x extends int {var x := 5}  type x = int var x := 5
x.x[x.x(break, "totor")].x[let var x := 5 in int {}  ; break end]
x()
var x : int := x("totor", nil)
(x(while x do int [nil] of nil, new int) ; let var x := 5 in end)
if for x := int {x = x(5|(), let  in end), x = (break ; 5)}  to for x := x.x := -() to x(new int, int [5] of "totor") do let var x := 5 in end do let var x := 5 var x := 5 in end then (x() ; x := "totor") else x()
let function x(x : int) = for x := break to "totor" do nil function x() : int = 5 in end
class x {var x := 5 var x := 5} 
int {} 
function x(x : int) : int = -x(break, nil) function x(x : int) : int = new int var x := 5 var x := 5 var x := 5
int {x = int {} } 
int {x = if int {}  then -let var x := 5 in break ; 5 end} 
int {x = x(if int {x = nil, x = ()} /int {}  then x(x(), if nil then 5) else x[break], (int {x = 5, x = "totor"}  ; 5))} 
function x(x : int) : int = for x := int {x = "totor", x = ()}  to let  in 5 end do int {} 
int [-if for x := x() to for x := () to 5 do () do while "totor" do 5 then while if () then nil else break do (5)] of if x.x["totor"*()] := -for x := "totor" to break do break then x[nil].x.x()
function x(x : int) : int = if x() then x.x() else let  in 5 end
var x := int {x = 5, x = "totor"} 
class x {var x := 5}  class x {var x := 5} 
x()
x.x.x.x[x(let var x := 5 in 5 ; 5 end, int {x = x(), x = while "totor" do break} )].x()
if if -int {x = int ["totor"] of "totor"}  then if int {x = x("totor", break)}  then (5 ; 5) else x.x then x.x[(5)][for x := x to if () then "totor" do if () then break] := int {} 
int {x = (x() ; break/"totor" ; 5)} 
x.x.x[while while nil do () do (5)][int {x = x.x, x = if int [nil] of nil then x} ]
function x(x : int, x : int) = int {x = x, x = while break do nil}  var x := "totor"
var x := x
function x(x : int) = if x := "totor" then x else x(nil, nil) type x = class {} type x = int
x[5].x[x.x].x := x()
function x(x : int) : int = x()
(x.x[if nil then 5 else break])
class x {var x := 5 var x := 5} 
if x["totor"][x()].x.x(x.x.x.x(x.x.x(), x.x.x(let  in end, for x := nil to break do break)), int {x = int {x = if "totor" then break, x = int [nil] of nil} , x = if int {}  then if 5 then nil else if nil then "totor"} ) then int [for x := int {x = if nil then "totor", x = (5)}  to new int do x/int {x = ()} ] of x[break][x].x()
class x {var x := 5} 
while x(((5) ; break), x(int {x = let  in 5 end} , if int [5] of () then x := break)) do x[5][x].x.x(let import "empty.tih" in end, (if () then "totor" else 5 ; "totor" ; 5))
if x[()][(5)][let var x := 5 in "totor" end].x() then let class x {}  import "empty.tih" in end else int [new int] of x()
function x(x : int) : int = if for x := 5 to () do "totor" then int {}  else int {} 
int {x = int {x = int {x = -x, x = new int} } , x = x["totor"].x[int {x = x := (), x = x} ]} 
if x(int {} , x()) then let type x = int import "empty.tih" in let var x := 5 in "totor" ; 5 end ; let  in end end
x.x[x.x()][if int {x = break, x = ()}  then int {x = break} ][new int].x(x.x[int [()] of nil][x[()].x(new int, for x := nil to () do "totor")], int {x = x.x[-nil].x()} )
x.x.x.x.x.x()
int {} 
function x(x : int, x : int) : int = x.x := int ["totor"] of () var x : int := nil function x() : int = nil import "empty.tih" var x := 5
x(int {} , if let import "empty.tih" in end then int {x = x[break].x()}  else x())
class x {var x := 5 var x := 5} 
new int
var x : int := int {x = nil, x = break} 
type x = class extends int{var x := 5}
int {x = int {x = let import "empty.tih" in end, x = while x[break] do let var x := 5 in end} , x = x((let  in 5 end), x(int {} , x.x := let  in end))} 
int {} 
class x extends int {var x := 5} 
new int
function x(x : int) = int {x = int [()] of break}  class x {var x := 5}  class x extends int {} 
function x(x : int, x : int) : int = let var x := 5 in end
x.x[new int].x.x := x[()][for x := 5 to "totor" do nil][x(x.x(), x)] := new int
-int [int [while (5) do x("totor", ())] of x()] of (new int)
function x(x : int) = let  in 5 end/int {x = 5} 
let function x(x : int) = x.x() in end
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = while 5 do nil function x() = nil var x := 5 var x := 5
function x(x : int, x : int) : int = -while "totor" do break class x {var x := 5} 
function x(x : int, x : int) : int = if x(5, "totor") then -5 else x type x = int
var x := if () then () else "totor" var x : int := break
function x(x : int) = for x := new int to (5) do if nil then () else 5 class x {var x := 5}  var x := 5 import "empty.tih" var x := 5
class x extends int {var x := 5}  var x := break
type x = class {var x := 5} var x := 5 type x = int
if (let var x := 5 in end ; if nil then ()) then x[nil].x.x.x(x(int {x = ()} &int {} , let var x := 5 in end), x())
let function x(x : int) : int = if nil then () var x := 5 in end
function x(x : int) : int = x.x.x() class x extends int {var x := 5}  class x extends int {}  import "empty.tih"
int {x = x.x.x.x.x(x[()].x := if (5) then int {x = ()}  else x.x(5, 5), let import "empty.tih" var x := 5 in let  in 5 end ; nil ; 5 end)} 
int {} 
(for x := (nil ; 5) to int {}  do if int {x = (), x = 5}  then for x := 5 to "totor" do nil else while 5 do 5)
function x(x : int) = int {x = "totor"|"totor"} 
int {x = x[()][x(nil, 5)][let var x := 5 in end] := for x := x.x.x() to int {x = while 5 do (), x = x := nil}  do if x.x((), break) then if () then 5 else 5 else x(5, ())} 
-while -let var x := 5 in "totor" ; 5 end do int {x = int {x = ()} } |x.x.x(if break then () else (), int {x = "totor"} )
let type x = int in int {x = int {x = while 5 do "totor", x = int [()] of nil} , x = x.x := let  in end}  end
x.x[int {x = "totor", x = ()} ].x[-x.x]
var x := let  in end
x.x.x[x()].x(if int [nil/()] of (5) then for x := int [5] of "totor" to x := () do x := nil else let var x := 5 in end, new int)-x[nil][while nil do break][new int].x(x.x.x.x(for x := if break then "totor" to x() do int ["totor"] of 5, let var x := 5 in end), x.x[while break do 5].x(x["totor"].x(), int {} +for x := 5 to () do nil))
var x : int := x := nil type x = array of int
int {x = int [x.x.x] of int {x = new int-(5), x = for x := for x := nil to break do 5 to 5/5 do x("totor", "totor")} } 
let function x(x : int) = if () then nil function x() = "totor" in end
x.x[x.x()].x.x.x(for x := x[5][int {} ] := -x to for x := while while break do break do while nil do nil to if while () do nil then int [break] of 5 do x.x.x(while 5 do (), int [()] of nil) do new int, if int {}  then int {x = -int {x = break} , x = for x := int [nil] of 5 to while break do nil do int [break] of 5}  else while int {}  do for x := x.x(5, break) to int {x = (), x = nil}  do let  in end)
function x(x : int, x : int) = -x := "totor" function x(x : int) : int = if nil then break
x()
int {x = let class x extends int {}  in end, x = int {} } 
x()
type x = class {var x := 5}
type x = {x : int}
function x(x : int, x : int) : int = x()
type x = {x : int} var x : int := () function x() : int = nil
class x {var x := 5 var x := 5} 
class x {var x := 5} 
type x = {x : int}
var x := ()-break
class x extends int {var x := 5} 
x.x[new int][--"totor"].x := int {} 
let function x(x : int) : int = "totor"/"totor" class x extends int {}  var x := 5 var x := 5 in x[break][x] end
function x(x : int) = x(while "totor" do break, if nil then 5 else break) class x extends int {var x := 5}  type x = int
int [int {x = new int, x = int {} } ] of x(int {x = x.x()} |x/x := 5, while while x.x() do int {x = "totor", x = break}  do x.x)
type x = class {var x := 5} function x(x : int) : int = x.x()
type x = int
x()
for x := if int {x = x := 5} *new int then if let var x := 5 in end then let var x := 5 in end else -while "totor" do nil|while "totor" do break to for x := x() to x[()][int {x = 5, x = 5} ] := while (5) do x do int {x = (nil), x = let var x := 5 in end}  do for x := let import "empty.tih" var x := 5 in int {}  ; nil ; 5 end to x["totor"].x := if new int then -break do -x.x
x["totor"].x.x[int [x.x.x(if break then 5 else break, let  in end)] of while x := nil do x(nil, break)].x(-let import "empty.tih" var x := 5 in end, int {x = --x := break} )
class x {var x := 5} 
if if int {x = ("totor" ; 5), x = let var x := 5 in end}  then if while x do let  in end then for x := x to int {x = break}  do x := break then x((x := 5 ; break ; 5), if let var x := 5 in end then x.x.x(if 5 then 5, if "totor" then nil else 5) else while x.x() do (5))
type x = int var x : int := "totor" var x := 5 var x := 5
function x(x : int, x : int) : int = if let  in end then x.x((), break) else for x := nil to "totor" do nil
function x(x : int, x : int) = x(int {x = 5, x = break} , (5))
let function x(x : int) : int = -5 class x extends int {}  var x := 5 var x := 5 in end
let type x = class extends int{} in int {x = let var x := 5 in end}  ; int [x := 5] of int {x = "totor", x = 5}  ; if break then () ; break end
x.x[x].x.x := let type x = int in x.x.x(x.x(nil, ()), -break) end
new int
class x {var x := 5} 
if x(if let var x := 5 in end then new int else x[nil].x(x := break, let  in 5 end), let var x := 5 in nil ; 5 end*while while "totor" do break do if () then 5) then int {x = int [for x := let  in 5 end to (5) do int {} ] of int {} , x = x.x[if () then ()]} 
-int {} 
class x extends int {var x := 5} 
type x = int function x(x : int) : int = new int
let type x = int in for x := x.x to new int do int {x = int {x = ()} , x = x.x((), ())}  ; let  in end/x(break, "totor") end
while x[nil][x][while x.x() do int [5] of ()] := x(while x("totor", nil) do ()/5, -while break do break) do while new int do let import "empty.tih" var x := 5 in end
var x := x.x() function x(x : int) = (5) function x() : int = ()
int {x = x()} 
x["totor"][if break then "totor"][let var x := 5 in 5 ; 5 end][if x[nil] := x.x("totor", "totor") then -let  in 5 end]
new int
x[5].x[x()].x
int {} 
if int {x = if let var x := 5 in break ; 5 end then x.x.x(if nil then nil, new int) else let var x := 5 in end}  then int {x = new int}  else (let var x := 5 in "totor" ; 5 end ; int {x = 5}  ; "totor" ; 5)
x[nil].x.x[int [x()] of let var x := 5 in end].x(for x := x[()][x].x(new int, (())) to int [x[()].x()] of (break) do -for x := if "totor" then "totor" else 5 to let  in end do -5, for x := (break|5 ; "totor" ; 5) to int {x = let var x := 5 in end, x = x(x(), int {} )}  do int [(() ; 5)] of x(int {} , x(break, 5)))
type x = class {var x := 5} type x = {} type x = int var x := 5 var x := 5
x[()][int {x = break} ][x.x.x()][let var x := 5 var x := 5 in int {x = break}  ; 5 ; 5 end].x()
type x = {x : int}
int {x = x.x.x.x, x = int {x = int [int {x = int {x = 5, x = "totor"} } ] of int {x = x := "totor"} , x = x()} } 
int {x = int {} , x = x(x.x[x()].x(), x.x[new int])} 
function x(x : int, x : int) : int = (nil)
var x := let  in 5 end
function x(x : int, x : int) : int = let var x := 5 in end
while int [-new int] of for x := x.x to x[nil] do x.x := x("totor", 5) do for x := (let  in 5 end ; "totor" ; 5) to x.x[()/nil].x(x(), x.x()-new int) do if -new int then int [let  in end] of let  in 5 end else while while 5 do "totor" do while break do 5
while x.x[()|()].x do if x.x[x].x() then if while if break then () else break do let  in 5 end then if x then x() else (5)
if let function x() = "totor" in end then while if let var x := 5 in end then x.x()|-break else if while nil do "totor" then break|() do new int else new int
x(int [let var x := 5 var x := 5 in end] of let var x := 5 var x := 5 in end, int {x = ("totor")&-x := nil, x = if (5) then x() else x.x()|int {x = x(), x = (5)} } )
class x extends int {var x := 5}  function x(x : int) : int = if "totor" then 5
function x(x : int, x : int) = x.x.x(int [()] of break, let  in end) var x := "totor"
let class x extends int {var x := 5}  function x() = () in end
function x(x : int, x : int) : int = int {x = x} 
function x(x : int, x : int) = x[nil] := x
type x = class extends int{var x := 5}
x[nil].x[int [new int] of new int][int [x()] of x()].x()
x[break][(5)][int {x = int {x = 5, x = break} } ].x.x()
var x : int := -5
int {} 
function x(x : int) : int = let  in end+let  in end var x : int := "totor" function x() = () import "empty.tih"
var x := int {x = break}  var x : int := 5 type x = int var x := 5 var x := 5
int {x = int {} , x = int {} } 
x()
function x(x : int, x : int) = new int class x extends int {var x := 5}  class x {}  var x := 5 var x := 5
let function x(x : int) : int = int [break] of () in int {}  ; x() ; for x := nil to nil do break ; "totor" ; 5 end
int {x = x.x.x[int {x = x()} ]} 
type x = class {var x := 5}
class x {var x := 5} 
x.x[x := 5][int {x = int {} } ][x[5].x.x(x["totor"] := x("totor", 5), x.x.x(x.x(), x.x((), "totor")))].x()
x[break][let  in 5 end].x[int {x = x[break].x(let  in 5 end, (5))} ].x()
x.x.x[int {x = int {x = "totor", x = 5} } ][for x := -nil&break to new int do x.x := x := ()] := if let var x := 5 in x() end then int {}  else int {x = x(int [5] of (), x.x("totor", 5)), x = for x := while () do "totor" to x do int {x = nil} } 
class x {var x := 5} 
int [x()] of x.x[x.x()][x := ()/x.x()]
var x : int := x.x(5, break)
int {x = (int {} )} 
class x {var x := 5} 
int {x = let function x() = () var x := 5 var x := 5 in int {x = int {} }  end} 
--let var x := 5 in end|x[break]-x[break] := new int
int {x = if int [if let  in 5 end then if "totor" then break] of x[nil].x(x(), x.x()) then int {x = int [x("totor", 5)] of int {x = 5} , x = if -break then x.x()} , x = let function x() : int = nil in end} 
let type x = {} in end
let type x = class extends int{} class x extends int {}  in end
function x(x : int, x : int) : int = if x := 5 then while "totor" do nil else x := 5
class x {var x := 5}  type x = int var x := 5 import "empty.tih"
x.x.x.x.x
var x := if nil then () else "totor" function x(x : int) : int = x.x() class x {}  import "empty.tih"
class x {var x := 5} 
var x := new int
type x = class {var x := 5}
x.x[let  in 5 end][int {x = let  in 5 end} ].x.x()
if new int then x[nil][int {x = (), x = break} ][x(x.x(), x := "totor")] else while int [x["totor"]] of (break) do if if int {x = nil, x = ()}  then let  in end then if "totor"-"totor" then x := break
type x = int function x(x : int) : int = while break do "totor"
class x {var x := 5 var x := 5} 
function x(x : int, x : int) : int = int {x = let  in 5 end, x = x.x()} 
x[()][(5)].x.x.x(let class x extends int {}  import "empty.tih" var x := 5 in end, int {x = -if nil-"totor" then x.x(5, "totor")} )
type x = class {var x := 5}
function x(x : int, x : int) : int = -x class x {var x := 5} 
int {} 
class x extends int {var x := 5 var x := 5}  var x := nil type x = int import "empty.tih"
let type x = class {} var x := 5 import "empty.tih" in let var x := 5 var x := 5 in new int end ; let var x := 5 in end ; let  in end end
function x(x : int) : int = x.x.x(-"totor", -()) function x(x : int) = for x := () to break do "totor" function x() : int = () var x := 5 var x := 5
type x = class extends int{var x := 5} class x extends int {var x := 5} 
if x.x.x := new int then let var x := 5 var x := 5 in end|int [x(x["totor"] := let  in 5 end, x.x := int [nil] of 5)] of int {x = int {x = x} , x = x(let  in end, new int)} 
type x = {x : int}
type x = int
function x(x : int, x : int) : int = x[()].x()
function x(x : int) = let var x := 5 in end class x {var x := 5}  function x() = 5
x[break].x[new int].x.x()
while x() do int {x = x(let var x := 5 in () ; 5 end, int [int {x = break, x = break} ] of for x := () to 5 do 5)} 
(x((nil ; 5), let var x := 5 in nil ; 5 end) ; if x then int {}  else new int)
function x(x : int, x : int) = let var x := 5 in end class x extends int {var x := 5} 
x[break][int {x = "totor"} ].x[while x() do (break ; 5)]
int {} 
x[nil].x.x[x.x[int {x = 5, x = 5} ] := if if nil then "totor" then for x := "totor" to 5 do ()].x(let class x extends int {}  var x := 5 var x := 5 in end, int {x = int {x = (() ; 5), x = x["totor"]} , x = x[nil][5+"totor"].x()} )
x(int {x = int {x = int {} } } , x[()][if "totor" then "totor" else "totor"].x.x())
function x(x : int) : int = int {x = x := "totor"} 
x[5].x.x[int {} ].x()
class x extends int {var x := 5 var x := 5} 
type x = int
-int [while new int do x[nil]] of x[()][x.x(break, 5)].x()
new int
x.x.x[(5 ; 5)].x.x(if x() then int [x()] of x.x.x() else for x := x.x.x(x := break, x()) to new int do x(x := nil, int [()] of break), int {x = (int {x = 5, x = "totor"}  ; () ; 5)} )
type x = array of int class x {var x := 5} 
x["totor"][x := ()][for x := x(5, ()) to x.x() do for x := () to nil do ()][x(x[break].x(), int [-5] of let  in end)] := x.x.x[x[()].x(int {} , if 5 then break)] := -x.x := new int
int {x = if x.x.x := x(x(nil, "totor"), x.x()) then if x[nil].x(x(5, "totor"), x := 5) then x.x.x() else x[()] := x.x("totor", nil) else int [int {} ] of x[5]} 
class x {var x := 5 var x := 5}  function x(x : int) : int = let  in 5 end class x {} 
class x {var x := 5}  var x := () function x() = ()
x()
if int {x = new int}  then if int {}  then while int {x = x()}  do x()
function x(x : int, x : int) = int {} 
var x := x class x {var x := 5}  type x = int import "empty.tih" var x := 5
function x(x : int, x : int) = x.x
-while (x() ; nil) do int {x = int {x = -5} , x = x(-(), if nil then nil)} 
class x {var x := 5 var x := 5}  function x(x : int) : int = for x := break to 5 do ()
class x {var x := 5 var x := 5}  var x := 5 function x() : int = nil var x := 5 var x := 5
for x := x[nil].x.x.x() to int [for x := int {x = x := ()}  to for x := (5) to while break do "totor" do int {x = "totor"}  do x.x := int [()] of break] of for x := x[()].x(break-(), for x := nil to 5 do 5) to while int [break] of break do x := break do x[break].x() do x()
function x(x : int) = x(x(), (5)) var x := () function x() = () import "empty.tih"
type x = class extends int{var x := 5}
x()
for x := x(x[()].x := int {x = new int, x = while 5 do 5} , x["totor"][int {x = 5} ].x()) to x.x.x[-int {x = (), x = "totor"} ] do x[()][let  in end].x.x()
(-int {}  ; x())
(x.x[int {x = 5, x = nil} ] := int {x = let  in 5 end} )
type x = class {var x := 5}
x.x[int {x = (), x = nil} ].x[(int {x = nil} )]
class x extends int {var x := 5}  var x : int := ()
x()
for x := if new int then for x := int [let  in end] of int {x = ()}  to if x.x((), 5) then break/nil else int [()] of break do for x := int {}  to while "totor" do break do x() else x() to x[break][new int].x()/for x := x.x.x() to x() do let var x := 5 in nil ; 5 end do -x.x[new int]
if int {x = x()}  then int [int {} ] of int {x = x[break].x(for x := () to "totor" do (), int {x = break, x = nil} ), x = x.x(nil, 5)&x()}  else let var x := 5 in end
x[break].x[if x.x(break, nil) then x := 5 else x((), 5)][int {x = x(), x = while int {}  do x.x(break, nil)} ]
while if int {x = let var x := 5 in 5 end}  then int {x = -x}  do if int {} -x(if () then "totor", break/nil) then let var x := 5 var x := 5 in (5) ; "totor" ; 5 end else (int {x = nil, x = 5}  ; () ; 5)
type x = int
-int {x = x[nil].x.x(), x = x[nil][int [5] of break].x(int {} , if x.x() then -break else int [5] of "totor")} 
function x(x : int, x : int) : int = x[5].x()
type x = int type x = {}
var x := nil/"totor" class x {var x := 5}  type x = int var x := 5
class x extends int {var x := 5 var x := 5} 
for x := while new int do for x := int {}  to x[5].x() do if x("totor", nil) then new int to for x := let var x := 5 in int {x = (), x = break}  end to while x() do int {x = new int, x = if nil then 5 else ()}  do x.x.x := let var x := 5 in break ; 5 end do new int
-if int {x = x[()] := for x := "totor" to 5 do "totor"}  then int [("totor" ; 5)] of x[nil]
type x = class {var x := 5}
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  function x() = () var x := 5
x.x[let  in 5 end].x[(x() ; break ; 5)]
function x(x : int, x : int) = while x := nil do int [break] of break
function x(x : int) = x(-5, if break then () else "totor") function x(x : int) = break*nil function x() = "totor" var x := 5 var x := 5
x(new int, while x["totor"].x.x() do for x := x.x.x() to if int {x = "totor", x = nil}  then int [break] of "totor" do x.x.x())
int {} 
int [int [x.x[(5)]] of int {} ] of let class x {}  in end
int {} 
function x(x : int) = if int {}  then x(nil, "totor") else if "totor" then nil function x(x : int) = -()
function x(x : int) : int = while if break then nil else () do x("totor", nil) class x extends int {var x := 5} 
x(x[nil][x.x(5, 5)].x.x(), int {x = x["totor"].x := x[()].x(x, -nil)} )
x["totor"].x.x[x.x.x.x()] := (new int)
new int
function x(x : int) : int = for x := x.x(5, 5) to x := 5 do "totor"/5
new int
class x {var x := 5} 
new int
function x(x : int) = int {x = if "totor" then 5, x = int {x = "totor"} } 
let function x(x : int) = if 5 then nil type x = int import "empty.tih" var x := 5 in end
function x(x : int) = while x(5, 5) do -()
let class x extends int {var x := 5}  function x() : int = 5 import "empty.tih" var x := 5 in end
let var x := 5 in end
type x = {x : int} type x = class {} var x := 5 var x := 5
int {x = x.x[for x := break to nil do "totor"].x.x(int {x = int {x = int {} } , x = (nil ; 5)} , for x := x() to x.x.x(nil|break, int {x = break, x = nil} ) do for x := () to "totor" do nil-x((), ())), x = let class x {}  var x := 5 in x(x, let  in end) ; int {}  end} 
type x = class {var x := 5}
x["totor"].x.x[let import "empty.tih" var x := 5 in new int end]
int {x = -x()} 
-int {x = let var x := 5 var x := 5 in end, x = if new int then x[5]} 
var x : int := let  in 5 end
type x = class {var x := 5} function x(x : int) : int = (5) var x := 5 var x := 5
function x(x : int) = x.x.x(-(), -())
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = let  in 5 end
class x {var x := 5 var x := 5}  function x(x : int) = 5*()
type x = class extends int{var x := 5} var x := 5 class x {}  import "empty.tih"
class x {var x := 5}  type x = class extends int{}
int {x = if for x := let var x := 5 in end to if int {x = "totor", x = nil}  then -"totor" do if while "totor" do break then if nil then "totor" else 5 else int {}  then int {x = int [x := ()] of let  in 5 end, x = x()} } 
type x = class extends int{var x := 5}
let class x extends int {var x := 5}  function x() : int = "totor" var x := 5 var x := 5 in end
type x = class extends int{var x := 5} class x {var x := 5} 
function x(x : int) = -5+() class x extends int {var x := 5}  class x extends int {}  var x := 5
x(let import "empty.tih" var x := 5 in int {}  ; nil end&int {x = let var x := 5 in nil ; 5 end} , for x := x.x.x to x.x[x.x(break, nil)] do let var x := 5 var x := 5 in end)
new int
int {} 
int [int [-new int] of int [x(int ["totor"] of 5, x)] of int {x = if () then nil} ] of -let var x := 5 in let  in 5 end end
function x(x : int, x : int) : int = (break ; 5)
var x := int [nil] of break
x.x[int {} ].x[(int [()] of break)]
if -x() then -let import "empty.tih" in for x := nil to nil do 5 ; nil ; 5 end
function x(x : int, x : int) : int = int {x = int {} , x = for x := nil to break do ()}  type x = {} function x() : int = 5
class x {var x := 5} 
class x extends int {var x := 5}  class x extends int {var x := 5} 
class x {var x := 5}  class x {var x := 5} 
(int {x = int {x = x.x()} , x = int {} } )
function x(x : int, x : int) : int = x() class x {var x := 5} 
-let function x() = () in new int end
class x {var x := 5 var x := 5} 
function x(x : int) = x() type x = array of int
type x = class {var x := 5} var x : int := 5 function x() = nil
if if new int/x.x.x() then if x() then x[()] else int {x = int {x = ()*break} }  then if (nil ; 5)*x[()].x() then (while () do "totor" ; "totor" ; 5)
var x : int := let  in end
function x(x : int, x : int) : int = int {x = "totor"} &int {}  type x = class {} var x := 5
int {x = for x := int {x = int {x = x} }  to for x := while if () then nil do x() to x.x.x(int {x = nil, x = "totor"} , new int) do int {x = x()}  do if int [let  in end] of (5) then x(let  in end, x := 5), x = x(int {} , int {x = int {} , x = x.x := int {x = nil, x = "totor"} } )} 
function x(x : int, x : int) = x[()].x(int [5] of 5, x)
while int {x = let var x := 5 var x := 5 in end}  do x.x[while 5 do "totor"].x := int {x = for x := (5) to for x := break to 5 do break do for x := 5 to () do 5, x = if 5 then 5 else ()/nil+"totor"} 
function x(x : int, x : int) = let var x := 5 in 5 ; 5 end class x extends int {var x := 5}  var x := 5
int {} 
for x := if if int {x = nil, x = break}  then while () do 5 then for x := if nil then break to int {x = 5}  do x := () else let var x := 5 in end*if x() then x[()] else int {x = new int}  to x[break].x[while int {}  do x(break, "totor")] do (-(5) ; let  in 5 end)
int {} 
function x(x : int, x : int) = int {x = int {} }  function x(x : int) : int = int {}  function x() : int = break var x := 5
class x {var x := 5 var x := 5}  class x {var x := 5} 
x[break].x[if if "totor" then "totor" then let  in 5 end else if 5 then break else break].x.x(int {} -x.x[x], int [(x ; break ; 5)] of int {} )
let var x := 5 in int {x = x := nil}  ; x end&int {x = x(), x = -x.x := for x := () to break do 5} 
new int&x[break].x[int {x = let  in end, x = new int} ].x()
var x : int := if () then "totor"
class x {var x := 5}  var x : int := "totor"
function x(x : int) : int = x(x(), while break do break)
x()
function x(x : int, x : int) = -let  in 5 end type x = class extends int{} function x() = 5
function x(x : int, x : int) : int = x(x, int {x = break, x = ()} )
int {x = if int [x[nil] := for x := break to break do ()] of while if "totor" then "totor" do int {}  then let import "empty.tih" in new int end else int [if x((), ()) then int {x = (), x = break} ] of (5 ; 5), x = for x := x.x.x := int [int {} ] of x() to while x((5), for x := break to nil do 5) do let var x := 5 in "totor" end do if x() then int {x = x.x(nil, nil)}  else int {} } 
class x extends int {var x := 5 var x := 5} 
x(int {} +int [let var x := 5 in end] of -(5), x(int {x = for x := "totor" to () do "totor", x = if break then nil} , let var x := 5 in end)|x.x[int {x = 5, x = 5} ])
var x : int := while nil do 5
if if int {}  then if x[nil] := x() then int {x = (), x = nil} /if break then 5 then let var x := 5 import "empty.tih" var x := 5 in end
class x {var x := 5 var x := 5}  var x : int := break
x[break].x.x[-int [5/5] of for x := break to nil do ()].x()
while x.x[x := ()][let var x := 5 in () end].x(while -let  in 5 end do x[5], (x := 5)) do int {x = x[5].x} 
function x(x : int, x : int) : int = x.x := if 5 then () else () function x(x : int) : int = break-"totor"
function x(x : int, x : int) : int = int [let  in 5 end] of break-()
x.x.x[x["totor"].x(new int, if 5 then () else nil)][x["totor"].x.x()] := int {x = x.x[x] := x.x.x()} 
int [x(let var x := 5 var x := 5 in end, x.x.x.x())] of int {x = (x())} 
if x.x[x.x()][(() ; 5)].x(int [int {} ] of new int, x.x[x((), break)].x(x(x.x(), int [nil] of 5), x[nil].x())) then int {} 
new int
class x {var x := 5 var x := 5} 
class x extends int {var x := 5} 
function x(x : int, x : int) : int = (break ; 5)
int {x = if int {x = for x := -break to int {}  do new int}  then int [x()] of let var x := 5 in nil ; 5 end else let import "empty.tih" var x := 5 in end, x = let var x := 5 in end} 
class x {var x := 5 var x := 5} 
x()
while while x[break].x.x() do let var x := 5 var x := 5 in end do (x[()].x() ; int {x = break, x = "totor"} )
int {x = int {x = int [while (5) do x.x("totor", 5)] of int {x = x.x((), break)} , x = let var x := 5 in end} , x = x[break].x[int {} ].x(-int {} , x())} 
class x {var x := 5} 
type x = {x : int} class x {var x := 5} 
type x = {x : int}
x()
int {x = int {x = while if x.x() then (5) do new int} } 
if if let import "empty.tih" in end then int {x = let var x := 5 in end, x = x[5] := x}  else -int {}  then int {x = int {} |x[nil].x(int [nil] of break, -nil), x = let var x := 5 var x := 5 in (5) ; 5 end} 
type x = class extends int{var x := 5}
-x["totor"][x][let var x := 5 in nil end].x()
function x(x : int, x : int) = -for x := "totor" to 5 do nil
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  class x {}  var x := 5 var x := 5
let class x {var x := 5}  class x {}  in end
(x[nil][-5].x(for x := if "totor" then () else nil to x.x() do (5), let var x := 5 in end) ; x.x)
while x[5].x.x(x[5] := x(break, ()), x["totor"].x(int {x = ()} , for x := "totor" to "totor" do nil)) do if x[break] then x["totor"].x(int {x = 5} , x) else x.x.x(if break then (), x.x())-x[5].x[int [-"totor"] of int {x = 5, x = break} ] := int {x = int [nil] of break} -int {x = x.x(break, 5), x = x(5, nil)} 
function x(x : int) : int = (5 ; 5) function x(x : int) = new int
x["totor"].x[int {x = x.x(), x = int {x = break, x = 5} } ].x.x(-(int {}  ; break), int [x()] of int {} )
class x {var x := 5} 
class x {var x := 5} 
type x = int class x extends int {var x := 5}  type x = int var x := 5 var x := 5
x()
-int {x = x(if x.x("totor", "totor") then (5), let var x := 5 in () end), x = for x := if x then let  in end else -"totor" to x.x do x.x.x("totor"-5, let  in 5 end)} 
int [if int {}  then -x[5] else for x := let var x := 5 in 5 end to x.x.x() do let var x := 5 in end] of x.x[(5)][x["totor"]].x(if x(int {x = 5} , for x := break to 5 do break) then x[break].x(if () then "totor", x(break, break)) else int [int {x = "totor", x = ()} ] of x.x(), let import "empty.tih" in end)
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() = nil
new int
var x : int := int {x = "totor", x = nil}  type x = {} type x = int import "empty.tih" var x := 5
class x extends int {var x := 5}  type x = array of int
x()
var x := int {x = "totor"}  class x {var x := 5} 
function x(x : int) = let var x := 5 in end
int [int {x = new int, x = -int {x = break} |x((), "totor")} ] of int {x = x.x&while ()*() do int {x = nil, x = "totor"} } 
var x : int := -break
type x = array of int class x {var x := 5}  class x extends int {}  import "empty.tih"
function x(x : int, x : int) : int = x[()]
class x {var x := 5 var x := 5} 
function x(x : int, x : int) = new int
type x = array of int
function x(x : int, x : int) : int = x()*if nil then 5
for x := while x(while int {x = break, x = "totor"}  do x.x(), let var x := 5 in break end) do if int {x = x := "totor", x = new int}  then -x := "totor" to (for x := let  in 5 end to ()&"totor" do (5) ; -nil ; 5) do while x.x.x do x.x.x.x()
class x extends int {var x := 5}  class x {var x := 5}  class x extends int {} 
for x := if if while int {}  do for x := 5 to "totor" do nil then x[()].x(int [break] of "totor", x.x("totor", ())) then x(int {x = while () do break, x = x := ()} , int {} ) else int {x = x.x, x = let var x := 5 in break end}  to int {x = x(let var x := 5 in break end, new int), x = let var x := 5 var x := 5 in end}  do if x.x := break/5 then x()*-let var x := 5 in end
function x(x : int) : int = if int {x = 5, x = "totor"}  then x.x(break, "totor")
x.x.x[--()].x.x()
x.x.x[let var x := 5 in nil ; 5 end].x
int {} 
class x {var x := 5} 
(x[nil][x := ()])
class x {var x := 5}  function x(x : int) : int = x := "totor" class x {} 
x.x[x.x()][if int {x = 5}  then -nil].x.x(let class x extends int {}  var x := 5 var x := 5 in end, x(x.x := let  in end, x[break] := x.x("totor", "totor"))*new int)
let function x(x : int) : int = if nil then break else () in if int {}  then if let  in end then x() ; x(let  in end, let  in end) end
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = int {} 
x.x.x[x.x := for x := break to () do nil].x := x[()].x.x := x[5].x
(let var x := 5 in int [nil] of () ; "totor" ; 5 end)
type x = class {var x := 5} class x {var x := 5}  class x {}  var x := 5
function x(x : int, x : int) : int = if if 5 then 5 else () then if () then nil else "totor" else 5*break
if if int {}  then x.x[for x := 5 to nil do ()].x(-(5), x()) else (int {x = ()}  ; ()) then x.x[x.x()][x()].x(int [int [x := break] of int [5] of break] of x.x, x[()][x(break, nil)].x(x(x(), (5)), int {} )) else x[5][for x := "totor" to () do break][-x]
class x {var x := 5}  class x extends int {var x := 5}  class x extends int {} 
if x[nil].x[-if () then () else 5] := let var x := 5 var x := 5 in end then x()
int {x = if x["totor"] := int [5] of 5|x.x.x(if "totor" then (), x.x()) then new int} 
x.x.x[("totor")][-new int].x()
int [x.x[int {x = ()} ][while if () then 5 else nil do x()].x()] of let var x := 5 in end
class x extends int {var x := 5 var x := 5}  var x := break function x() : int = nil
x[()][x := 5].x.x
let var x : int := nil in int {x = (5)*let  in 5 end, x = for x := ()&nil to int [()] of break do for x := 5 to nil do 5}  end
class x extends int {var x := 5 var x := 5}  type x = {}
x[5].x.x.x.x()
class x extends int {var x := 5}  class x {var x := 5}  function x() = ()
function x(x : int) = if x := 5 then new int function x(x : int) = while break do break
function x(x : int) : int = x.x.x(let  in 5 end, int [nil] of "totor") class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  type x = class extends int{} function x() = nil
x.x.x[let var x := 5 in 5 ; 5 end].x := x(x["totor"] := x.x(), while int {x = 5}  do break|5)-int {} 
function x(x : int) = x("totor"|(), x.x(nil, break)) function x(x : int) = let  in end
function x(x : int) = x(x := "totor", int [nil] of ())
let class x {var x := 5}  in x(for x := while 5 do 5 to new int do x := break, let var x := 5 in end) ; x[break] end
let class x {var x := 5}  in end
type x = class {var x := 5}
-x.x[let  in end][new int].x(x(int {x = x := break, x = x.x()} , if if nil then () then let  in end else int {x = ()} ), if let var x := 5 in "totor" ; 5 end then x.x.x(x.x((), break), x.x("totor", nil)) else int {} )
class x {var x := 5} 
while if x(let var x := 5 in end, int {x = x((), ())} ) then int {x = x()}  do x[5].x.x.x()
new int
x()
function x(x : int) : int = x[()].x(break&5, int {} ) type x = int function x() = break import "empty.tih"
let var x := break in new int ; x.x := x ; (5) ; () end
x[nil][x := nil][x(x(), for x := break to () do 5)].x.x()
x(while let var x := 5 var x := 5 in x.x() end do if new int then -int {}  else let var x := 5 in end, x.x["totor"*nil]*let import "empty.tih" in x() ; 5 ; 5 end)
type x = array of int
class x {var x := 5}  var x := break class x extends int {}  import "empty.tih" var x := 5
x.x.x[if int {}  then x(5, 5)][int {x = (())} ].x()
var x := x.x(break, break) var x := "totor" type x = int
int [let class x {}  in x.x end] of while x[5][let  in 5 end].x() do -if let  in end then -5
x.x.x.x[new int] := int {} 
x[nil][let  in end][int {x = let  in 5 end, x = x()} ][if int [let  in 5 end] of for x := nil to nil do 5 then if let  in 5 end then (5) else if () then break] := new int
function x(x : int) = while if 5 then "totor" else nil do (5) function x(x : int) : int = x.x() function x() = nil var x := 5 var x := 5
-x[()].x[break-break/int [nil] of 5].x(if if if nil then "totor" else break then (5) else x.x() then int [new int] of x := "totor" else while break|5 do let  in 5 end, let import "empty.tih" var x := 5 in end)
function x(x : int, x : int) = let var x := 5 in end type x = int
-let function x() : int = () in x.x.x() ; if break then break else nil ; "totor" end
(int {x = x[()] := let  in 5 end, x = -if "totor" then nil} )
if let class x {}  in int {} |let  in end end then int {x = new int} 
x(-x[nil].x.x(), let class x {}  var x := 5 var x := 5 in ("totor" ; 5) ; int ["totor"] of () end)
new int
class x {var x := 5 var x := 5} 
type x = array of int class x {var x := 5} 
new int
x["totor"].x[for x := int {}  to nil&"totor" do x := ()][x[nil].x.x(x("totor"&nil, int {} ), x.x)].x(int {} , let type x = int in -int {}  ; for x := nil to "totor" do nil end)
new int
var x := x() class x {var x := 5} 
new int
var x := if () then 5
var x := new int
function x(x : int, x : int) : int = x()
while x() do -int {x = let var x := 5 in end} 
let var x : int := 5 function x() = 5 import "empty.tih" in end
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
int [x[5].x[x.x := int {x = (), x = "totor"} ]] of x()
class x extends int {var x := 5 var x := 5} 
function x(x : int) = let var x := 5 in end
new int
x[break].x.x[x(x[()], x[()].x(x.x(), x))].x()
int {x = -(() ; 5)/x[break].x(int {x = (), x = "totor"} , int {x = "totor"} ), x = while if x.x.x() then let var x := 5 in end do while x(int {} , for x := break to () do nil) do int {x = let  in end} } 
int {} 
function x(x : int, x : int) : int = let var x := 5 in 5 end
function x(x : int, x : int) = x.x := if "totor" then nil var x := nil function x() : int = break
var x : int := if () then () else "totor" function x(x : int) = x := nil function x() = () import "empty.tih" var x := 5
if (x(x(), int {x = 5} ) ; int {}  ; ()) then for x := -x := () to x.x := if 5 then "totor" else "totor" do for x := x to while "totor" do () do let  in 5 end-int {x = if int [5] of () then int {x = "totor"} } 
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  class x extends int {}  import "empty.tih"
-x.x[x()].x(let var x := 5 in 5 end, int {x = x.x(), x = if nil then 5 else nil} )|x.x.x[x.x.x(while () do (), new int)].x()
while x[break].x[int {x = int [nil] of nil} ] do let class x {}  var x := 5 var x := 5 in end
-x[()][new int][x()]
x(x.x[5+nil].x.x(), let function x() : int = nil in x[nil].x() end)
function x(x : int) : int = if int {x = "totor"}  then int {x = nil}  else for x := "totor" to () do "totor" var x := "totor" function x() = nil
x[5][(5)][x(int {} , int {x = nil} )].x
while x(x(), if if let  in end then int {}  else new int then x[5].x() else x(let  in 5 end, new int)) do x[()][int [5] of break].x()+for x := int {}  to if for x := nil to () do 5 then x do x()
function x(x : int) : int = x[break] type x = {}
function x(x : int, x : int) : int = for x := int {x = 5, x = 5}  to x do let  in 5 end function x(x : int) : int = x class x {}  var x := 5 var x := 5
int {x = x[break][let  in 5 end][(break ; 5)]} 
-x.x := int {x = break} |x()&if (break) then for x := x.x("totor", nil) to x := nil do new int|x[()].x
new int
var x : int := x.x()
x.x.x[(nil ; 5)].x.x()
function x(x : int, x : int) = int {x = -5}  type x = class extends int{} class x {}  import "empty.tih" var x := 5
x["totor"].x.x.x.x()
function x(x : int, x : int) : int = x[5].x(let  in end, -"totor") type x = class {} function x() : int = 5
int [if -new int then x(let var x := 5 in nil end, x(x, x(5, break)))] of int {x = x.x[int {x = break, x = ()} ], x = for x := int [let  in 5 end] of int {x = 5, x = 5}  to int {}  do x(new int, let  in 5 end)} 
for x := for x := int {}  to x(let  in end|x.x(nil, 5), if () then 5/for x := () to break do "totor") do x() to x(x["totor"].x.x(), int [new int] of while "totor" do "totor"&for x := () to "totor" do ()) do if x(int {} , int {x = x.x((), 5), x = let  in 5 end} ) then -for x := let  in 5 end to x do for x := () to "totor" do nil else x.x[if () then break else 5].x(x.x.x(), let var x := 5 in 5 ; 5 end)
function x(x : int) = int {x = let  in 5 end, x = (5)}  var x := break
int {x = x(), x = int [int [-new int] of for x := let  in end to int {x = nil, x = 5}  do (5)] of x()} 
while x[break][for x := "totor" to nil do break].x := x["totor"][int {x = nil} ] := int {}  do int {x = let var x := 5 in end, x = for x := int [int [()] of break] of if () then () to if let  in 5 end then x.x() do int [int {} ] of x := nil} 
let class x extends int {var x := 5}  class x {}  var x := 5 in end
int {x = if if int {}  then int {x = x.x(), x = for x := nil to 5 do "totor"}  else -x := break then new int else int [for x := for x := "totor" to nil do 5 to if 5 then () do for x := break to break do break] of x[break] := x((), ()), x = if x() then int {}  else x[nil][x(break, break)]} 
x[break].x.x.x
class x {var x := 5} 
int {x = x["totor"][if nil then ()][if if 5 then "totor" else "totor" then let  in end else break*nil].x(-if "totor" then nil else break|5|break, let import "empty.tih" in end), x = x(while if "totor" then () else nil|new int do int {x = x, x = int {} } , int {} /int {x = ()} *x := "totor")} 
x[break].x.x[let import "empty.tih" var x := 5 in end]
function x(x : int, x : int) : int = if x := nil then int {}  else x.x() type x = {}
function x(x : int, x : int) : int = int {}  class x extends int {var x := 5}  class x {} 
int {} 
int {x = x.x.x+while while if "totor" then break do if 5 then nil else "totor" do if x.x(nil, ()) then int {} , x = int {x = x[nil][let  in 5 end].x(), x = if if x then ()*nil else x(break, ()) then if for x := nil to nil do break then 5&nil else x.x.x()} } 
x.x[int {x = nil} ].x.x.x(x[break][for x := break to "totor" do ()] := for x := if nil then nil else 5 to x do let  in end-x[break][int {x = "totor"} ], x())
new int|-x()
x[()][if () then nil else "totor"][int {x = x.x(break, ())} ][int {x = x(), x = let var x := 5 in "totor" ; 5 end} ] := x.x.x.x := let var x := 5 var x := 5 in end
class x extends int {var x := 5}  class x {var x := 5}  function x() = () import "empty.tih"
int {x = let function x() = "totor" var x := 5 var x := 5 in end, x = x[break].x[-"totor"|break] := int {x = x.x, x = -nil|new int} } 
int {x = x[nil][x((), nil)][x()].x(x[()].x.x(new int, x(int {} , x.x("totor", "totor"))), -x[nil] := int ["totor"] of 5)} 
class x {var x := 5} 
int {} 
if (x.x ; x) then new int
int {x = (for x := x := () to x.x() do int {x = nil, x = 5}  ; (5) ; nil)} 
let function x(x : int) = x := 5 in end
function x(x : int, x : int) : int = int [x.x("totor", ())] of x() class x {var x := 5}  var x := 5
function x(x : int) : int = x(new int, int [nil] of 5) function x(x : int) : int = int {x = break} 
var x : int := for x := "totor" to 5 do nil class x extends int {var x := 5}  class x extends int {} 
type x = {x : int} function x(x : int) = x(nil, ())
while x(int {x = x(), x = x.x} , x()+x[5].x()) do int {} 
var x : int := x := nil type x = int function x() : int = nil
function x(x : int) : int = int {} 
var x : int := int {x = ()} 
int {} 
x.x.x.x.x.x()
let class x extends int {var x := 5}  function x() : int = "totor" var x := 5 in end
function x(x : int, x : int) : int = x.x.x(int {x = nil} , while nil do "totor")
type x = class extends int{var x := 5}
if x(if x.x := if break then () else nil then if int {x = ()}  then if break then "totor" else new int, x[5].x) then int {x = for x := x[break].x(x.x(break, 5), if break then nil) to int {x = int ["totor"] of "totor"}  do while let  in end do while nil do (), x = x(x.x.x(-nil, for x := "totor" to nil do "totor"), (() ; 5))}  else int {x = int {x = while let  in end do int {} , x = x.x.x(x.x((), 5), if 5 then 5 else "totor")} } 
function x(x : int) = int {x = int {x = "totor"} }  var x : int := ()
var x := int {x = break}  var x : int := 5
function x(x : int) = for x := int {x = ()}  to if "totor" then () else () do -5 class x {var x := 5}  class x {} 
var x := x()
x()
x.x[5|nil].x.x := while x.x[int {x = (), x = nil} ].x(x(), -while break do nil) do x.x[int {x = nil, x = "totor"} ].x(x(), -x.x((), break))
let function x(x : int) = int {}  in end
type x = {x : int}
x["totor"].x[x()].x.x()
(int {x = x(), x = if if break then () then int {x = ()} } )
for x := if int {}  then int [if () then nil else ()] of x else x()-if () then break else ()/-int {x = x()}  to let type x = int var x := 5 in let var x := 5 in break end ; let  in end ; "totor" ; 5 end do x(x["totor"][int {x = break} ].x(x.x := while "totor" do 5, x[()].x()), x())
int {} 
let class x extends int {var x := 5}  in end
var x : int := x.x() type x = class extends int{}
class x {var x := 5}  class x extends int {var x := 5}  function x() : int = ()
int {} 
int {} 
int {x = int {x = new int, x = x[5].x.x(x[break].x(), while x := () do 5&nil)} , x = int [x[5][x.x()].x(x.x.x(), (5 ; 5))] of int {x = x(), x = int [if "totor" then 5] of int {x = ()} } } 
int [new int] of for x := x() to x.x do if while nil do () then for x := "totor" to () do () else if 5 then 5-int {} 
var x := new int function x(x : int) = x.x(nil, "totor") class x extends int {} 
var x : int := while "totor" do nil class x {var x := 5} 
x.x.x[int {x = (5), x = x := break} ].x := while --for x := break to break do "totor" do if int [(5)] of int {x = 5, x = break}  then x["totor"].x(x.x(), x)
function x(x : int, x : int) = if for x := break to nil do 5 then x(5, break) else x := "totor"
while if int {}  then x() do if x.x.x := int [int [nil] of break] of for x := break to nil do break then -x[()].x(if break then break else "totor", (5)) else int {x = while new int do x(break, 5)} 
type x = array of int
type x = {x : int}
int {x = let var x := 5 in if x() then int {}  else let  in 5 end ; (5) end, x = x.x.x.x.x(let var x := 5 in end*let var x := 5 in end, let import "empty.tih" in int [5] of "totor" end)} 
int [if x() then new int] of while int {} &x.x := x := nil do let var x := 5 var x := 5 in end
function x(x : int) : int = let var x := 5 in nil ; 5 end type x = class {}
x(int {x = if if x() then x.x(5, nil) else int {}  then for x := int {x = nil, x = nil}  to for x := "totor" to 5 do "totor" do (5) else if let  in 5 end then x := nil} , if int [while if "totor" then break do let  in end] of -x.x() then x(x(new int, while () do ()), while x(nil, nil) do if "totor" then 5) else int [int {x = x((), break)} ] of (5)|let  in 5 end)
function x(x : int, x : int) = x.x.x()
x.x.x[x()].x.x(x(x.x[-()], x.x[for x := 5 to 5 do break]), let class x {}  var x := 5 in end)
int {x = if new int then let import "empty.tih" var x := 5 in end, x = if (let  in 5 end) then int {}  else -while x := "totor" do "totor"-nil} 
class x {var x := 5 var x := 5}  function x(x : int) = x(break, 5)
function x(x : int) : int = new int
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
int {x = x((5), let var x := 5 in "totor" end), x = if while int {x = 5, x = nil}  do let  in end then (()) else x.x := x} /for x := x[5] := x := "totor"*while let  in 5 end do for x := () to nil do () to x[nil][int {} ].x() do let var x := 5 in end
function x(x : int, x : int) = let var x := 5 in nil end
class x {var x := 5} 
int {x = x.x.x.x} 
function x(x : int, x : int) : int = if int {}  then new int
let type x = int in end
class x extends int {var x := 5} 
function x(x : int, x : int) = x.x.x(x, int {x = nil, x = "totor"} )
function x(x : int, x : int) = let var x := 5 in 5 ; 5 end
let class x extends int {var x := 5}  function x() : int = nil import "empty.tih" var x := 5 in end
x()
function x(x : int, x : int) = -int [()] of () class x {var x := 5} 
class x extends int {var x := 5}  type x = int
x(int [x(for x := let  in 5 end to x := 5 do let  in end, x[nil] := (5))] of ((5) ; break ; 5), if new int then if int {}  then let var x := 5 in nil end else int [let  in 5 end] of if nil then ())
var x : int := int {}  function x(x : int) = x.x() function x() = break var x := 5 var x := 5
function x(x : int) : int = x(int {x = break, x = ()} , int {x = 5} ) function x(x : int) : int = if "totor" then () class x extends int {} 
class x {var x := 5} 
function x(x : int) : int = while x(break, ()) do x()
let function x(x : int) : int = "totor"+nil class x extends int {}  in x[nil].x.x(int {x = if 5 then nil, x = let  in 5 end} , x.x.x(int {x = ()} , new int)) ; let var x := 5 in end end
x(new int, --x())
int {x = x[break].x.x := if ("totor") then x() else x.x := x, x = x.x.x.x := if int {x = (5), x = if () then () else 5}  then -int {} } 
function x(x : int) = let var x := 5 in end
let import "empty.tih" var x := 5 in end&int {} |int [x.x.x.x(int [int ["totor"] of 5] of int [()] of break, -x := ())] of x(let var x := 5 in end, -int [()] of "totor")
let function x(x : int) = int {x = "totor", x = "totor"}  in end
class x {var x := 5 var x := 5}  class x {var x := 5}  class x extends int {}  import "empty.tih"
class x {var x := 5 var x := 5}  type x = array of int
for x := let function x() = break var x := 5 in int {x = (5)}  end to let var x := 5 import "empty.tih" in end do int {x = x[()].x.x(x[nil], x.x.x())} 
var x : int := let  in 5 end
int [(x.x() ; nil)] of int {} |int [((5))] of int {x = int [(5)] of x(), x = new int} 
class x {var x := 5}  class x {var x := 5} 
for x := x(while let var x := 5 in break ; 5 end do for x := x.x("totor", 5) to (5) do x, let import "empty.tih" in -break end) to int [for x := let var x := 5 in end to (() ; 5) do int {x = -nil} ] of x(for x := nil to "totor" do 5|-"totor", int {x = x.x()} ) do new int
int {x = x.x[int [break] of break][int [int [()] of break] of if "totor" then nil else break].x(), x = if int {x = x[()].x(()+(), if 5 then break else "totor")}  then ((5) ; "totor") else int {} } 
x[break][(5)][int {x = x, x = int {} } ].x.x()
-if new int then let var x := 5 var x := 5 in x := nil end else if int {} +let  in end then let var x := 5 in nil ; 5 end else x.x := break|"totor"
for x := let import "empty.tih" in end to x.x[x.x()] := x() do x[nil][x(5, break)].x()|let var x := 5 var x := 5 var x := 5 in while int {x = 5}  do int [break] of () ; nil&break ; "totor" end
function x(x : int, x : int) : int = while (5) do int {}  var x := break
x.x.x.x.x(x.x[x] := int {} , int {x = let var x := 5 in end} )&-while if x then let  in end do let var x := 5 in "totor" ; 5 end
x[nil].x[if new int then -break else x("totor", "totor")][int {x = int {x = new int, x = let  in 5 end} , x = int {} } ]
let var x := 5 import "empty.tih" var x := 5 in x := "totor"|let  in 5 end end&let class x {}  var x := 5 var x := 5 in end
function x(x : int, x : int) = x["totor"] := -5 function x(x : int) : int = int {} 
var x : int := int {}  class x extends int {var x := 5}  var x := 5
x.x.x.x[int {} ] := x[nil].x.x := -int {x = int {} , x = new int} 
x(x.x.x.x, if x(new int, x(x, if "totor" then "totor")) then x.x.x.x())
class x extends int {var x := 5} 
type x = {x : int}
type x = {x : int}
x()
x.x[x()].x[x(if x.x() then while () do nil else x(), x.x.x(if nil then "totor", let  in 5 end))] := int {x = if int {x = x.x()}  then x.x.x(while "totor" do (), x) else x[()] := int {x = (), x = break} } 
while x[break].x[int [let  in end] of if "totor" then ()] do x[nil].x[let var x := 5 in end]
for x := x[5].x.x := (x := break) to new int do (-"totor"+nil)
class x {var x := 5 var x := 5} 
let var x : int := break in end
function x(x : int, x : int) = -new int type x = array of int
class x extends int {var x := 5 var x := 5} 
function x(x : int) = let var x := 5 in () end class x extends int {var x := 5}  var x := 5
class x {var x := 5 var x := 5} 
int {} 
var x : int := x var x := 5
x(new int, int {x = let import "empty.tih" in x.x(break, nil) ; 5 end, x = int {} } )
type x = {x : int} class x extends int {var x := 5} 
class x {var x := 5} 
function x(x : int, x : int) = int {x = x.x("totor", 5), x = while break do break}  class x {var x := 5} 
int {x = int {x = if int {}  then x.x.x() else int [new int] of for x := 5 to () do (), x = while x() do while -break do x()} } 
class x {var x := 5}  type x = class extends int{} var x := 5
function x(x : int) : int = for x := let  in 5 end to new int do x.x(nil, 5)
while let import "empty.tih" var x := 5 in end-int {x = int {} , x = int {x = for x := "totor" to 5 do "totor", x = new int} }  do for x := x[break].x.x() to let var x := 5 var x := 5 in nil+nil end do if -"totor"-int {}  then x.x.x() else if int {}  then x.x(nil, break) else -5
x[5].x[-x].x.x()
-x.x.x.x := int {} 
if int [(nil&nil)] of x() then -(5)/int {x = int {x = "totor"/"totor"} } 
let function x(x : int) = int ["totor"] of 5 in x["totor"][x.x("totor", 5)] := (5 ; 5) end
function x(x : int) = -x
function x(x : int, x : int) : int = int {x = ()*"totor", x = ()|nil} 
x.x[while "totor" do "totor"].x.x := new int
function x(x : int) = let var x := 5 in "totor" end type x = {}
type x = class extends int{var x := 5}
class x extends int {var x := 5 var x := 5} 
for x := x() to x() do int [x(int {} , x[nil].x())] of x.x.x.x(x(), int [-5] of if break then "totor")
new int
function x(x : int, x : int) = x[break].x((5), x.x("totor", break)) function x(x : int) = let  in 5 end
let function x(x : int) : int = for x := break to () do nil in end
class x {var x := 5 var x := 5}  function x(x : int) : int = x()
class x extends int {var x := 5}  class x {var x := 5} 
x.x[x][let var x := 5 in "totor" ; 5 end].x.x(-while while x.x((), ()) do let  in 5 end do x(let  in end, break+"totor"), let import "empty.tih" in x.x(break, nil) ; nil end+if x[()].x() then x())
type x = class extends int{var x := 5}
type x = array of int function x(x : int) : int = 5|break
function x(x : int, x : int) : int = x()
-if x[5].x then while if int [()] of break then nil&nil do int [-5] of (5) else if new int then let var x := 5 in nil ; 5 end else int {x = if nil then 5, x = int {} } 
(new int)/int {x = int [for x := int {x = nil}  to let  in end do let  in end] of x(for x := nil to nil do 5, int [5] of ())} 
class x {var x := 5 var x := 5}  function x(x : int) : int = x.x((), ()) class x {} 
let class x {var x := 5}  class x {}  import "empty.tih" in end
class x {var x := 5} 
x(x(), int {x = for x := int {}  to let var x := 5 in 5 ; 5 end do int {} } )
int [x[()][if break then nil else "totor"].x := int [x()] of x.x.x()] of for x := -while x((), ()) do while 5 do 5 to int {x = for x := int [nil] of () to if 5 then () do for x := () to break do 5}  do let import "empty.tih" in break*5 end
class x extends int {var x := 5 var x := 5} 
if if -x() then int [x.x := x.x("totor", "totor")] of if x then (5) else int [5] of "totor" else for x := x[5] := "totor"&5 to while int {}  do if break then nil do let var x := 5 in end then if while int {x = -()}  do for x := x.x() to 5|() do if () then nil then int {x = while let  in end do for x := break to 5 do ()} 
function x(x : int) : int = while () do break&x() function x(x : int) : int = x(break, ())
int {x = int {x = -x(let  in 5 end, int {x = break, x = nil} )} } 
for x := x()*let import "empty.tih" in while break do 5 ; 5 end to x.x.x[x["totor"].x(x := (), (5))].x() do x[break].x[for x := let  in 5 end to let  in end do x((), ())].x(int {} , if int {x = x()}  then if x.x((), "totor") then x else while int {x = ()}  do let  in 5 end)
x.x[(5)].x[int [-x.x()] of int {} ].x(-if x() then x[break].x((5), int {x = ()} ) else int {x = if "totor" then "totor", x = int [break] of "totor"} , x[nil].x[int {} |while 5 do nil] := let var x := 5 in end)
function x(x : int) = if x.x(nil, ()) then let  in end else x() type x = array of int
int {x = if x[5].x.x() then x[5].x.x()} 
type x = class {var x := 5}
if let class x extends int {}  import "empty.tih" in if x() then let  in 5 end else x end then let var x := 5 var x := 5 var x := 5 in end else int [int {x = x["totor"], x = (5 ; 5)} ] of x[()].x
-for x := x(x[break].x(), int {x = new int} ) to x(new int, let var x := 5 in () ; 5 end) do int {x = int {} } 
let function x(x : int) : int = if "totor" then 5 in end
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) = x[nil].x() function x(x : int) : int = (5) var x := 5
new int
class x extends int {var x := 5 var x := 5} 
type x = class {var x := 5}
x()
var x := int {}  function x(x : int) = (5) function x() = nil
class x {var x := 5 var x := 5} 
function x(x : int, x : int) : int = int {x = let  in end, x = int [break] of break}  class x extends int {var x := 5}  function x() = 5 var x := 5 var x := 5
function x(x : int, x : int) = if if break then 5 then let  in 5 end
var x : int := break|5 function x(x : int) : int = while nil do "totor"
function x(x : int, x : int) : int = ("totor") class x {var x := 5} 
let class x extends int {var x := 5}  in x[()].x end
x(x(), x.x.x&x.x.x := int {x = break+()} )
class x extends int {var x := 5} 
x.x[if break then break][x.x := for x := break to () do "totor"][x[()][int {x = nil, x = "totor"} ] := int {x = x} ].x()
class x extends int {var x := 5 var x := 5}  var x := nil
x[5].x.x.x := x(int {} , x["totor"][x.x()].x(-int [break] of nil, if int [5] of "totor" then x.x()))
function x(x : int, x : int) : int = int [x()] of -"totor" function x(x : int) : int = x(5, 5)
if int [int {x = x["totor"].x((5), int [5] of nil)} ] of let var x := 5 var x := 5 in end then while let var x := 5 in int {x = break, x = 5}  end do x["totor"][x].x(let var x := 5 in end, x[()].x()) else x()
x(int {x = x.x.x.x(x[break] := x(nil, "totor"), let var x := 5 in end)} , for x := -let var x := 5 in end to x.x[if nil then nil].x(if let  in 5 end then new int, x.x) do int {x = x} *x[()].x())
let type x = {} in end
if let function x() = break in end then for x := x.x to if x then new int do x.x.x(x.x((), "totor"), while () do ())-x.x.x.x(let var x := 5 in () ; 5 end, int [int {x = break, x = "totor"} ] of let  in end) else int [let var x := 5 in "totor" ; 5 end&x()] of if int {x = x()}  then int {x = ()} &x.x(break, ()) else x.x := x()
class x {var x := 5} 
x(x.x.x[int [x.x("totor", nil)] of let  in end].x(), for x := x[break].x := x() to let import "empty.tih" in end do let var x := 5 in (5) end)
int [x()] of if (int {x = break}  ; () ; 5) then let import "empty.tih" var x := 5 in end
function x(x : int) : int = int {x = x := nil} 
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
while let function x() : int = () in end do x(int {x = x(x.x(break, nil), x(nil, nil))} , for x := x() to int {}  do int {} )
x["totor"][x(5, nil)][let var x := 5 in end].x
int {x = int [new int] of int {} } 
x.x[if () then "totor" else ()].x.x := (-x(nil, break))
class x {var x := 5 var x := 5} 
x()
function x(x : int) : int = for x := x((), "totor") to int {x = break}  do int {x = 5, x = "totor"}  var x := break class x extends int {} 
x.x.x[let var x := 5 in "totor" ; 5 end][(x := break)].x()
class x {var x := 5} 
function x(x : int, x : int) : int = (() ; 5)
var x := x(5, 5)
x.x[x((), ())].x[x(new int, if new int then x else int {x = (), x = "totor"} )].x()
type x = array of int
var x := int [nil] of "totor" type x = class extends int{} var x := 5 import "empty.tih"
let type x = array of int function x() : int = "totor" import "empty.tih" in for x := int [if "totor" then "totor" else break] of x(nil, 5) to x["totor"] := x.x() do x.x := let  in end ; int [int {x = 5} ] of for x := "totor" to nil do "totor" end
function x(x : int) = x.x.x(-"totor", let  in 5 end) class x extends int {var x := 5}  function x() = nil
function x(x : int) = int [x.x(5, nil)] of x() class x extends int {var x := 5}  type x = int
new int
new int
class x {var x := 5} 
function x(x : int, x : int) = if int {x = "totor"}  then if nil then 5
type x = array of int
if x[break].x.x.x(let var x := 5 var x := 5 in end, int {} ) then int {x = x.x[nil&break], x = x.x.x := x[break].x()}  else new int
function x(x : int, x : int) : int = while int [nil] of "totor" do "totor"*5
var x := let  in 5 end
int {x = let type x = int var x := 5 in new int ; let  in end end, x = while while let var x := 5 in 5 end do x(int {} , int [nil] of break) do int {x = for x := ()-() to while () do break do x()} } 
x(if int [int {x = new int, x = x} ] of int {x = "totor", x = nil} &let  in end then (for x := () to nil do nil), if --x(5, 5) then let import "empty.tih" var x := 5 in end else x[break][x()].x(if new int then x := 5 else let  in 5 end, let var x := 5 in () ; 5 end))
let function x(x : int) : int = (5) in end
type x = class {var x := 5} function x(x : int) : int = int {x = "totor"}  function x() = nil
let function x(x : int) : int = x := "totor" var x := 5 import "empty.tih" var x := 5 in end
var x := ()&break
type x = class {var x := 5} class x extends int {var x := 5}  var x := 5 var x := 5 var x := 5
function x(x : int, x : int) = x.x.x() type x = array of int
var x := while "totor" do 5
x[break].x[x()][int {x = let var x := 5 in () end, x = if (5) then int [()] of 5} ].x()
function x(x : int) = x["totor"]
--int {} 
x[break].x[if x.x(5, 5) then x.x(break, nil)][if x(for x := "totor" to 5 do 5, x) then int {x = x(nil, ())} ].x()
x.x[if () then 5 else nil][while x do x.x()].x.x()
x(int [-int {} ] of x.x.x.x(x.x, x[()].x(x.x((), break), x(5, "totor"))), int {x = int [new int] of x.x.x(x.x(), x.x()), x = let import "empty.tih" var x := 5 in x.x() end} )
(new int)
type x = class {var x := 5} type x = int
x()
type x = class extends int{var x := 5} class x extends int {var x := 5} 
var x : int := (5)
if int {}  then x.x[let  in end][let var x := 5 in end].x(let import "empty.tih" in end, int [int {} ] of (5)*x["totor"].x(int {x = (), x = break} , int {x = 5} )) else x[break].x[if int {}  then if nil then 5].x(int {x = x.x} , new int)
type x = array of int
class x extends int {var x := 5 var x := 5} 
new int|x(-x.x.x(int {x = "totor", x = "totor"} , let  in 5 end), while (nil) do -int [break] of "totor")
(int [()&nil|x()] of if 5+() then int {x = nil} )
x["totor"][-5].x[int {} ].x()
for x := x.x[x(break, "totor")][int [nil] of nil*x.x("totor", nil)].x(int {x = x(), x = let var x := 5 in "totor" ; 5 end} , x[break][x("totor", 5)] := (() ; 5)) to x.x[for x := nil to "totor" do break] := -x&x[5][x(5, 5)] do int [x.x[nil+break]] of while int [x()] of x() do (())
let type x = int import "empty.tih" var x := 5 in end|-for x := (5) to x[nil].x(()&"totor", int [5] of ()) do x[break].x(let  in end, x)
-while x() do for x := (5) to let  in 5 end do x+int {x = x(nil, break), x = int {x = break, x = "totor"} } 
for x := x() to x(int {x = x[break] := int {x = break} } , while int [int [5] of "totor"] of while "totor" do 5 do x.x.x(x, x.x())) do while for x := x(nil, nil)-while 5 do 5 to while x() do if break then nil else 5 do x.x.x("totor"-"totor", x.x(break, ())) do int {x = int {x = int {x = 5, x = nil} , x = new int} } 
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  class x {} 
function x(x : int, x : int) : int = x[()].x() type x = {} class x {}  var x := 5 var x := 5
int [-int {x = x[break] := int {x = "totor"} , x = int [let  in end] of x := 5} ] of let type x = int in end
class x {var x := 5 var x := 5} 
function x(x : int, x : int) : int = x.x := x.x() function x(x : int) : int = -()
type x = class {var x := 5} function x(x : int) = int {} 
let function x(x : int) : int = x in end
function x(x : int, x : int) : int = x.x
new int
var x := new int
function x(x : int) = if x.x() then int {}  class x extends int {var x := 5}  class x {}  var x := 5
int {x = -int {x = x()} } 
class x extends int {var x := 5 var x := 5}  function x(x : int) = int {}  class x {} 
int {x = x()} 
x()
function x(x : int, x : int) : int = int {x = x(), x = if () then "totor" else 5}  function x(x : int) = x.x("totor", break) class x {} 
for x := -x[nil].x to int [x(int {x = break, x = break} +x("totor", break), new int)] of let var x := 5 in let  in 5 end end do (let var x := 5 in nil ; 5 end)
var x : int := for x := nil to 5 do break function x(x : int) = let  in 5 end
if let type x = int import "empty.tih" in let var x := 5 in "totor" ; 5 end end then int {}  else if if int {}  then "totor"&5*x := () then let var x := 5 in x.x() end
if -new int then x[5].x[-x()]
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
if let class x {}  in end then if int {}  then while int {x = nil, x = nil}  do int {x = ()} -let var x := 5 in () end else let var x := 5 var x := 5 in (5) end
function x(x : int, x : int) = x[()].x() function x(x : int) : int = x.x() class x {} 
x[break][()|break].x[let import "empty.tih" var x := 5 in end]
new int
let class x {var x := 5}  class x {}  import "empty.tih" var x := 5 in while let var x := 5 in end do x[()].x(x.x(nil, "totor"), int {} ) ; int {x = x(), x = int {} }  ; x() ; "totor" ; 5 end
var x := x() class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
x(x(), for x := x() to x.x() do x(nil, 5))*int {} &while int {} *int {x = x(break, 5), x = int {x = break, x = break} }  do x.x[(5)].x(for x := if () then break to if "totor" then "totor" do int {x = 5, x = 5} , if int [5] of nil then int {x = break, x = ()}  else if nil then () else "totor")
var x : int := int {} 
x.x.x[let var x := 5 in "totor" end][int [if x := () then x((), "totor")] of for x := let  in end to x := break do int {x = "totor"} ].x(int {x = new int} , (x[5] := while "totor" do nil))
class x {var x := 5} 
let class x extends int {var x := 5}  class x extends int {}  var x := 5 in x() ; for x := x to new int do if () then () ; int {}  ; () ; 5 end
var x : int := new int class x extends int {var x := 5}  class x {} 
type x = int
function x(x : int) : int = int {x = x(), x = let  in end} 
int [x(x.x.x.x(int {x = x.x()} , for x := int {}  to x.x((), 5) do x("totor", ())), int {} )] of int {} 
class x extends int {var x := 5}  function x(x : int) : int = x() function x() : int = 5 import "empty.tih" var x := 5
function x(x : int, x : int) = if x.x() then if nil then () else for x := nil to 5 do "totor"
let class x {var x := 5}  in end
class x extends int {var x := 5 var x := 5} 
while int {x = if x["totor"] then let var x := 5 in () end}  do x()
type x = {x : int} var x := 5 class x {}  var x := 5 var x := 5
function x(x : int) : int = x(x.x(), int [nil] of nil)
function x(x : int) = x[break] class x {var x := 5} 
type x = {x : int} class x {var x := 5} 
-x.x[x()].x.x(x(), x.x[int {x = break} ].x())
type x = int
type x = {x : int} var x : int := nil
var x := int {x = 5, x = nil}  class x extends int {var x := 5} 
-x(while x() do int [x.x()] of x(5, nil), -x.x.x())
x.x[x := break].x.x.x(let function x() = "totor" var x := 5 var x := 5 in end, x.x[while break do ()][x[()]].x(while if new int then x(break, nil) else (5) do x.x := x(), x[5].x.x(x.x := x((), "totor"), int {} )))
var x := x.x()
x()
x[break].x.x.x.x()
var x : int := int {x = ()}  function x(x : int) : int = nil|break
int [int {x = if while x() do new int then while (5) do x.x("totor", "totor") else x(x("totor", break), x.x(5, "totor")), x = x.x[let  in end].x()} ] of if (x() ; ()) then int {} 
x[()][x][(5)/let  in end].x := x[break][x()].x.x(let import "empty.tih" var x := 5 in end, --x.x((), nil))
class x {var x := 5}  function x(x : int) = if "totor" then () else () function x() = nil
int {x = int {} , x = (int [if () then "totor"] of if () then break else "totor" ; (5) ; 5 ; 5)} 
function x(x : int) : int = x[nil] := x((), 5)
x.x[if break then nil][int {x = nil&nil, x = int {x = 5} } ].x
x[5][x()][int {} ][(x.x() ; "totor" ; 5)]
int [x.x[x := ()].x] of int {x = (-break), x = x()} 
new int
int {} 
x.x.x.x[int [let var x := 5 in nil end] of x.x.x(let  in end, x.x(nil, 5))].x(x.x.x.x, let type x = int var x := 5 in for x := let  in 5 end to int {}  do if nil then 5 ; int {x = "totor", x = ()}  end)
class x extends int {var x := 5} 
-if for x := x[nil].x((5), (5)) to x[nil] := for x := nil to "totor" do () do int {x = int [break] of ()}  then int {} 
class x extends int {var x := 5} 
var x : int := while "totor" do "totor" var x : int := break function x() = "totor"
class x {var x := 5 var x := 5}  function x(x : int) : int = x.x("totor", ())
class x {var x := 5 var x := 5}  class x {var x := 5} 
(x.x.x.x(x[5].x(), if break then break else 5&for x := nil to 5 do ()) ; if while "totor" do "totor" then if 5 then 5 else nil else new int)
x.x[-break][while let  in end do int {} ][x[5][if "totor" then ()].x()] := int {x = int [let var x := 5 in "totor" ; 5 end] of x[nil].x(), x = x()} 
function x(x : int) = -let  in end
var x : int := x.x(nil, nil)
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5}  type x = class extends int{}
var x : int := x.x() class x extends int {var x := 5}  class x {} 
int {x = int [int [while x := () do break/nil] of while if 5 then break else break do let  in end] of for x := x.x := int {}  to let var x := 5 in end do int {} , x = int [int {} ] of while -int {}  do x["totor"] := x.x(nil, "totor")} 
x["totor"].x.x[(int [()] of "totor" ; nil)] := x[break][let  in end][new int]
x["totor"][for x := break to 5 do nil][x()] := x(int [x()] of let  in end, new int)&int [x(x[break], int {x = for x := () to 5 do 5} )] of x[()][if () then "totor"].x()
let class x {var x := 5}  in if int [let  in 5 end] of x((), break) then int [let  in end] of -"totor" else x.x.x(x(break, "totor"), ()+nil) end
var x := int [()] of "totor"
new int
type x = {x : int} var x := nil
class x extends int {var x := 5}  type x = {} type x = int import "empty.tih" var x := 5
new int
function x(x : int, x : int) = -int ["totor"] of 5 class x extends int {var x := 5} 
type x = class extends int{var x := 5} class x extends int {var x := 5}  class x {}  var x := 5
function x(x : int, x : int) : int = x["totor"].x() var x : int := "totor"
if if x.x.x.x(int {x = "totor"} -x.x(), (() ; 5)) then -for x := while break do nil to new int do if 5 then "totor" else x() then if x["totor"][-"totor"] then for x := x() to x() do ("totor" ; 5) else if int {x = (5), x = int {x = ()} }  then if nil/"totor" then let  in end else x := "totor" else let var x := 5 in "totor" ; 5 end
class x extends int {var x := 5}  class x {var x := 5} 
int {x = -if int {x = x := nil}  then if x(break, "totor") then 5|() else int [if break then "totor" else nil] of x, x = if x(x, int {x = (), x = 5} ) then x() else if -() then "totor"-nil&if x[break] := (5) then if for x := nil to nil do () then x(break, ()) else int [let  in 5 end] of -5} 
let function x(x : int) = new int in end
if x.x[int [break] of ()] then (for x := 5 to break do nil ; nil)&x[break].x[if int {}  then x else x := 5].x()
x()*int [int {x = 5/5} ] of x[()].x()*while new int do int {} +if int {}  then x()
new int
int {} 
function x(x : int, x : int) : int = int {x = let  in end}  function x(x : int) : int = if nil then 5 else "totor" class x extends int {} 
function x(x : int) = int [x.x()] of for x := "totor" to "totor" do nil
function x(x : int, x : int) : int = x(x.x(), x := 5) var x := () function x() = ()
class x extends int {var x := 5} 
type x = class extends int{var x := 5}
function x(x : int) = x()
type x = {x : int} function x(x : int) : int = (5) class x extends int {} 
function x(x : int, x : int) : int = x[break].x((5), int {} ) var x : int := nil
x[5][int [()] of 5][x[nil]].x.x(int {x = let var x := 5 var x := 5 in if () then "totor" end, x = x(new int, while new int do int {x = 5, x = 5} )} , for x := x.x.x(if nil then "totor", new int) to --nil do if if break then nil else () then int {x = (), x = 5} -if int {} +new int then int [x := break] of -break else x.x := x)
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  type x = int import "empty.tih" var x := 5
function x(x : int, x : int) = x[5].x(while nil do 5, if break then "totor" else 5)
type x = {x : int}
x()
class x {var x := 5 var x := 5}  function x(x : int) = x.x()
x()
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() : int = "totor"
class x {var x := 5} 
x["totor"][int {x = 5, x = nil} ].x.x.x()
let function x(x : int) : int = if () then () class x {}  var x := 5 var x := 5 in end
x()
type x = class {var x := 5}
var x : int := x.x((), break) var x := nil
function x(x : int) = x.x class x extends int {var x := 5}  var x := 5
x.x.x.x.x.x(int {x = int [if 5/5 then int {x = ()} ] of for x := new int to x := () do for x := 5 to "totor" do 5} , int {x = for x := int {}  to (5) do if 5 then nil, x = x["totor"] := int {x = "totor"} } *x[nil][let  in 5 end].x(x[()].x((5), x()), ("totor" ; 5)))
var x := x(nil, break)
var x := x
function x(x : int) = x.x class x {var x := 5} 
function x(x : int, x : int) : int = -x() class x {var x := 5}  function x() : int = 5
for x := x.x.x[-let  in 5 end].x() to int {}  do let function x() : int = "totor" var x := 5 var x := 5 in int {x = if 5 then (), x = -break}  end
class x {var x := 5}  function x(x : int) : int = ()+() function x() : int = break import "empty.tih"
var x : int := -"totor"
x[5][while nil do ()].x.x.x()
while x() do let function x() = nil in end
function x(x : int) : int = int {} 
class x {var x := 5 var x := 5} 
type x = {x : int} type x = int
function x(x : int) = x.x.x(int {x = 5} , let  in 5 end)
function x(x : int) = x.x.x() class x extends int {var x := 5} 
x.x.x[int {x = -5, x = x()} ].x.x()
type x = class extends int{var x := 5}
x(x(), for x := -x[()].x(break/break, int {x = break, x = 5} ) to if int {x = -nil, x = x.x(nil, 5)}  then x["totor"].x(x := break, x.x("totor", "totor")) do int [let var x := 5 in end] of if 5 then nil else "totor"&int {} )
if -x["totor"][let  in 5 end].x() then while if x then (5) else x()/int {x = if break then () else break}  do x[break][break+break].x()
class x extends int {var x := 5 var x := 5} 
let class x extends int {var x := 5}  in end
int {x = (while x := 5 do -"totor"), x = while for x := x[break].x(x(), int {x = (), x = 5} ) to int {x = int {x = "totor"} }  do int {x = new int, x = new int}  do let import "empty.tih" var x := 5 in end} 
class x extends int {var x := 5}  var x := break function x() = break
class x extends int {var x := 5 var x := 5} 
int {x = x.x.x.x()/("totor")*(5)} 
int {} 
type x = int
var x := x.x(nil, 5) var x := 5
while for x := x() to int {x = (()), x = x[5] := x()}  do int {}  do int {x = x.x[let  in end].x(x(), int {x = int {x = break} } )} 
function x(x : int, x : int) = x[5]
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = if () then () else () class x extends int {} 
x[break].x[for x := int {x = "totor", x = ()}  to int {}  do -()][x[5][x.x(nil, nil)].x()].x()
var x := x type x = {} function x() : int = ()
-for x := -if x then x(break, "totor") else x.x() to x() do int [int {x = x()} ] of x[()]
x.x[if break then break else "totor"].x.x := x()
for x := -x.x[x := nil] := int {x = new int, x = int {x = nil, x = ()} }  to new int do x.x[x.x()][x()] := -x.x(nil, break)*int ["totor"] of break
int {x = x(x.x.x.x(), x["totor"][x := ()].x(if for x := () to "totor" do break then let  in 5 end, int [for x := nil to break do 5] of x())), x = let function x() = 5 import "empty.tih" var x := 5 in (()) ; while 5 do () end} 
function x(x : int, x : int) : int = x.x.x(let  in 5 end, if nil then nil else "totor") class x {var x := 5} 
if int {x = for x := if for x := "totor" to break do () then if break then nil to int {x = int [nil] of "totor"}  do x.x}  then int {x = -x, x = x(while () do "totor", x := ())} *if new int then x["totor"].x() else while let  in end do x()
x[break].x[int {x = -break} ].x.x(x(), int {} )
class x {var x := 5}  class x extends int {var x := 5} 
x(let class x {}  var x := 5 in end, x[nil]["totor"-break].x)
x.x.x.x[new int] := x[nil][while 5 do nil][new int].x()
(-x[nil].x())
type x = class {var x := 5} function x(x : int) = while "totor" do ()
function x(x : int) = for x := x := () to x.x() do int [break] of 5
class x extends int {var x := 5} 
new int
int {x = x()} 
class x {var x := 5 var x := 5} 
-if x(int [for x := 5 to () do break] of new int, x("totor"*break, let  in end)) then x(x.x, if int [5] of "totor" then int {}  else int {x = "totor", x = "totor"} )
class x extends int {var x := 5}  class x extends int {var x := 5} 
if x.x[int {x = "totor"} ][let var x := 5 in () end] := new int*x.x then int {x = for x := if break then () else "totor" to x.x(break, "totor") do int {x = 5} , x = x()} /new int
x(x[nil][if break then break else nil][-while () do "totor"].x(), int {x = x[()].x, x = x()} )
var x := x := nil var x : int := ()
if int {x = x(int {x = int {x = break} , x = x(nil, break)} , if if 5 then () then new int else let  in 5 end)}  then x.x[let  in end][if x := 5 then int {}  else x := ()].x(if new int then x(), x()) else (let  in 5 end*new int)
let function x(x : int) : int = int [nil] of "totor" var x := 5 var x := 5 in end
function x(x : int) = (5)/if nil then break
class x extends int {var x := 5} 
int [if int [int [new int] of int [nil] of 5] of int [int [break] of break] of int {x = ()}  then x[5].x.x(-for x := 5 to () do "totor", int {x = for x := break to () do "totor"} )] of x[()][int {x = "totor"} ].x
class x extends int {var x := 5 var x := 5} 
x[break].x.x[int {} ].x()
function x(x : int) = -x()
class x {var x := 5 var x := 5} 
type x = array of int function x(x : int) = while break do () var x := 5
if if if x[break] := new int then x(x.x("totor", 5), int {} ) else ("totor" ; 5) then new int else (x() ; "totor") then x()
x()
if x(new int, int [x.x.x()] of x.x) then let type x = int in x() end
function x(x : int) : int = x.x := x(break, break) function x(x : int) = let  in 5 end
class x {var x := 5 var x := 5} 
for x := x.x[x()].x to int [let var x := 5 in end] of x[nil].x.x() do x.x.x.x
int {x = let type x = int in x[nil].x(int [5] of (), x := "totor") end, x = while int [int {x = "totor"} -x.x(break, nil)] of x(-break, x := ()) do int [x.x.x()] of new int} 
type x = class {var x := 5} var x := break
type x = {x : int}
(new int)
function x(x : int, x : int) = x.x()/(5)
class x extends int {var x := 5} 
if new int then -for x := int {}  to x(x((), break), if break then nil else 5) do if x(5, break) then int {x = break, x = 5} 
if x(if while 5 do break then while nil do break|("totor"), x(let var x := 5 in 5 ; 5 end, -for x := break to break do 5)) then int {x = x(while new int do break|"totor", x[nil].x(int [()] of break, new int)), x = if let var x := 5 in () ; 5 end then x[5].x(x(), if "totor" then break else break)} 
x[break][for x := "totor" to 5 do ()].x.x
x[nil][x.x()][x()][int [int {x = int {} } ] of -let  in 5 end]
while x[()][x := "totor"][x.x := if nil then "totor" else break] do int {x = x((break), if while () do nil then (5) else while () do "totor")} 
x[()][while 5 do break][for x := nil/nil to x() do int {} ].x
x[()].x[-if break then nil].x.x(if let var x := 5 in end then if int {x = int {x = ()} }  then let var x := 5 in "totor" end else let import "empty.tih" in int {x = nil, x = 5}  end, int {x = x.x.x := int {x = int {x = break} , x = int {x = nil, x = nil} } , x = int {} } )
function x(x : int) = x.x := x := "totor"
function x(x : int) = let var x := 5 in nil ; 5 end
if x[break][-"totor"][if int {x = nil, x = break}  then let  in 5 end].x() then if new int then x.x.x := int {x = x()} 
let function x(x : int) : int = (5) function x() : int = break var x := 5 in end
if if let import "empty.tih" var x := 5 in x := nil end then int {x = int {} , x = x[break]}  else int {x = x.x.x(), x = x(int {x = 5} , int {x = break, x = 5} )}  then x(int [(nil)] of int {} , (x := () ; ()))
-if int {x = if if () then () else () then if "totor" then nil else break else x.x(), x = new int}  then let var x := 5 in (5) end
if x(int {x = (5)} , (if break then ())) then new int else new int
class x {var x := 5 var x := 5} 
var x := -() class x extends int {var x := 5}  function x() : int = nil var x := 5 var x := 5
let class x {var x := 5}  class x extends int {}  import "empty.tih" in int {}  end
class x {var x := 5} 
-if x() then if x[break] := let  in end then x["totor"].x() else (nil ; 5) else let var x := 5 var x := 5 in let  in 5 end end
var x := x()
if int {}  then let var x := 5 in end else (("totor") ; x)
class x {var x := 5}  type x = {}
class x {var x := 5 var x := 5} 
class x {var x := 5}  function x(x : int) = (5)
x[()].x.x.x.x()
function x(x : int, x : int) : int = x.x type x = class {} class x extends int {}  var x := 5
new int
type x = class {var x := 5} var x : int := nil class x extends int {}  var x := 5 var x := 5
class x extends int {var x := 5 var x := 5}  function x(x : int) = (5)
while if x(x(-nil, break|break), x.x.x()) then -for x := while "totor" do 5 to x("totor", ()) do x := 5 do if (x("totor", nil)) then int [x[nil].x(x.x(), int {} )] of x() else new int
class x extends int {var x := 5 var x := 5}  function x(x : int) = if nil then () function x() = nil var x := 5 var x := 5
function x(x : int, x : int) : int = -int {x = "totor", x = nil}  class x {var x := 5} 
type x = {x : int} function x(x : int) = int {x = ()} 
function x(x : int, x : int) : int = if if 5 then break else () then if nil then () else nil
var x := x := nil var x := () function x() : int = ()
var x : int := x.x()
x.x[x("totor", 5)].x[int {x = x(), x = let var x := 5 in 5 end} ].x(int {x = let var x := 5 var x := 5 in int {x = 5}  ; nil end, x = int {x = int {x = let  in end} } } , int {x = x["totor"].x := if (5) then for x := () to () do break} )
class x {var x := 5} 
int {} 
x[break][int {x = nil, x = 5} ].x[while x() do -if "totor" then "totor"] := while int {x = if "totor"/break then -nil else new int}  do x["totor"].x := if x := nil then x := nil
class x extends int {var x := 5}  class x extends int {var x := 5} 
class x extends int {var x := 5} 
if x[5][x := 5][new int].x() then x[break].x.x.x(-x(if 5 then (), -break), (x ; () ; 5))
x.x[let  in 5 end].x.x.x()
class x extends int {var x := 5}  class x {var x := 5}  class x extends int {}  var x := 5 var x := 5
type x = int
x.x.x[let var x := 5 in "totor" end].x := for x := x(-x, x(for x := nil to break do (), x.x())) to x(x.x := x.x((), nil), -int {x = break, x = nil} ) do ("totor" ; 5)+int [for x := break to break do "totor"] of -"totor"
class x {var x := 5 var x := 5} 
let var x := 5 import "empty.tih" var x := 5 in end*new int
class x extends int {var x := 5} 
x[nil].x.x[x()] := int {x = int {} , x = x()} 
var x : int := if break then "totor"
while if break then ()+x.x(nil, nil)&("totor" ; 5) do int {x = x(int {} , int {x = break} ), x = while int [5] of "totor" do int {x = break} } *for x := x(x.x := int [()] of (), int {} ) to int {}  do -let var x := 5 in "totor" end
x.x.x.x.x := x[break].x.x
x["totor"][int {} ][for x := while () do break to x.x() do x := ()][let var x := 5 var x := 5 in x(nil, break) ; () end]
(int {x = if x then if () then break else break else new int, x = int {x = -break, x = int ["totor"] of 5} } )
x[break][x()].x[x(x["totor"], int {} )] := let function x() : int = break import "empty.tih" in for x := new int to int {x = break}  do let  in 5 end end
while for x := while let var x := 5 in "totor" ; 5 end do x[break].x() to x.x.x do let var x := 5 var x := 5 in end do for x := new int to x.x[x.x((), ())] := let var x := 5 in end do let import "empty.tih" in new int end
class x extends int {var x := 5}  type x = array of int var x := 5
(int {} )
x[nil][for x := "totor" to nil do ()].x[x.x.x] := x()
x()
x(int [x()] of while let var x := 5 in break ; 5 end do x[nil].x(while break do "totor", x.x((), break)), let class x {}  in x() end)
function x(x : int, x : int) = if int {}  then int {x = "totor", x = break}  class x {var x := 5}  var x := 5 var x := 5
x["totor"][let  in 5 end][let var x := 5 in end].x := -let import "empty.tih" var x := 5 in end
class x extends int {var x := 5 var x := 5} 
x.x.x[int {x = int {x = 5, x = break} , x = x := 5} ].x.x()
var x := int [nil] of nil type x = array of int
x[5][x((), nil)].x.x.x()
var x := ()/5
function x(x : int, x : int) = x[5].x(int {x = nil} , -break)
function x(x : int, x : int) : int = if x := nil then while () do nil else -() function x(x : int) : int = int [break] of 5
x[()][x].x[int {} ]
x()
class x extends int {var x := 5 var x := 5} 
x()
-int [let import "empty.tih" in end] of while if x() then while "totor" do () do x.x
var x := let  in 5 end var x : int := nil class x extends int {}  var x := 5 var x := 5
type x = array of int var x : int := ()
var x : int := x((), nil) type x = class {} function x() = "totor"
class x extends int {var x := 5 var x := 5}  var x : int := break function x() = break import "empty.tih" var x := 5
var x : int := break|break class x extends int {var x := 5}  var x := 5
x["totor"].x.x[let var x := 5 in end].x(x.x[let  in 5 end][x[break].x(int {x = nil, x = 5} , x.x())] := for x := x.x := x.x() to x[()].x() do int {x = -nil, x = x := "totor"} , while let var x := 5 in 5 ; 5 end-x.x.x() do -x.x := int {x = 5, x = break} )
-x.x.x[int [int [5] of break] of -()]
type x = class extends int{var x := 5}
class x extends int {var x := 5 var x := 5} 
int {x = while for x := int {x = int {x = "totor", x = nil} }  to x.x.x() do (5 ; 5) do while int ["totor"] of "totor"|while "totor" do 5 do x.x()|new int} 
int {} 
function x(x : int) : int = x(int [5] of (), int {x = break, x = nil} ) class x {var x := 5}  function x() = 5 import "empty.tih"
let class x extends int {var x := 5}  function x() = "totor" var x := 5 in end
function x(x : int) : int = let var x := 5 in end var x := nil function x() : int = 5 var x := 5 var x := 5
for x := -int {x = let var x := 5 in end}  to int {x = for x := x.x := x := break to let var x := 5 in end do int {x = x.x(5, ())} }  do x(x.x.x.x(x[()].x(let  in end, x := "totor"), int [for x := "totor" to () do break] of x.x(break, ())), int {x = let var x := 5 in "totor" ; 5 end, x = new int} )
class x {var x := 5 var x := 5} 
while new int do new int
var x : int := let  in end class x extends int {var x := 5}  class x {}  var x := 5 var x := 5
function x(x : int, x : int) = -int {x = break, x = 5}  type x = int function x() : int = nil
x.x.x[int [x((), break)] of int {} ][if ("totor") then int {x = int {x = (), x = "totor"} }  else x.x := while break do nil].x()
for x := x["totor"].x[let var x := 5 in end].x() to let type x = int var x := 5 in end do x[5][new int].x := x.x[-()].x()
if -x(x(), if int {x = break, x = break}  then while break do ()) then x.x.x.x
if if let import "empty.tih" in end then x.x[x] := x.x := x else -x|int [int {} ] of new int then (if int {x = nil}  then new int ; if "totor" then 5 ; ()) else -x.x.x.x()
((int {x = "totor", x = break} ) ; let var x := 5 in nil ; 5 end ; x() ; "totor" ; 5)
x(-let var x := 5 in 5+() ; "totor" end, -if int {x = if 5 then "totor" else break}  then int {x = while 5 do "totor"} )
var x := int {x = "totor", x = "totor"}  function x(x : int) = x
x.x[int {x = 5} ].x[let var x := 5 in int {}  ; "totor" ; 5 end] := if if nil then () else 5 then if break then "totor" else break else x := ()/for x := new int to x.x() do int {x = (), x = 5} |x.x&let var x := 5 in "totor" ; 5 end
int {x = (while let  in 5 end do (5) ; for x := break to () do "totor")} 
if x[()][int [5] of nil].x := int {x = int {} }  then for x := int {x = for x := int {x = break}  to int {x = 5, x = nil}  do -nil, x = x(x.x(break, break), x.x((), 5))}  to x[break][x := nil].x() do int {x = if int {}  then x, x = x(x := (), while nil do nil)} 
x(let function x() : int = 5 var x := 5 in end, int {x = if while x := nil do while nil do break then if x.x() then if break then "totor" else "totor" else if break then "totor" else "totor" else x["totor"], x = int [int [new int] of new int] of int {} } )
type x = int
let var x := "totor" in end
class x {var x := 5 var x := 5} 
class x extends int {var x := 5} 
while if ((5) ; 5) then int {x = if x(nil, nil) then x, x = int {} }  else x["totor"].x.x(x.x(nil, ())|new int, x(x := break, x)) do if (x := 5) then int {x = x[5].x((5), x())} 
type x = class {var x := 5}
function x(x : int) : int = int [x()] of x := "totor"
x.x.x[let var x := 5 in end]-x(while x() do for x := for x := nil to 5 do "totor" to (5) do x := 5, int [let var x := 5 in "totor" end] of if for x := "totor" to break do break then x else if 5 then "totor" else break)
class x {var x := 5}  function x(x : int) : int = if "totor" then "totor" else "totor" function x() = 5 var x := 5 var x := 5
type x = array of int function x(x : int) : int = if nil then nil else nil
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = int ["totor"] of "totor"
class x extends int {var x := 5} 
type x = class extends int{var x := 5} class x extends int {var x := 5}  function x() : int = break
x[()].x[int {x = 5/"totor"} ][x()].x()
if for x := int {x = int {x = 5} +let  in end}  to let var x := 5 in for x := break to nil do () end do let var x := 5 in end then int {x = int {x = (5)} , x = x.x()+5+"totor"} --int [let  in end] of (5) else int {x = -(break), x = let var x := 5 in end*x[5].x()} 
int {x = x.x[if () then 5 else 5].x, x = x.x[for x := break to () do ()][x.x.x()] := if (() ; 5) then let var x := 5 in () end} 
var x := let  in 5 end var x : int := nil
var x := x
x(new int, int {x = let import "empty.tih" in end} )
let function x(x : int) = int [()] of "totor" function x() : int = "totor" import "empty.tih" var x := 5 in end
function x(x : int) : int = int {} 
for x := int {x = -x()}  to x.x.x[int {x = int {} , x = x.x("totor", ())} ].x() do int {} 
int {x = x(x[5] := let  in end, let var x := 5 in nil end)} &int {} 
class x {var x := 5 var x := 5}  var x : int := break
class x {var x := 5 var x := 5} 
let type x = array of int in end
function x(x : int, x : int) : int = x.x.x(x.x(), x.x())
let type x = array of int var x := 5 in x.x.x.x(while for x := "totor" to nil do break do let  in 5 end, x&x(5, ())) ; x(let  in end, int {x = nil, x = 5} ) end
while new int do new int
type x = array of int type x = class extends int{} function x() = nil import "empty.tih" var x := 5
if int {}  then while x() do x()
let function x(x : int) = while nil do 5 function x() = () import "empty.tih" in x.x.x.x((() ; 5), while nil do break&x.x()) end
class x {var x := 5} 
x[5].x.x.x.x()
int {x = let class x extends int {}  in end, x = if x(x["totor"].x(if () then nil, new int), x.x.x(int [5] of nil, x())) then new int} 
type x = {x : int}
int {x = for x := int [int [x := break] of int ["totor"] of "totor"] of (() ; 5) to int {}  do int {x = x.x()&int {} , x = if x.x() then x() else x()} , x = let function x() = nil import "empty.tih" in let var x := 5 in end end} 
function x(x : int) : int = while int [5] of 5 do x.x(nil, "totor") function x(x : int) : int = while () do nil
let function x(x : int) = -"totor" var x := 5 import "empty.tih" in end
type x = class extends int{var x := 5}
var x : int := new int type x = class extends int{}
if while -x[()] := int {x = break, x = break}  do let import "empty.tih" var x := 5 in end then int [new int] of let var x := 5 in -break ; "totor" end
x[()].x[x["totor"]][let import "empty.tih" var x := 5 in int {}  end].x()
int {} 
int {x = int {x = for x := x.x := int {x = "totor"}  to x.x do x.x := nil-5, x = x.x[new int].x(x.x, if x.x() then ()+break)} , x = let type x = int import "empty.tih" var x := 5 in x() end} 
class x extends int {var x := 5}  class x {var x := 5} 
var x : int := x.x()
int [x[break].x.x] of x(if if x then (5) then x.x.x() else x := 5*x := (), x(x.x.x(if () then 5 else nil, while () do "totor"), x.x.x()))
(if int {}  then -() else nil&()+x[nil] := x := ())
new int
while for x := -x.x := if break then nil to if if -5 then for x := nil to "totor" do "totor" then let var x := 5 in end else (nil ; 5) do if x() then while (5) do int {x = break}  do x()
function x(x : int, x : int) = (5)|x.x()
function x(x : int) : int = let var x := 5 in "totor" ; 5 end function x(x : int) = x.x() function x() : int = 5
function x(x : int) = int {}  type x = array of int class x extends int {}  import "empty.tih" var x := 5
let var x : int := nil in x[5].x := int {x = int [()] of 5, x = x.x()}  end
function x(x : int, x : int) = if int {x = nil}  then x.x() else int [5] of ()
function x(x : int) = let var x := 5 in end
new int
function x(x : int, x : int) : int = if x.x(nil, ()) then for x := "totor" to break do 5 else "totor"/()
class x extends int {var x := 5 var x := 5} 
int {x = new int, x = for x := int {x = if if "totor" then "totor" else nil then x.x() else for x := 5 to "totor" do ()}  to while -if () then "totor" else 5 do let var x := 5 in end do int {x = if let  in 5 end then (5) else if "totor" then () else "totor", x = let var x := 5 in () end} } 
class x {var x := 5 var x := 5} 
if x.x.x.x.x(for x := -if 5 then "totor" to (5)+x do if break|"totor" then (5) else x, x[break].x) then let class x {}  var x := 5 in int [for x := "totor" to nil do break] of while 5 do 5 end else -x()
function x(x : int) = x[break] := let  in end
new int
function x(x : int, x : int) : int = let var x := 5 in end
function x(x : int, x : int) = while 5|nil do for x := break to "totor" do "totor"
-x.x[if 5 then "totor" else break].x
let type x = class {} class x {}  import "empty.tih" var x := 5 in x.x.x.x(x(x(nil, "totor"), "totor"&"totor"), if "totor" then ()+"totor"-()) end
x[()][-"totor"][x()|int {x = break} ][x()+int {x = new int, x = (5)} ]
type x = array of int
x.x[let  in 5 end][x.x.x(if () then nil, int [nil] of ())][-if x := nil then int {}  else x].x((x.x.x(int {x = "totor"} , if () then break else nil)), int {x = for x := if () then 5 else "totor" to let  in end do int {x = break} *new int, x = let import "empty.tih" in while "totor" do 5 end} )
function x(x : int, x : int) = int {x = int [nil] of nil} 
class x extends int {var x := 5}  class x extends int {var x := 5} 
-x()
class x {var x := 5}  var x : int := () function x() = 5
x["totor"].x[new int][x(x[nil], for x := if () then () to new int do int {x = "totor"} )]
if (int {x = x, x = x.x()} ) then int [x(int [break] of (), int {x = (), x = 5} )] of new int|x(x.x(), int {x = break, x = 5} )*(break) else x[()].x.x.x(let var x := 5 var x := 5 in int {x = break}  end, if x.x.x() then x.x := let  in end else let var x := 5 in end)
var x := let  in 5 end class x extends int {var x := 5} 
function x(x : int) : int = int {x = while 5 do break, x = x := ()} 
class x {var x := 5} 
function x(x : int) : int = x.x.x()
x(new int, x())
x()
function x(x : int, x : int) = -while 5 do 5 type x = int
function x(x : int, x : int) = for x := int {}  to break|nil do int {x = (), x = "totor"}  function x(x : int) = x := 5
x()
class x extends int {var x := 5 var x := 5}  var x : int := nil class x {}  var x := 5
class x extends int {var x := 5 var x := 5}  var x := 5 function x() = 5 import "empty.tih" var x := 5
int {x = int [x[break].x := x.x.x()] of int {x = int {x = let  in 5 end, x = if "totor" then 5 else "totor"} } } 
int {x = int {} } 
int {x = int {x = x[()], x = if (5) then -5 else int [break] of nil} } +(if break then () else 5+if nil then "totor" else ())
int {} 
x["totor"][x.x()][new int].x := -x.x[int ["totor"] of 5]
type x = array of int
function x(x : int) = let var x := 5 in end class x {var x := 5}  var x := 5 var x := 5
x.x[int {x = nil, x = 5} ][for x := let  in 5 end to for x := () to () do nil do for x := break to "totor" do "totor"][int {x = new int} ] := x[5].x[if -5 then int ["totor"] of nil else int {} ].x()
let var x : int := 5 class x {}  import "empty.tih" in end
var x := if () then 5 else nil class x {var x := 5}  function x() : int = nil
var x : int := while "totor" do "totor" function x(x : int) = int {x = break, x = ()}  function x() = 5
function x(x : int, x : int) : int = if int {x = (), x = break}  then 5&5 var x : int := nil
var x := 5+() class x extends int {var x := 5}  var x := 5 import "empty.tih"
x.x[while break do 5][if 5/() then let  in end].x.x(int {x = while x(5, ()) do for x := 5 to break do "totor"} /int {x = new int} , x.x.x.x.x(x(int {x = let  in end} , int [x.x()] of x()), x(if int ["totor"] of break then int {x = break, x = 5}  else -nil, while x(break, break) do int {x = nil, x = nil} )))
(let var x := 5 in end ; int {x = let  in 5 end, x = if "totor" then ()} )
int [if x[nil] then let var x := 5 in "totor" end else x.x.x(x.x(), int [5] of "totor")*x()] of new int
x(x.x.x[if x.x((), 5) then x.x(break, nil)] := let import "empty.tih" var x := 5 in end, let function x() = nil in end)
(int {x = new int} )
int {x = (let var x := 5 in end), x = -let var x := 5 var x := 5 in -break end} 
x(int {} , (if break then nil ; "totor" ; 5)*for x := x.x := new int to x(while "totor" do "totor", x.x(5, 5)) do int {x = (5), x = while break do break} )
x.x.x.x[x.x := if nil then "totor" else 5|int {x = 5/"totor", x = x(break, "totor")} ].x()
class x {var x := 5}  class x {var x := 5} 
function x(x : int, x : int) : int = while let  in 5 end do break/nil type x = class {}
x.x.x.x[x.x.x.x()].x()
for x := x() to x[break][x()].x.x() do if let import "empty.tih" in break-break ; () end then int [-x("totor", "totor")] of int [while "totor" do "totor"] of int {x = 5} 
var x := x() var x : int := () var x := 5
class x extends int {var x := 5} 
int {x = x(let import "empty.tih" in end, (if break then break else nil)), x = let function x() : int = () in end} 
class x extends int {var x := 5} 
x.x.x[x(int {x = "totor", x = nil} , x := 5)].x.x()
x(x(), int {} )
x()
x.x.x.x.x.x()
class x extends int {var x := 5} 
function x(x : int) = (break ; 5) class x extends int {var x := 5} 
var x := int [()] of "totor"
int [x.x[()+5][if 5 then nil else nil&while 5 do "totor"].x(x(), if x() then new int|int [()] of 5)] of let function x() : int = nil in (() ; 5) ; int {x = "totor"}  end
for x := -x["totor"].x to int [let import "empty.tih" var x := 5 in new int end] of x["totor"][let  in 5 end].x() do x()
class x {var x := 5} 
x.x[break*5].x.x
function x(x : int, x : int) : int = int {x = let  in end}  class x {var x := 5}  function x() = break
new int
if let import "empty.tih" in end then let import "empty.tih" var x := 5 in if () then "totor" else 5 end+x[break][int {x = 5} ][new int].x(((5) ; 5), x(x[()].x(x(), if 5 then "totor" else break), x(x := (), for x := nil to "totor" do break)))
(x.x.x.x(x["totor"].x(), int {x = x("totor", 5), x = while nil do nil} ))
function x(x : int, x : int) = if int {}  then for x := "totor" to break do break else x type x = array of int
var x : int := (5)
type x = class extends int{var x := 5} var x : int := () type x = int import "empty.tih" var x := 5
function x(x : int, x : int) : int = int {} 
-x[break].x[for x := if 5 then break else () to let  in 5 end do if () then "totor"].x(x(int {} , for x := let  in end to let  in end do x()), int [(nil ; 5)] of int {x = int {x = "totor"} , x = 5&break} )
function x(x : int, x : int) = x()
type x = class extends int{var x := 5} var x := ()
x(while int {}  do int {x = int {x = let  in 5 end, x = int {x = "totor"} } } , let class x extends int {}  in let var x := 5 in nil end end)
let function x(x : int) = x in end
if x.x[let  in end].x := x() then x[nil][int {x = (), x = 5} ].x else if (nil ; 5)+let var x := 5 in break ; 5 end then let var x := 5 in int {x = "totor", x = 5}  end else (x() ; break)
var x : int := x(break, nil)
class x {var x := 5 var x := 5}  function x(x : int) : int = if "totor" then "totor" else 5
x(x[break][int {x = break, x = 5} ][x(x, if nil then "totor" else 5)].x(), if x.x[int [nil] of "totor"] then let var x := 5 var x := 5 in end else int [x.x.x()] of x[()])
x[()][int {} ][let var x := 5 in end][x.x.x.x()] := if x[nil][let  in end].x() then -x.x.x()
(int [while int {x = 5, x = 5}  do int {} ] of let var x := 5 in nil end)
class x {var x := 5} 
x[nil][new int].x.x.x(if x.x.x.x(x.x := let  in end, int {} ) then x[()].x, new int)
function x(x : int) : int = -5+break type x = array of int class x {} 
-x.x[int {x = (), x = break} ][-let  in 5 end].x()
let var x := "totor" class x extends int {}  var x := 5 var x := 5 in end
int {x = new int-while int {x = "totor"}  do let  in 5 end/x.x.x := x(while nil do break, x := ()), x = let class x extends int {}  import "empty.tih" var x := 5 in x(if 5 then 5, int [5] of ()) ; let  in end end} 
for x := int {x = if -x("totor", nil) then while nil do ()-x.x(nil, break)}  to x(if ("totor") then for x := while nil do break to while 5 do () do x.x() else x.x.x("totor"|"totor", x()), int [for x := x := "totor" to if nil then () else break do (5)] of x(int {} , x(break, nil))) do (while int {}  do int {x = ()} )
x[break].x.x.x.x()
class x extends int {var x := 5 var x := 5} 
x(x.x[for x := break to break do "totor"][x[nil].x()].x(if int {}  then int {x = 5} *new int, int {} ), x())
function x(x : int) : int = int {x = if "totor" then break else "totor", x = if nil then break}  class x extends int {var x := 5}  function x() : int = nil
x[()][new int].x[x()].x()
class x {var x := 5} 
int {x = x.x.x[int {} ].x(x(while for x := () to break do "totor" do for x := nil to break do "totor", ("totor" ; 5)), let import "empty.tih" var x := 5 in if 5 then () end)} 
-int {x = for x := int {x = 5} *()|() to int {x = new int, x = int {x = nil} }  do if let  in end then while break do "totor"} 
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = x.x()
var x : int := x(nil, "totor")
type x = int class x {var x := 5}  function x() = break
class x extends int {var x := 5 var x := 5}  function x(x : int) = x.x(nil, ())
x[break].x[for x := x := break to int {x = break, x = ()}  do x.x((), break)][int {x = if (5) then int {x = ()}  else x.x((), break)} ].x()
x()
if while while while while break do "totor" do while nil do () do x(x, x()) do x.x.x then (int {x = int ["totor"] of 5}  ; let  in end) else let var x := 5 var x := 5 in x.x end
int [if x.x[int {x = nil, x = ()} ] := if (5) then x := 5 then while x[()] := int {x = ()}  do if x.x() then x.x((), ())] of -x.x.x
let function x(x : int) = let  in 5 end in end
class x {var x := 5 var x := 5}  type x = int
new int
var x := let  in end var x := 5
class x extends int {var x := 5 var x := 5}  function x(x : int) = if "totor" then 5 else 5
type x = {x : int} function x(x : int) : int = ()*break function x() : int = () import "empty.tih"
while int {x = x(), x = (x)}  do int {x = x(), x = (5)/x[nil].x(x.x(), int {x = 5} )} 
new int
class x extends int {var x := 5 var x := 5}  var x : int := break function x() = break
if while int [x.x.x()] of int {x = for x := nil to () do (), x = x()}  do while x.x do if break then () else nil&if nil then 5 then --(nil ; 5)
x.x[while nil do ()].x.x
var x : int := let  in end
int [x.x.x.x.x(if int {x = x := "totor"}  then if if 5 then break then int [()] of break else x.x((), ()), int {} )] of if x.x.x.x() then while x[break] := if 5 then nil do int [x.x()] of int {} 
var x := x
var x := x()
function x(x : int, x : int) : int = x[()].x(x(break, nil), (5)) class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5} 
for x := x.x[x := break][for x := x.x(5, break) to let  in 5 end do while () do break].x(int {x = int [x.x()] of for x := 5 to "totor" do break, x = while let  in end do if () then nil else break} , x()) to let var x := 5 in end do int {x = x(), x = x[()]["totor"-5]} 
for x := x.x[let  in 5 end].x() to int {x = x.x := if 5 then ()}  do int {} |x.x[x.x(nil, "totor")][int {x = x(), x = let  in end} ] := int [-x] of let var x := 5 in end
class x {var x := 5} 
function x(x : int) : int = if x() then if "totor" then break else 5
function x(x : int, x : int) : int = while if break then break do int {}  class x extends int {var x := 5}  type x = int import "empty.tih"
var x := int {x = ()} 
var x := for x := break to nil do nil
-while while let var x := 5 in end do if x := nil then x() do x.x[int [break] of 5]
class x {var x := 5 var x := 5}  function x(x : int) : int = int {x = 5, x = "totor"} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = if "totor" then "totor" else break
int [int {} ] of int [x(x(), int [()] of "totor")] of if while nil do break then x() else while break do break&x()
type x = class {var x := 5} type x = array of int
class x extends int {var x := 5} 
function x(x : int, x : int) = let var x := 5 in 5 ; 5 end
var x := while "totor" do break
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
if int {x = int {} }  then x.x[x.x()][x[()].x()] := int {x = (() ; 5), x = let var x := 5 in break ; 5 end} 
class x {var x := 5 var x := 5} 
var x : int := let  in 5 end
function x(x : int, x : int) : int = x.x class x extends int {var x := 5}  function x() = break
var x := new int
class x {var x := 5}  class x {var x := 5}  type x = int
int {x = x.x.x[let var x := 5 in 5 end] := int [x[break].x()] of int {x = x(), x = int {x = ()} } , x = for x := int [int {x = nil&break, x = new int} ] of if x.x("totor", 5) then int {x = "totor", x = "totor"}  else if "totor" then 5 to while for x := 5 to 5 do "totor"-let  in 5 end do int [x((), "totor")] of ()|5 do x[nil].x.x(int {x = x} , int {} )} 
function x(x : int) : int = x[()]
var x := int {x = 5, x = ()} 
function x(x : int, x : int) : int = -x := () function x(x : int) = x := "totor"
class x {var x := 5 var x := 5}  var x : int := 5
new int
for x := new int to if new int then x.x.x else x["totor"][x.x()].x() do let class x extends int {}  in end
class x extends int {var x := 5}  class x {var x := 5} 
int [x[break][for x := nil to break do "totor"][while if nil then () else nil do (5)].x(int {x = while (5) do int {x = "totor", x = break} , x = for x := int {}  to x.x(nil, 5) do let  in end} , -for x := if 5 then break else break to (5) do int {} )] of int [let import "empty.tih" in end] of while int {x = while 5 do break}  do if int {x = break}  then x.x() else x := "totor"
var x : int := x(nil, ())
int {x = int {x = let var x := 5 in x() ; 5 end} } 
x.x[int {x = nil} ][x(x.x(nil, nil), int {} )][(int [break] of 5 ; nil ; 5)].x(let class x {}  in --() end, let var x := 5 var x := 5 in end-x.x[x] := x())
new int
while while x.x.x := if let  in 5 end then let  in 5 end else int [nil] of "totor" do x["totor"].x := let var x := 5 in nil ; 5 end do if int {}  then (for x := break to () do ()) else -if let  in 5 end then int {x = ()}  else x := ()
class x {var x := 5 var x := 5}  class x {var x := 5}  type x = int var x := 5
x()
x.x[if 5 then 5][new int].x
type x = class {var x := 5} class x extends int {var x := 5} 
int {} 
while x.x[x()].x do x(if let var x := 5 in 5 end then int {x = for x := 5 to nil do "totor", x = x.x((), "totor")}  else x.x("totor", nil)&x(break, ()), x.x.x := if nil then 5/int {} )
function x(x : int) : int = int {x = int {} , x = if 5 then break}  class x {var x := 5} 
x.x.x[x((5), -"totor")].x.x(x(x(), new int), let var x := 5 var x := 5 var x := 5 in x[break].x(x, x.x(5, nil)) end)
var x := nil-()
function x(x : int) : int = int {x = x(5, break), x = -5}  class x extends int {var x := 5} 
var x := int {}  function x(x : int) : int = break&break
int [(x() ; int {x = nil, x = "totor"} )] of x.x.x[x[5] := let  in 5 end].x()
let type x = class {} function x() : int = nil import "empty.tih" in end
int {x = new int, x = -int {} } 
x.x[(5)][let var x := 5 in end].x.x()
let class x extends int {var x := 5}  in x[break].x.x(x.x.x(), new int) ; (nil ; 5) ; x ; 5 end
function x(x : int) = -let  in 5 end
function x(x : int, x : int) : int = let var x := 5 in "totor" ; 5 end function x(x : int) = while () do 5
function x(x : int, x : int) : int = if if () then break else "totor" then x.x(nil, 5) else if 5 then break
function x(x : int, x : int) = x.x.x()
function x(x : int) = int {x = x(nil, "totor"), x = int {} } 
function x(x : int) = if int [5] of () then x() class x {var x := 5} 
let class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5 in end
class x {var x := 5} 
for x := int [if let var x := 5 in end then new int else x(let  in 5 end, while nil do nil)] of if x.x.x() then int {x = ()/"totor"}  else int {x = (5), x = int {x = "totor", x = nil} }  to (int {}  ; x) do x()
var x : int := if 5 then nil else break function x(x : int) : int = int {x = break, x = "totor"}  class x {} 
let class x {var x := 5}  function x() : int = nil in end
function x(x : int) : int = (5)
let type x = int in end
while for x := x(x.x.x(while nil do nil, x), int [x := break] of if break then break else nil) to for x := int {}  to let var x := 5 in 5 end do int [if break then "totor" else ()] of let  in end do new int do new int
int {x = x()} 
-(int [for x := 5 to break do "totor"] of ()*() ; int {} )
x[5][for x := 5 to () do break].x.x.x(int {x = x()} , let type x = int import "empty.tih" var x := 5 in end)
x[break].x.x[int {x = int {x = x()} , x = let var x := 5 in end} ] := let class x extends int {}  in new int ; x.x(5, "totor") end
int [let function x() = () var x := 5 in x[nil] := if () then break else () end] of int [new int] of let import "empty.tih" in end
class x {var x := 5 var x := 5} 
-if int [new int] of int {x = ()&"totor"}  then x.x.x.x(int {x = x()} , if let  in end then let  in end else int {x = nil} ) else int {} 
x[break].x.x[for x := while x() do x() to int [x.x(5, nil)] of x.x() do while -nil do break|nil]
int [x["totor"][x.x()].x] of let type x = int in end
(x["totor"][new int] ; x[()] ; while () do "totor" ; () ; 5)
if while if x.x then new int else while (5) do (5) do new int then new int
var x := x := break type x = class extends int{} var x := 5
if new int then if int [x := 5] of int {x = (), x = nil}  then while -() do let  in end+int [x.x] of x.x.x(x(nil, "totor"), int {x = ()} ) else int [x.x["totor"*break] := x()] of x[nil].x.x()
class x extends int {var x := 5 var x := 5} 
int [new int] of x.x[x.x(5, 5)][(nil)].x(int {x = let var x := 5 in end, x = if int {x = 5, x = 5}  then x.x() else int {} } , x[break].x)
class x {var x := 5} 
function x(x : int) : int = let var x := 5 in break end class x extends int {var x := 5}  class x {} 
var x : int := x := 5
if int {}  then (int [x := nil] of new int ; int {x = break, x = "totor"} ) else x(x.x.x, x())
function x(x : int, x : int) : int = for x := x to let  in 5 end do int {x = nil, x = "totor"}  function x(x : int) : int = x.x() type x = int
x.x.x.x.x := int [if x.x.x() then for x := -() to if nil then break else nil do x()] of int [x(int [()] of nil, (5))] of if x.x((), nil) then int [nil] of 5
x.x[x.x()][while if () then "totor" else "totor" do x.x((), 5)][x[5][x()] := x()].x()
class x extends int {var x := 5 var x := 5}  type x = array of int
function x(x : int, x : int) : int = int [x(5, 5)] of -break function x(x : int) = (5) class x extends int {}  var x := 5 var x := 5
int {x = x.x[int [break] of ()].x.x(), x = new int} 
x[()][-nil].x.x
x[()][x()].x[int [new int] of int {x = x := 5, x = if nil then 5 else "totor"} ]
type x = array of int
function x(x : int) = new int
-while int {x = x, x = new int}  do int [for x := break to nil do break] of int {} -while x := nil do x.x(break, "totor")*-int {} 
for x := while x.x[x.x()] := x[5] do x() to x(x[nil][let  in 5 end], if ("totor" ; 5) then x[break]) do int {x = int {} , x = while x() do int {x = x.x(5, break)} } 
function x(x : int, x : int) = if int {x = 5, x = ()}  then x := 5
while x() do int {x = let var x := 5 in () ; 5 end} /-let var x := 5 var x := 5 in x(break, 5) ; () end
class x {var x := 5}  type x = array of int function x() = nil import "empty.tih" var x := 5
-x.x.x.x
class x {var x := 5 var x := 5} 
function x(x : int) = int [(5)] of break&nil function x(x : int) : int = int {x = "totor", x = break}  class x extends int {} 
x(x(), int [-let var x := 5 in end] of let import "empty.tih" in end)
type x = int class x extends int {var x := 5}  type x = int import "empty.tih" var x := 5
type x = array of int
function x(x : int, x : int) = int [if "totor" then break else 5] of for x := 5 to break do 5 type x = int
class x extends int {var x := 5 var x := 5}  var x : int := nil function x() : int = ()
class x {var x := 5} 
x.x.x[new int].x
var x : int := (5) function x(x : int) : int = let  in end type x = int import "empty.tih"
x.x.x.x[if while int [break] of 5 do let  in end then int {} ] := int {x = x[()][int {x = ()} ].x(), x = int {x = if (5) then (5)} } 
x(x.x[if () then nil else nil].x, int {} )
int {} 
function x(x : int) = x.x := (5)
class x {var x := 5} 
let var x : int := 5 function x() : int = "totor" in for x := int {}  to for x := x.x("totor", 5) to x.x((), "totor") do while break do "totor" do x.x.x(int {x = break} , int {} ) end
int {} 
if x[nil].x.x := new int then if int {x = if let  in end then x}  then int {x = int {x = new int, x = int {x = nil} } , x = -x.x(5, nil)}  else new int
function x(x : int) : int = if for x := () to 5 do "totor" then int [5] of nil else x.x(nil, break)
int {x = int {x = while for x := break to 5 do nil-(5) do x(if 5 then () else nil, if 5 then "totor"), x = int {} } } 
let function x(x : int) = int {}  in if x(-break, int {} ) then (() ; 5) else if int {x = ()}  then int {x = 5}  else break+5 ; int {x = new int, x = for x := "totor" to break do ()}  end
type x = int type x = class extends int{}
if let var x := 5 in for x := while 5 do nil to int {x = nil}  do int {x = "totor"}  ; let  in 5 end end then int {}  else int [x()] of for x := int {x = x, x = x}  to int {x = if () then "totor"}  do x(new int, x(break, "totor"))
int {} 
new int
x[nil].x.x[x(while let  in end do int [nil] of nil, int {x = new int} )].x((x[5].x()), x.x[x := nil][let var x := 5 in nil end].x())
function x(x : int) : int = if x.x() then x.x() else int {x = 5, x = 5}  class x extends int {var x := 5}  var x := 5
x.x[x()][if x.x() then int {}  else let  in 5 end][if for x := for x := break to "totor" do "totor" to let  in 5 end do x.x(nil, 5) then int [x := nil] of let  in 5 end else if x.x(nil, 5) then (5)]
function x(x : int) : int = int [int {x = break, x = break} ] of int {x = "totor", x = 5} 
if if x.x[int {} ].x(x[()], if let  in 5 end then (5)) then x.x.x.x(if if break then 5 else "totor" then new int else int [5] of "totor", int {} ) else for x := int {}  to if x.x(5, "totor") then let  in end else x() do x[break].x() then x[()][x.x()][x.x.x(if nil then nil else 5, (5))]
x(x.x[int {} ].x, (let var x := 5 in end))
for x := x.x.x[for x := int {x = nil, x = break}  to if 5 then break else nil do int ["totor"] of ()] to x[nil]["totor"*break].x := for x := x(for x := 5 to nil do nil, while () do ()) to (break ; 5) do if x.x() then x do let class x {}  var x := 5 var x := 5 in end
type x = class extends int{var x := 5}
while (-5&int {x = break} ) do let var x := 5 in while let  in end do if break then () else nil end
x.x.x.x[int {x = x[()], x = int [x] of for x := "totor" to () do ()} ] := int {} 
for x := x[nil][int {x = "totor", x = "totor"} ].x := x(if for x := break to break do 5 then int {}  else if "totor" then break else break, int {x = int {} , x = x()} ) to -x(int {x = x((), ()), x = int {} } , int {x = int [nil] of "totor"} ) do x.x.x.x
type x = {x : int} function x(x : int) = new int class x extends int {}  import "empty.tih" var x := 5
x()
let type x = {} var x := 5 in end
x.x[x].x.x(for x := if new int then int {}  to x := 5-x do let var x := 5 in break end, if x(x.x(), (5)) then x[()].x(x.x(), x := break) else -int {x = "totor"} )+if int {x = x.x.x(), x = -int {} }  then x(if x then -5, new int) else int {x = if x.x() then int {x = (), x = "totor"}  else int {x = "totor"} , x = let var x := 5 in break ; 5 end} 
while x(x.x[x].x(if int {}  then let  in end, x(x := (), x.x())), int [if int {x = 5, x = "totor"}  then x] of int [x()] of int {x = 5, x = 5} ) do while int {x = for x := (5) to let  in 5 end do let  in 5 end}  do int [if x.x() then int {x = nil, x = 5} ] of x[()].x()
class x {var x := 5}  class x extends int {var x := 5}  function x() : int = 5
var x : int := int [break] of "totor" type x = array of int
class x extends int {var x := 5 var x := 5} 
new int
function x(x : int, x : int) : int = if x then "totor"/"totor" var x := 5
new int
int {x = int [new int] of (for x := 5 to () do break ; nil), x = let var x := 5 import "empty.tih" in end} 
function x(x : int, x : int) : int = (5)
if if if x["totor"].x() then x() else let var x := 5 in end then for x := -while break do () to int {x = x((), break)}  do int [x(5, ())] of new int else (new int) then x[()][let  in 5 end].x
class x {var x := 5 var x := 5} 
if let type x = int var x := 5 var x := 5 in end then int {x = if x["totor"] then for x := let  in 5 end to int [nil] of 5 do x.x(), x = new int}  else int {} 
function x(x : int, x : int) = int {x = int {x = 5} } 
while x(x[break][let  in 5 end].x(x.x.x(), new int), while while x.x() do int {x = 5, x = ()}  do int {x = x.x(), x = x("totor", 5)} ) do int {x = x.x[if break then ()].x(x.x.x(), if int {x = ()}  then for x := break to break do () else if nil then break)} 
for x := if x.x[let  in end].x() then int {x = new int}  else x() to let var x := 5 in x.x ; int [5] of () ; 5 ; 5 end do x[5].x.x(x(int [()] of break, if nil then 5 else 5), new int)/new int
var x : int := let  in end
int {x = let function x() : int = "totor" in end, x = if x() then int {x = x.x.x(x(nil, 5), (5)), x = x.x}  else int {x = -while "totor" do break} } 
int {x = -let var x := 5 in end+-x[break].x((5), x.x(5, nil)), x = -int {x = x()} } 
var x := x(break, break)
var x := x("totor", break) class x extends int {var x := 5}  var x := 5
function x(x : int, x : int) = int {x = if nil then break else "totor"}  function x(x : int) : int = int [nil] of nil var x := 5 import "empty.tih"
class x extends int {var x := 5 var x := 5} 
x()
for x := x.x[x((), 5)].x.x(x(), x.x[x(break, nil)].x()) to int [let var x := 5 in x := nil end] of new int do if x.x.x then int {} 
x(let function x() : int = break import "empty.tih" in x(int {x = 5, x = nil} , x := break) ; x() ; "totor" ; 5 end, int {x = int {} } )
function x(x : int, x : int) = int {x = x.x()} 
x(for x := x[()][int {} ] to x[nil][x] do x["totor"][int {x = 5, x = break} ].x(), (x.x.x(let  in end, new int)))
(x["totor"][for x := 5 to break do ()].x())
function x(x : int) : int = x(x.x((), ()), x.x((), nil))
int {x = x.x[x(5, 5)][new int].x()} 
function x(x : int) = new int function x(x : int) = new int
let class x extends int {var x := 5}  in while x.x.x() do x[()].x(if 5 then "totor", int {x = (), x = "totor"} ) end
type x = class extends int{var x := 5}
var x := for x := nil to nil do nil function x(x : int) = while "totor" do "totor" var x := 5 import "empty.tih" var x := 5
class x extends int {var x := 5}  function x(x : int) : int = if () then nil else nil type x = int
new int
x[break][x].x[x.x[for x := nil to break do "totor"].x(let var x := 5 in break ; 5 end, let var x := 5 in "totor" end)] := x()
let function x() = () in end*x.x["totor"&()][int [for x := nil to 5 do "totor"] of ()/()]
if x(let var x := 5 in let  in 5 end end, -x(let  in 5 end, 5&break)) then int [-for x := int {}  to int {}  do "totor"/()] of x(x.x.x(), int {x = int {x = break} } ) else int {x = int {x = int {} , x = -for x := nil to 5 do ()} } 
var x := "totor"+5 var x := () type x = int
type x = class extends int{var x := 5}
-int [while int {x = "totor"} -break-nil do int {} ] of (let  in 5 end ; () ; 5)
if x[5].x then int {x = let var x := 5 in end}  else for x := x() to let var x := 5 in 5 end do x.x := x.x()+new int
class x extends int {var x := 5}  var x : int := break function x() = nil
while let class x extends int {}  in end do new int
class x extends int {var x := 5 var x := 5} 
function x(x : int) = int [if () then 5] of int {x = 5}  class x {var x := 5} 
function x(x : int) : int = int [if () then nil] of int {}  function x(x : int) : int = -nil type x = int
class x {var x := 5} 
if if int {x = x()}  then new int else int {}  then for x := x(-x(), new int) to (x := 5 ; () ; 5) do let var x := 5 var x := 5 in end
type x = class {var x := 5} type x = array of int
x[()][x].x[int {} ].x(-int {x = -if () then break, x = for x := (5) to if nil then () else "totor" do int ["totor"] of "totor"} , x.x.x.x.x(x(let var x := 5 in () end, if let  in 5 end then if break then 5 else 5), if x[nil].x() then for x := nil to "totor" do "totor"&while () do "totor"))
type x = class {var x := 5} type x = class {} class x extends int {} 
-int [x()] of let import "empty.tih" var x := 5 in end
x.x.x.x.x
int {x = if x[break][if () then ()].x() then x["totor"].x else let import "empty.tih" in let  in end end} 
if while for x := if while 5 do break then x else -() to (() ; 5) do int {x = int [5] of nil}  do let var x := 5 var x := 5 in end then x.x[(5)][-int {} ].x() else x(let var x := 5 in 5 ; 5 end+int {x = (5), x = new int} , x[()].x.x())
int {x = int {x = while let  in end do let  in end} &new int} 
class x {var x := 5} 
-let var x := 5 var x := 5 var x := 5 in end
x.x[for x := break to 5 do break][x.x].x()&new int
type x = class extends int{var x := 5}
function x(x : int) = let var x := 5 in end
x(let type x = int in end, if int {x = x[5]}  then x(for x := (5) to x.x((), "totor") do x(), x.x) else x.x[int {x = 5} ] := x[nil].x(x(break, 5), x()))
type x = class extends int{var x := 5}
function x(x : int) : int = new int
int {} 
class x extends int {var x := 5} 
x(for x := int [int {} ] of int {}  to if if int ["totor"] of "totor" then let  in end then int {} |while () do break do x(int {x = nil, x = "totor"} /x(), let var x := 5 in end), x((x := break ; "totor" ; 5), int {x = int {} , x = let var x := 5 in end} ))
int {x = x(x[5][for x := nil to "totor" do nil].x(), (new int ; () ; 5))} 
function x(x : int) : int = let var x := 5 in break end class x {var x := 5}  var x := 5
function x(x : int) = (nil) class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int, x : int) = int [if break then nil else ()] of while nil do nil class x {var x := 5}  type x = int
function x(x : int, x : int) = -let  in 5 end
var x := if () then 5 var x : int := nil class x extends int {}  import "empty.tih" var x := 5
var x : int := x := 5 class x extends int {var x := 5} 
function x(x : int) = int {x = x := nil, x = int {x = (), x = ()} }  type x = class extends int{} type x = int import "empty.tih" var x := 5
var x : int := let  in 5 end
class x {var x := 5}  var x : int := "totor"
class x {var x := 5}  function x(x : int) : int = new int
new int
function x(x : int, x : int) = x.x.x(for x := break to break do (), int {} ) class x {var x := 5} 
class x {var x := 5} 
x.x.x[x[nil].x()].x.x()
function x(x : int, x : int) = -x := nil function x(x : int) = new int
var x := for x := "totor" to () do ()
let function x(x : int) : int = -() in int {x = x.x, x = new int}  end
let function x(x : int) : int = int {x = "totor", x = break}  in end
while x(x(), new int) do x()*(-x.x("totor", ()))
var x : int := int [5] of "totor"
int [new int] of (-x.x("totor", nil) ; x(5, 5) ; "totor")
for x := int {x = -x, x = if int {x = "totor"}  then let  in end else if () then break else ()} *int {x = x.x.x(if break then "totor", let  in 5 end), x = x.x.x()}  to new int do int {} 
var x := new int type x = class {} class x extends int {}  import "empty.tih" var x := 5
function x(x : int) = x.x.x()
int [int {x = x.x[int [break] of nil].x(), x = if x()/-"totor" then x() else x+x := ()} ] of new int
if if (let  in end) then (-nil ; break ; 5) else int {x = let var x := 5 in end, x = int {} }  then int {x = x.x.x, x = new int&if (5) then let  in end}  else int {x = int {x = x.x := x := ()} , x = let var x := 5 in new int ; "totor" ; 5 end} 
function x(x : int) : int = int {x = let  in 5 end, x = int {x = ()} } 
var x := x()
function x(x : int, x : int) : int = int {x = int {x = break} , x = x(nil, ())}  type x = class {}
int {} 
x[()][5*"totor"][while int {}  do int ["totor"] of ()].x(new int, ((5) ; () ; 5))*x()
x[nil][x].x[x.x.x := x()].x()
x()
type x = class {var x := 5}
function x(x : int, x : int) : int = while if nil then 5 else break do new int class x {var x := 5} 
x.x[let  in end][new int].x.x()
class x {var x := 5} 
function x(x : int, x : int) : int = x.x.x() var x := "totor" function x() : int = ()
class x extends int {var x := 5} 
let type x = class {} in end
while for x := --() to int {x = while "totor" do break, x = if "totor" then break}  do x(let  in end, x := "totor")&(x.x(nil, 5)) do int {x = -x.x.x(int [break] of 5, x := "totor")} 
function x(x : int, x : int) : int = int {}  type x = int class x {} 
function x(x : int) = x[5]
while for x := int {}  to if x[()].x() then let var x := 5 in () ; 5 end do int {x = x()}  do for x := x.x[let  in end] := for x := -break to -() do new int to while int [-"totor"] of while 5 do () do let var x := 5 in end do new int
class x extends int {var x := 5} 
int {x = -if x.x(break, 5)+x.x((), ()) then for x := while () do 5 to x.x(5, nil) do x.x() else int {} *(5), x = x[nil][x].x := int [x(x := break, int {x = "totor"} )] of x()} 
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  var x := 5 import "empty.tih" var x := 5
class x extends int {var x := 5}  function x(x : int) : int = (5)
var x := (5) function x(x : int) : int = let  in 5 end
while while if int {}  then -if break then () else while for x := () to nil do nil do x(break, nil) do for x := int {x = if () then 5 else "totor", x = let  in 5 end}  to new int do let var x := 5 in end do while while -let  in end do x.x do if while break|5 do nil*"totor" then while x.x() do new int
function x(x : int) = let var x := 5 in nil end function x(x : int) = -() type x = int import "empty.tih"
x(new int, int {} )
int {x = let type x = int in x() ; int {x = 5}  end} 
int {x = if x[nil].x := x(let  in 5 end, (5)) then if x.x.x(x(), x()) then let var x := 5 in end else int {x = x.x := x.x(break, break)} } 
var x := if () then break else "totor"
class x extends int {var x := 5}  class x extends int {var x := 5} 
type x = int
function x(x : int, x : int) : int = int {x = int {x = 5} }  function x(x : int) : int = int {x = break} 
int {} 
x[5][x.x()].x[if for x := int {x = "totor", x = break}  to "totor"+() do int {x = break, x = break}  then x[break] else -int {x = "totor"} ] := if x(let var x := 5 in () end, for x := x := "totor" to int [()] of break do (5)) then new int
let class x extends int {var x := 5}  type x = int in end
int {} 
x.x.x.x[if -int {x = break, x = "totor"}  then x[5].x()].x()
x()
for x := int [x[5].x.x(for x := if 5 then 5 to let  in end do x(nil, ()), if while nil do 5 then x.x() else let  in end)] of int {}  to x.x.x.x do int {x = let var x := 5 in end, x = while new int do int {x = x.x(break, 5)} } 
int {} 
let function x(x : int) = -"totor" function x() = 5 import "empty.tih" var x := 5 in end
type x = class extends int{var x := 5} class x extends int {var x := 5} 
type x = array of int var x : int := 5 function x() = 5 var x := 5 var x := 5
type x = array of int class x {var x := 5}  class x extends int {} 
x[nil][x("totor", 5)][x()][while int {x = int {x = nil, x = nil} }  do -(5)].x(int {x = while if let  in end then int [()] of nil do -let  in end} , ((break ; 5) ; if () then 5))
function x(x : int, x : int) = if x() then let  in 5 end type x = int
int {x = int {x = new int} , x = for x := let var x := 5 in end to x[5][x := 5] do if x.x.x(while "totor" do (), (5)) then x() else new int} 
x[5].x.x.x := int [x[nil][x(nil, "totor")].x()] of let import "empty.tih" in end
function x(x : int) = let var x := 5 in "totor" ; 5 end
type x = int
new int
type x = class {var x := 5}
new int
function x(x : int, x : int) = for x := let  in end to x := () do "totor"+()
int {x = (for x := "totor" to nil do "totor" ; "totor" ; 5)&if let  in 5 end then new int|x(if nil then "totor" else "totor", if nil then () else 5)} 
function x(x : int) : int = int {x = if nil then nil else (), x = for x := "totor" to break do ()}  function x(x : int) : int = (5) function x() = nil import "empty.tih"
type x = class {var x := 5}
class x {var x := 5}  function x(x : int) : int = int [()] of nil type x = int import "empty.tih" var x := 5
class x extends int {var x := 5} 
class x {var x := 5}  function x(x : int) = x := nil
let class x extends int {var x := 5}  function x() : int = 5 var x := 5 in end
var x := int [nil] of 5
-x()
int [int {x = x["totor"].x := x(int [nil] of 5, x("totor", 5)), x = let import "empty.tih" var x := 5 in end} ] of new int
int {} 
class x extends int {var x := 5}  class x extends int {var x := 5} 
function x(x : int, x : int) : int = -if "totor" then "totor" else 5 function x(x : int) : int = -break var x := 5 import "empty.tih"
var x : int := new int
x[5][let  in end][x.x].x.x()
type x = int class x extends int {var x := 5}  type x = int import "empty.tih" var x := 5
function x(x : int, x : int) : int = (nil) class x extends int {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
x[()][x.x((), 5)].x.x.x(x.x[x := "totor"][-if 5 then "totor" else 5] := int {x = int [-nil] of if "totor" then 5 else break, x = int {} } , -x["totor"].x)
class x extends int {var x := 5}  function x(x : int) : int = if nil then break else nil
var x := int {x = break, x = break}  function x(x : int) : int = x()
if new int then x.x[new int].x.x(x(), -if -break then x := nil else x.x()) else if x[()][let  in end].x(x(int {} , while "totor" do break), x.x := x := nil) then x()
let class x {var x := 5}  in x[nil][int [()] of 5] end
type x = int
type x = int var x : int := break
x.x.x.x.x := x()
x()
x[nil].x[x.x.x(-"totor", x(break, break))][int {} ].x()
int {x = let function x() : int = "totor" in new int end} 
let var x : int := () in end
var x : int := x(nil, ())
while for x := let var x := 5 var x := 5 in end to let import "empty.tih" var x := 5 in end do x.x[x.x()] do -x()
x[break].x.x[(x)].x(let function x() : int = 5 import "empty.tih" var x := 5 in end, let type x = int import "empty.tih" in int [x.x()] of 5*"totor" end)
(for x := x() to int {x = int {x = break, x = "totor"} }  do while x do x())
function x(x : int, x : int) = x[5]
(-int {x = (5), x = x} )
var x := let  in end type x = class extends int{} class x {} 
type x = int class x extends int {var x := 5} 
for x := (x[break] := nil&break ; x := "totor") to x(let import "empty.tih" in end, x.x[if 5 then nil]) do let var x := 5 in end
while for x := if if if () then "totor" else "totor" then if () then break else 5 else while 5 do break then ("totor") else let var x := 5 in () end to int {x = for x := x() to x do let  in 5 end}  do (while nil do nil) do while while x.x do x() do int {} 
int [(x[nil].x() ; let  in end ; 5)] of x()
type x = class extends int{var x := 5} var x : int := ()
var x := if "totor" then "totor" function x(x : int) : int = int [5] of break class x extends int {}  var x := 5 var x := 5
function x(x : int) : int = while nil do 5|x.x(break, "totor") function x(x : int) = x.x()
int {} 
function x(x : int, x : int) : int = if x((), break) then x((), break)
var x := x()
type x = int function x(x : int) = x.x(break, "totor")
function x(x : int) = let var x := 5 in end
if x.x.x.x := for x := int [x.x(nil, 5)] of let  in 5 end to new int do let var x := 5 in break ; 5 end then x(let import "empty.tih" var x := 5 in end, int [-while 5 do nil] of -if "totor" then 5 else 5) else let var x := 5 in 5*5 end+x.x[break*nil]
type x = int
var x := x()
while let var x := 5 in int {x = x()}  end do if int {x = let var x := 5 in end, x = if new int then while "totor" do break else x("totor", 5)}  then new int
if int {x = x["totor"][int {} ] := while (5) do x := "totor", x = x.x[while nil do break] := for x := let  in 5 end to -() do x := nil}  then while -x() do let var x := 5 in x ; break end
x.x[x()].x.x := let var x := 5 in end
var x := (5)
function x(x : int, x : int) = let var x := 5 in 5 end var x := break function x() : int = ()
for x := int {x = x(), x = for x := if -5 then x.x((), break) to x.x.x() do -while () do 5}  to x(int {x = for x := x() to (5) do -break, x = int {x = -nil} } , if int {}  then while (5) do for x := break to nil do break) do ((break))
var x := x.x("totor", nil) type x = int var x := 5 import "empty.tih" var x := 5
class x {var x := 5} 
-x[5][let  in 5 end].x()/for x := int [if 5 then break else ()] of while nil do () to x := "totor"*while nil do break do x.x()*int {x = (), x = nil} 
var x := int {x = nil, x = "totor"} 
function x(x : int) = x[break].x() function x(x : int) = int {x = 5} 
int {x = let var x := 5 in let var x := 5 in nil end end, x = if int [if new int then int {x = break} ] of for x := break to "totor" do break*if 5 then "totor" else () then let var x := 5 in x(5, nil) ; nil end} 
if if let var x := 5 in end then int [x()] of int {x = nil}  else int [x.x("totor", 5)] of int {x = nil, x = break} +while x(x.x((), 5), int [()] of "totor") do (5) then x.x.x.x := x.x[-break] else (x.x.x())
int {} 
function x(x : int) : int = new int type x = class extends int{} function x() = "totor" import "empty.tih"
x()
if x[break].x.x.x() then int [int {x = (() ; 5)} ] of x()
class x {var x := 5} 
class x {var x := 5} 
var x : int := if 5 then () var x : int := 5
function x(x : int) = int [x := break] of int {x = break} 
int [x.x.x.x] of let class x {}  import "empty.tih" var x := 5 in end
type x = {x : int} function x(x : int) = x := "totor" type x = int import "empty.tih" var x := 5
type x = class extends int{var x := 5} var x := () class x extends int {} 
class x extends int {var x := 5 var x := 5} 
x[nil][x.x()].x.x
x[()].x[x[5] := "totor"-nil].x.x()
type x = int
if int {x = int {} , x = (x.x("totor", nil))}  then x[5][let  in 5 end].x.x(x(x(), while int [()] of () do x), new int)
-(int {} )
function x(x : int, x : int) : int = x[break] := int [()] of "totor" class x {var x := 5} 
x.x[let  in end].x[x.x := let  in end/if let  in end then int [nil] of nil else while nil do "totor"].x(x(), (-if () then "totor" else break))
var x := let  in 5 end class x extends int {var x := 5} 
x[nil].x[if () then ()+new int].x.x(let var x := 5 import "empty.tih" var x := 5 in if while "totor" do break then 5*() end, (int {x = ()|break, x = int {} }  ; if "totor" then nil))
function x(x : int) : int = while int {x = 5}  do ()/5 function x(x : int) = -nil function x() : int = () var x := 5
-int {x = for x := int [if "totor" then 5 else nil] of for x := () to 5 do () to let var x := 5 in nil end do if break then () else 5&x.x((), 5)} 
x.x[(5)].x.x
x(int {} , new int)
class x extends int {var x := 5 var x := 5} 
type x = class extends int{var x := 5} function x(x : int) = x()
-let function x() : int = nil in let var x := 5 in 5 end ; int [nil] of 5 end
x.x[(5)][while if 5 then 5 else 5 do -()].x := x(if let  in 5 end then while nil do 5 else (5)|x.x := nil/break, x.x.x.x(x["totor"].x(), -int [break] of "totor"))
x.x[x.x("totor", break)].x.x
class x {var x := 5 var x := 5}  class x {var x := 5}  class x {}  import "empty.tih" var x := 5
int {} 
var x := for x := 5 to 5 do nil function x(x : int) : int = new int function x() = "totor"
class x extends int {var x := 5}  function x(x : int) : int = int {x = break}  type x = int var x := 5
int {x = int {x = x[nil].x := int [x()] of int {} , x = x.x[while 5 do 5] := new int} } 
class x {var x := 5} 
while let function x() : int = break var x := 5 var x := 5 in end do x()
x[()].x[if x("totor", nil) then x][if x.x := int [nil] of nil then if int {x = ()}  then int {} ].x(x.x.x.x.x(for x := x[break] to x(new int, if nil then 5 else break) do (nil), int [int {} ] of x(int {} , -"totor")), (x[()] ; x := () ; nil))
-if x.x.x then x.x[for x := () to break do "totor"].x()
if (while x do if 5 then 5 else ()) then (x(int {x = 5} , int {x = 5, x = nil} ))
function x(x : int, x : int) = let var x := 5 in end class x extends int {var x := 5} 
int {} 
function x(x : int, x : int) = int {x = for x := "totor" to 5 do nil, x = x()}  function x(x : int) : int = let  in end type x = int
function x(x : int) = int [while () do ()] of -() class x extends int {var x := 5}  var x := 5 import "empty.tih"
while if x(if x.x((), 5) then x else x := "totor", (nil)) then new int do int {x = x()} 
function x(x : int) = int ["totor"] of 5/x := () class x extends int {var x := 5}  function x() = "totor" import "empty.tih" var x := 5
class x {var x := 5}  function x(x : int) = let  in end var x := 5 var x := 5
if x(if new int then x["totor"].x(), for x := x.x((), ())&for x := () to () do "totor" to x["totor"] := int {x = break, x = nil}  do if if 5 then "totor" else 5 then x.x(nil, nil) else (5)) then let function x() = nil var x := 5 var x := 5 in x[nil].x() ; for x := nil to break do 5 ; "totor" end else x.x[new int][let var x := 5 in end] := x[nil].x := int {x = ()*break} 
function x(x : int, x : int) = -int ["totor"] of "totor" var x : int := 5
var x : int := x("totor", ()) class x {var x := 5}  class x extends int {} 
new int
function x(x : int, x : int) : int = for x := int {x = break, x = ()}  to x(5, 5) do let  in end
int {} 
int {x = let type x = int import "empty.tih" var x := 5 in end, x = let function x() = () var x := 5 var x := 5 in end} 
int {} 
class x extends int {var x := 5 var x := 5} 
let function x(x : int) = let  in end in end
while int {}  do let function x() = "totor" in end
function x(x : int, x : int) : int = if x(break, break) then int {x = ()}  else (5) class x {var x := 5} 
var x := x := 5
let function x(x : int) = x.x("totor", 5) in end
x()
x(int {} , x()+while x.x.x(x.x(), if 5 then 5 else nil) do if if "totor" then 5 then x)
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = int {x = nil, x = break}  function x() = "totor" var x := 5 var x := 5
var x : int := x := break
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  type x = int
function x(x : int) = let var x := 5 in 5 end
let function x(x : int) : int = if 5 then 5 else nil type x = int in if --break then (5 ; 5) end
function x(x : int, x : int) : int = let var x := 5 in end function x(x : int) = x := break
x(x["totor"][let  in 5 end][x(if 5 then break, int {x = 5, x = "totor"} )].x(new int, while for x := x to x.x() do while () do "totor" do x["totor"].x()), int {x = int {x = int {x = -break} , x = int [let  in end] of x()} , x = int {x = int {x = x.x("totor", break)} } } )
function x(x : int) : int = for x := int {x = (), x = ()}  to x() do x() function x(x : int) = new int class x {}  var x := 5
function x(x : int, x : int) : int = int [(5)] of (5) function x(x : int) = x.x()
(let import "empty.tih" in -break ; "totor" end ; let var x := 5 in end)
int {x = int {x = for x := while int [break] of "totor" do int {x = break}  to x.x.x(x.x(), x := 5) do x.x, x = new int} } 
int {} 
x(x.x.x[let var x := 5 in end], if let var x := 5 var x := 5 in (5) end then x[()].x.x())
-if int {}  then x.x.x.x()
function x(x : int, x : int) = while "totor" do "totor"*let  in end
if x[5][x()].x.x(x[()][int {x = "totor"} ].x(), let var x := 5 in () ; 5 end-x.x := (5)) then int {}  else x[5].x[new int].x()
x.x[(5)].x[x.x.x.x()].x()
let type x = class extends int{} in end
function x(x : int) = if let  in end then let  in 5 end else int [5] of 5
function x(x : int) : int = x.x
var x := "totor"*()
type x = int function x(x : int) : int = x.x("totor", 5)
function x(x : int, x : int) : int = int {}  var x := 5
class x {var x := 5}  var x := nil class x extends int {} 
function x(x : int) = for x := x to -"totor" do int [nil] of () function x(x : int) : int = x := 5 function x() = "totor" var x := 5 var x := 5
type x = array of int
int [x.x.x[(nil ; 5)].x()] of let class x extends int {}  var x := 5 var x := 5 in if int ["totor"] of "totor" then x.x("totor", "totor") else while () do nil ; int {x = nil}  end
type x = array of int
x.x[int {} ].x[x.x.x.x()].x()
type x = class extends int{var x := 5} var x := 5
function x(x : int) = x(x(), if nil then () else "totor")
if x.x[x.x("totor", ())][int [break] of break&if () then 5].x() then int {}  else if x.x.x.x(x.x.x(), if int [()] of nil then int [5] of () else -nil) then int {x = let var x := 5 in end} 
(let import "empty.tih" in x.x(nil, break) end)
function x(x : int) = int {x = for x := break to () do break, x = int ["totor"] of ()} 
class x {var x := 5 var x := 5}  function x(x : int) = let  in 5 end type x = int
new int
new int
function x(x : int, x : int) = if x() then let  in end else int {}  var x : int := break type x = int
x()
new int
if int {x = new int, x = int {x = x[5].x(), x = int {} } }  then for x := while int {x = let  in end, x = while nil do nil}  do if x.x(nil, "totor") then let  in end to let var x := 5 in int {}  ; "totor" ; 5 end do x.x[while 5 do break] := x() else x.x.x.x := let var x := 5 in break ; 5 end|if int {x = 5}  then if () then 5 else while nil do ()
var x : int := while nil do () class x extends int {var x := 5} 
int {} 
type x = {x : int}
class x {var x := 5 var x := 5} 
let class x {var x := 5}  function x() = () var x := 5 in x.x[let  in 5 end].x(let var x := 5 in break end, while int {x = nil}  do let  in end) end
if int [-(())] of x[nil] := x.x()*int {}  then if int {} *x["totor"].x(x.x(), if nil then break else ()) then while if new int then x.x() do int [(5)] of while break do break else for x := int {}  to for x := 5 to "totor" do () do for x := break to 5 do nil|if for x := "totor" to () do nil then let  in end
class x {var x := 5 var x := 5} 
x.x.x[(() ; 5)].x := let class x {}  import "empty.tih" var x := 5 in (() ; 5) end
class x extends int {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
int [new int] of ((5) ; x.x("totor", ()))
class x {var x := 5 var x := 5}  function x(x : int) = x.x(nil, nil) class x extends int {} 
if let var x := 5 in end then if while x() do x.x(break, ()) then for x := () to "totor" do "totor"*x() else for x := if new int then -"totor" else 5*nil to (() ; 5) do (nil ; 5)+x(let import "empty.tih" in end, x(int [(5)] of let  in end, int {x = int {} , x = x} ))
function x(x : int) : int = if int {}  then -() function x(x : int) = x("totor", ())
let class x {var x := 5}  class x extends int {}  var x := 5 var x := 5 in end
function x(x : int) = if x.x() then int {x = 5}  function x(x : int) = int {x = "totor"}  var x := 5
class x {var x := 5 var x := 5}  function x(x : int) = let  in 5 end type x = int import "empty.tih"
let function x(x : int) : int = int {x = break, x = "totor"}  function x() = "totor" in end
class x {var x := 5 var x := 5}  var x := 5 class x extends int {} 
var x := int {x = 5, x = 5} 
-if x() then new int&-if nil then () else if while (5) do int {x = nil}  then for x := x to let  in end do int {x = nil, x = 5} 
class x {var x := 5 var x := 5} 
x()
if (-break*x.x()) then for x := int {x = x[()], x = if if break then 5 else "totor" then let  in 5 end}  to let import "empty.tih" var x := 5 in end do x.x.x := x.x.x() else int [x()] of for x := new int to if nil then nil do (5)/for x := -x() to if new int then int {x = ()}  else int {x = nil}  do x(x := 5, x := nil)
type x = {x : int} class x {var x := 5} 
type x = class extends int{var x := 5}
class x {var x := 5}  function x(x : int) : int = x.x((), break)
var x := x var x := nil
int {x = (x() ; if 5 then 5)} 
function x(x : int) : int = ("totor" ; 5) type x = int
x(while x[break].x do new int, x.x[int {x = (), x = "totor"} ][x(int {} , x := break)].x())
function x(x : int, x : int) : int = let var x := 5 in end
x.x[int [nil] of 5][-(5)].x := x()
x[5].x[int [x] of -()].x
var x := x function x(x : int) = x := nil function x() = break
for x := let var x := 5 import "empty.tih" in if int [break] of 5 then let  in 5 end end to (let var x := 5 in "totor" end ; int {x = nil, x = ()}  ; nil ; 5) do new int
x()
x[5][while break do "totor"].x[(while break do nil)] := while x.x[int {x = nil, x = nil} ].x(int ["totor"] of break*x(), int {x = int {x = ()} , x = -"totor"} ) do int {x = x.x.x()} 
while x() do int {x = if x["totor"].x() then x(let  in end, 5|"totor") else int {} } 
int [x(x[break].x.x(-x.x((), ()), if new int then int {}  else if () then 5), x[()].x)] of if x.x[if 5 then "totor"] then int {}  else let var x := 5 var x := 5 in end
class x extends int {var x := 5 var x := 5} 
var x : int := x
x[nil].x[while x.x(5, nil) do let  in end].x.x(x["totor"][int {x = "totor", x = nil} ].x.x(), new int)
type x = class {var x := 5} type x = {} var x := 5
int {} 
type x = class {var x := 5} var x := "totor"
function x(x : int) = x() var x := () function x() : int = "totor" var x := 5
if while if while "totor"-() do int {}  then let var x := 5 in end else x[5].x() do (nil&"totor" ; "totor") then let var x := 5 var x := 5 var x := 5 in -x.x() end
function x(x : int) : int = while ()*5 do let  in end
x.x[int {} ][if x() then x.x()][x["totor"].x := ("totor")] := int {} 
function x(x : int) : int = while (5) do int [nil] of break type x = {}
let function x(x : int) : int = x() in end
type x = {x : int}
for x := int {x = if -int {}  then if x((), ()) then let  in end else x.x(nil, ())}  to -let var x := 5 in int {x = nil}  end do int {} 
function x(x : int) : int = x.x.x()
x["totor"].x[x.x][let var x := 5 var x := 5 in end] := x()
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() = break
if x() then x.x.x.x
if let type x = int in if new int then -() else let  in end ; new int ; "totor" end then int {}  else new int
function x(x : int) = new int
x()
x(x.x[for x := () to () do nil].x.x(int [int {x = nil|5} ] of while for x := nil to "totor" do "totor" do (5), x()), x[5].x.x.x(while x[nil] := x.x(5, "totor") do int {x = int {x = 5} } , if if x("totor", "totor") then if break then nil else ()/5 then int {}  else for x := if nil then break to if 5 then nil else break do int {} ))
new int
x[5].x[x.x][if x.x then x()].x()
x.x.x[x.x.x(x(nil, ()), (5))].x := int {} 
-int [let var x := 5 in x.x(nil, "totor") end] of x["totor"].x.x()
x(int {x = let import "empty.tih" in end, x = x[break][let  in 5 end].x()} , while new int do x.x.x)
class x extends int {var x := 5} 
function x(x : int) = x.x.x(x(), int [nil] of nil) function x(x : int) = let  in end class x extends int {}  var x := 5
var x := x((), "totor") function x(x : int) = (5)
function x(x : int, x : int) : int = x[break].x() class x {var x := 5} 
int {} 
if x() then let type x = int in int {x = let  in end}  end else while x.x.x := -let  in 5 end do int [x()] of (break ; 5)
let var x : int := nil in x.x.x.x() end
class x {var x := 5}  var x : int := () class x {} 
int {x = while while x(while nil do nil, x := nil) do x() do x.x[x()], x = int {x = while let  in end do int {x = "totor"} , x = x(x.x(break, 5), new int)} *let import "empty.tih" var x := 5 in x(nil, nil) ; 5 ; 5 end} 
while int {x = x[5][if () then 5 else 5].x(), x = if x(int [()] of break, int {} ) then int {x = int {x = nil, x = "totor"} , x = int {x = nil} } }  do int {x = if x(for x := 5 to nil do 5, new int) then int {x = let  in end, x = int [break] of "totor"}  else int [x.x(5, 5)] of x, x = -if (5) then while "totor" do ()} 
function x(x : int) = int [while break do nil] of x.x((), ()) var x := "totor" type x = int var x := 5 var x := 5
function x(x : int) : int = x+-break class x {var x := 5} 
class x extends int {var x := 5 var x := 5} 
(int {x = x[5].x()} )
class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5}  var x := "totor"
new int
var x : int := int {x = ()} 
function x(x : int, x : int) = x.x.x() type x = {}
type x = class extends int{var x := 5} function x(x : int) : int = (5) function x() = 5
int {} 
(-x[nil].x())
int {x = int {x = new int} } 
type x = array of int class x extends int {var x := 5}  type x = int import "empty.tih" var x := 5
x(while for x := new int to int {x = -(), x = if "totor" then () else nil}  do if while nil do () then int {}  do while int [if nil then break] of x do x[5], int {x = x[break][int {x = break, x = break} ]} )
class x extends int {var x := 5} 
new int
x["totor"][int ["totor"] of "totor"][int {} ].x.x()
x.x.x.x.x.x()
var x := int {x = nil, x = break}  class x extends int {var x := 5} 
let type x = int var x := 5 var x := 5 var x := 5 in x.x.x end
int {x = int [let var x := 5 in end] of x(for x := x() to for x := () to () do 5 do x, if (5) then for x := () to () do 5 else "totor"*"totor"), x = x.x.x.x()/new int|x[nil].x(if "totor" then () else nil, x(5, "totor"))} 
function x(x : int, x : int) : int = int {x = if () then ()} 
while x.x[x.x()][int {} ] do int [while x["totor"].x() do int {x = int [5] of nil} ] of let import "empty.tih" var x := 5 in end
int {x = new int} 
-x.x[x()][if if "totor" then 5 then x := "totor"].x(while x() do x[break], let var x := 5 in end)
int {} 
if x[()][-"totor"].x.x() then ((nil) ; int {}  ; "totor")
int {x = while new int do x.x[int {x = nil} ].x(int [let  in end] of x := 5, x()), x = while int [int {x = x.x((), nil), x = if () then break else 5} ] of x(x("totor", "totor"), -()) do x.x[int {x = "totor"} ].x(int [while "totor" do break] of int {x = (), x = 5} , int {} )} 
int {} 
function x(x : int, x : int) = let  in end/new int type x = class {} function x() = nil
for x := x[break].x.x.x() to for x := x.x[let  in 5 end].x() to (x.x() ; nil ; 5) do x[5].x := let var x := 5 in () end do let var x := 5 import "empty.tih" in x(x(), int {x = break} ) ; x(break, break) end
-x[nil].x[x.x := while break do break].x()
class x {var x := 5 var x := 5}  function x(x : int) = x.x()
let function x(x : int) = if nil then () else nil function x() : int = "totor" import "empty.tih" in end
class x extends int {var x := 5}  var x := nil
if new int then while int [int [()*"totor"] of int {} ] of x(if 5 then "totor" else break, x.x("totor", ())) do new int
type x = class extends int{var x := 5}
var x : int := -break
class x extends int {var x := 5 var x := 5} 
var x : int := -nil
class x extends int {var x := 5 var x := 5} 
int [if while if x := break then int {}  do if for x := break to "totor" do break then for x := () to break do 5 else while "totor" do 5 then int [x(break, nil)*if break then "totor" else 5] of int [let  in end] of x else x[5][x := nil] := x(x("totor", 5), int {x = "totor", x = ()} )] of while if let var x := 5 in () end then int {x = 5} /int {x = (), x = 5}  do if while int {x = ()}  do x then if new int then (5) else x.x := if nil then () else break
(if int {x = x()}  then x.x.x() ; (5)-x(break, nil) ; for x := break to 5 do ())
x.x.x.x[new int]
-x[nil].x.x()+int [x(x[break], x.x := let  in end)] of for x := x.x.x(x(), int [()] of break) to int {}  do new int
x()
-x()
var x := let  in 5 end function x(x : int) = x
class x extends int {var x := 5 var x := 5} 
class x {var x := 5} 
type x = {x : int} var x : int := break
if (if x(5, 5) then x.x() else if nil then break ; if nil then ()) then x(while (break ; 5) do x.x := (5), if x.x then if while break do nil then (5) else x else if 5|5 then x)
class x extends int {var x := 5} 
var x : int := let  in 5 end function x(x : int) : int = int {x = nil, x = ()} 
type x = class {var x := 5}
class x {var x := 5}  var x : int := nil
int {x = let var x := 5 in end, x = -int {} } 
let function x(x : int) : int = int [5] of "totor" in if x.x then int [int [nil] of nil] of (5) else int {x = int {x = "totor"} , x = let  in 5 end}  end
type x = {x : int} type x = int
x[()][let  in end][x[()].x()][int [if new int then (5) else int {x = break} ] of for x := nil to "totor" do nil+while break do 5].x(if int {x = let var x := 5 in "totor" end}  then x(while -break do x := "totor", x.x) else x[5].x.x(), int {x = x.x.x} )
x()
x.x[-"totor"].x[let var x := 5 in nil end-if int {}  then int {} ]
function x(x : int, x : int) = let var x := 5 in () end
function x(x : int, x : int) : int = new int
class x extends int {var x := 5} 
function x(x : int) : int = if for x := 5 to nil do 5 then ()-nil type x = class extends int{}
var x := x()
new int
x()
let class x extends int {var x := 5}  in for x := if if () then () else break then new int to new int do new int end
int [x.x.x[if x then let  in 5 end else for x := 5 to () do "totor"].x(let import "empty.tih" var x := 5 in -() ; () ; 5 end, x[()][new int].x())] of -new int
class x {var x := 5 var x := 5}  var x := nil
x.x.x[int {x = new int, x = x()} ].x
class x {var x := 5} 
var x : int := x
let type x = {} class x {}  import "empty.tih" in end
var x := x class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int) = x.x.x()
while new int do new int
class x {var x := 5 var x := 5} 
let type x = int type x = int var x := 5 var x := 5 in end
x["totor"][while break do ()][for x := x := nil to x(nil, ()) do int {x = "totor"} ].x(if new int then if -break then int [()] of 5 else int {}  else while x.x(5, 5) do x.x(), int {x = int [x := break] of if () then break} )*x()
x.x[x.x()].x[x[nil].x].x(int {x = x.x.x} , int {} )
function x(x : int) : int = if x() then new int
class x {var x := 5 var x := 5} 
int [if new int then int {x = x(), x = -while "totor" do ()}  else x.x.x.x(x(x(), x.x()), int {x = x()} )] of x["totor"].x.x := int {x = x(int [break] of nil, if 5 then 5 else "totor"), x = x.x := let  in end} 
-let function x() : int = break in end
if int {x = x()}  then if x.x.x.x() then x.x[x] := x.x.x() else let function x() = 5 in end
for x := new int to -x.x.x := x[break].x() do int {} 
x.x[let  in end][x[()].x(while () do nil, if break then nil else "totor")].x()|if if let  in 5 end then int {x = break}  else if nil then break else "totor"&let var x := 5 in "totor" end then while (5) do (5)-new int else x.x[x.x(nil, break)]
int {x = int {x = int {x = x[break].x()} } } 
int [new int] of if x(if new int then int {} , let var x := 5 in end) then x[5].x.x()
class x extends int {var x := 5} 
if x.x[while nil do "totor"][x.x] then while x[break].x := x(x.x(), x.x(break, ())) do int {x = x(for x := nil to break do break, x := ()), x = for x := -() to int {x = 5}  do if () then nil} 
function x(x : int) = let var x := 5 in "totor" end
int {x = int {x = x[()].x.x(), x = x[break].x := x.x.x()} , x = -x.x.x := while int {x = (), x = break}  do if "totor" then nil} 
x[5][(5)][int {} ][while let var x := 5 in nil ; 5 end do x["totor"] := int {x = "totor"} ].x()
int [if int {x = -if () then nil, x = if int {x = break, x = "totor"}  then let  in 5 end else while break do break}  then int {x = int {} }  else x.x.x.x()] of x.x.x[if int [nil] of () then x := nil].x(x.x.x, x(x.x.x(for x := nil to nil do 5, let  in end), int {} ))
new int
class x {var x := 5}  function x(x : int) : int = x()
int {x = if x["totor"].x.x(x.x.x(), x(int {x = ()} , int [nil] of nil)) then if while -nil do let  in end then if x.x("totor", ()) then (5) else x := ()} 
class x {var x := 5 var x := 5} 
int {x = int {x = while new int do -int {x = (), x = ()} } , x = let class x extends int {}  in end} 
x()|for x := if new int then x.x() else x.x() to x(for x := nil to break do "totor", int {x = "totor"} ) do int {x = let  in end, x = x := nil} +for x := (5) to int {}  do x()
class x extends int {var x := 5 var x := 5} 
int {} 
x["totor"].x[x[break]][x.x := int {} *let var x := 5 in 5 ; 5 end] := -new int
function x(x : int) = x()
function x(x : int, x : int) : int = if int {}  then let  in 5 end else -() class x extends int {var x := 5} 
x(if while int [5] of "totor" do int {x = (), x = break}  then -int [break] of "totor", (new int ; ()))*x["totor"][for x := 5 to break do break].x.x()
class x {var x := 5} 
class x {var x := 5} 
class x {var x := 5} 
type x = class extends int{var x := 5} class x {var x := 5} 
for x := for x := let var x := 5 var x := 5 in int {}  ; 5 ; 5 end to if x[5].x() then x["totor"] := (5) else let var x := 5 in end do int [x(x("totor", ()), new int)] of x["totor"].x(-5, int [break] of 5) to (int {x = x()} ) do if if int {x = x.x(nil, 5)}  then -while nil do 5 then x()
let function x(x : int) = new int in end
class x extends int {var x := 5}  class x extends int {var x := 5} 
int {x = int [new int] of x()} 
(int {x = if x.x() then int {x = (), x = ()}  else x(), x = (5)}  ; x.x.x() ; x)
type x = {x : int} type x = {}
x["totor"].x[x.x.x(x(break, 5), int [5] of nil)].x.x(if let import "empty.tih" var x := 5 in end then let import "empty.tih" var x := 5 in end else int [x.x.x(break&nil, int {x = "totor", x = nil} )] of x(if nil then break, if break then ()), ((nil ; 5) ; x.x() ; nil ; 5))
var x : int := x() var x : int := break
function x(x : int) = while x.x(break, 5) do (5)
x.x[if nil then 5 else "totor"][("totor")][int [x(if () then nil else 5, x.x(5, break))] of x["totor"]].x()
(int {}  ; if nil then "totor" else nil)&x["totor"][x.x((), 5)][while int {x = 5, x = 5}  do x(nil, ())] := x()/x()
function x(x : int) = while x.x(nil, ()) do -"totor" function x(x : int) = if 5 then "totor" function x() : int = ()
x.x[x.x()].x.x(if int {x = x.x(), x = int {} }  then x.x.x(), -for x := if nil then 5 to for x := nil to "totor" do break do if 5 then 5 else break)|if let var x := 5 var x := 5 in end then int {x = x.x.x(), x = x()}  else x[5].x.x()
int [x["totor"].x.x.x()] of if int {x = int {x = int {} , x = while () do 5} , x = int [let  in end] of x.x()}  then int {x = x(), x = x.x.x()} 
class x {var x := 5} 
type x = class {var x := 5} class x extends int {var x := 5}  type x = int var x := 5 var x := 5
x[()].x[x(5, 5)+let  in 5 end].x()*int {} 
if while x.x[while "totor" do nil].x(x[5].x(if () then "totor", if () then 5 else "totor"), x.x) do int {x = x[nil]}  then -x[5].x else int {} 
function x(x : int) : int = new int function x(x : int) = int [nil] of nil function x() = "totor"
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  type x = int
x()
type x = int type x = class extends int{}
x[break][x.x()].x.x
function x(x : int) = (())
x.x[int [5] of "totor"].x.x.x(int {x = x[()].x, x = int {x = for x := if break then nil to x := 5 do x.x(), x = x.x} } , ((break)))
x.x[let  in end][int {x = new int, x = for x := break to "totor" do ()} ]-x.x[-()].x((() ; 5), if -break then for x := break to () do break else int {x = "totor", x = "totor"} )*int {x = -if break then break else "totor"} 
function x(x : int, x : int) : int = int {x = int {x = break, x = ()} , x = x(nil, break)} 
function x(x : int) : int = let var x := 5 in 5 ; 5 end
class x extends int {var x := 5 var x := 5}  var x : int := nil function x() = break
class x extends int {var x := 5} 
x(int {x = if new int then let var x := 5 in "totor" ; 5 end} , -x[()].x.x(x[nil].x(), x[nil].x((5), x())))
var x := int {x = nil} 
(new int)
-int [int [while x := break do for x := () to break do 5] of for x := new int to if () then 5 else nil do if 5 then 5] of -x(int {x = 5} , let  in end)
x()
function x(x : int, x : int) = int {x = (5), x = int [nil] of break} 
class x {var x := 5 var x := 5}  function x(x : int) = x.x() function x() = 5
function x(x : int, x : int) : int = let var x := 5 in 5 end
type x = array of int
int [if new int then if x[5].x() then (()) else x[nil].x()] of x[break].x.x.x(x.x[x.x((), nil)].x(while let  in end do int {x = 5} , ("totor" ; 5)), for x := ("totor" ; 5) to let var x := 5 in end do let var x := 5 in break ; 5 end)
type x = array of int function x(x : int) = x((), "totor")
let class x {var x := 5}  type x = int var x := 5 in let var x := 5 in break end-if int {x = break, x = 5}  then while break do 5 end
var x := x()
int {} 
var x : int := if 5 then nil else 5
while if x() then if let var x := 5 in "totor" end then int [int [nil] of break] of x.x() else int {x = new int}  else if -new int then x.x else let var x := 5 in end do int {x = x(while new int do int {} , int {x = int [break] of "totor"} ), x = -(5)} 
var x : int := x((), nil) function x(x : int) : int = int {x = break} 
new int
type x = class extends int{var x := 5}
type x = {x : int} type x = class {}
x()
function x(x : int) = x(let  in end, if () then nil)
var x := x := nil function x(x : int) : int = x := "totor"
class x {var x := 5}  var x := nil class x extends int {}  import "empty.tih"
var x := if () then "totor" else nil
var x : int := x("totor", nil) function x(x : int) : int = x function x() = break
function x(x : int) : int = int {x = for x := nil to "totor" do ()} 
x()
int [for x := (int [break] of nil ; break) to x[5].x := let var x := 5 in end do new int] of if x() then new int
int {x = x()} 
x[()].x.x[if x[nil].x() then if int {}  then int {x = 5, x = nil} ].x(int {x = int {} , x = int {} &int [int {} ] of x} , -for x := new int to int {x = 5, x = break}  do while "totor" do 5+int [int {} ] of let var x := 5 in end)
function x(x : int, x : int) = int {x = if 5 then break, x = x} 
type x = {x : int} var x := break
var x : int := if "totor" then nil else nil function x(x : int) : int = int {} 
if -if new int then for x := x() to let  in end do let  in 5 end then x(x(x.x, if x() then x), x[nil].x) else let class x {}  var x := 5 in end
let class x extends int {var x := 5}  in end
var x : int := x := break type x = {} function x() : int = "totor"
int {x = int {x = if x then if 5 then nil/x(), x = let import "empty.tih" in new int ; () end} } 
var x := x := "totor"
(x())
function x(x : int) : int = x()
class x {var x := 5 var x := 5}  type x = {}
class x {var x := 5} 
var x := let  in end class x {var x := 5}  var x := 5
function x(x : int) = int {x = -5, x = int [5] of ()}  class x extends int {var x := 5} 
class x {var x := 5}  var x : int := () type x = int var x := 5
class x extends int {var x := 5 var x := 5} 
int [x.x.x[int {x = int {} } ]] of x()
class x {var x := 5} 
type x = class {var x := 5}
-let class x {}  import "empty.tih" in int {x = x := break, x = new int}  end
(int [int {x = for x := break to break do nil, x = 5|break} ] of if 5 then "totor" else "totor"&if break then 5)
var x : int := int {} 
function x(x : int) : int = int {}  var x : int := ()
int [-let var x := 5 var x := 5 in int {}  end] of new int
var x : int := x(break, "totor") class x extends int {var x := 5}  type x = int
if if new int then x() then let function x() = 5 import "empty.tih" var x := 5 in end
class x {var x := 5}  class x extends int {var x := 5} 
type x = class {var x := 5}
class x {var x := 5} 
x(x(x.x.x(), x.x.x()), let import "empty.tih" var x := 5 in end)&x()
type x = array of int var x : int := break
x()
var x : int := int {x = break} 
x[nil].x.x.x := int {x = let import "empty.tih" in end, x = int {x = while x() do int {x = "totor", x = 5} } } 
function x(x : int) = new int&if "totor" then nil function x(x : int) : int = if "totor" then () else "totor"
while -int {x = if while 5 do () then nil*nil else -nil, x = if nil/5 then -5 else while () do "totor"}  do x.x.x[int [x := ()] of int {} ]
class x {var x := 5}  var x : int := break function x() : int = nil var x := 5 var x := 5
function x(x : int) : int = x.x.x() type x = class {} function x() : int = () var x := 5
let class x extends int {var x := 5}  function x() : int = 5 import "empty.tih" var x := 5 in int {}  end
var x : int := -5 function x(x : int) : int = int {}  function x() = ()
function x(x : int) = int {x = x := break, x = int {x = ()} } 
function x(x : int, x : int) : int = let var x := 5 in () ; 5 end var x := break
function x(x : int, x : int) : int = if x.x() then int {x = ()}  else if 5 then ()
let function x(x : int) : int = (5) in end
class x {var x := 5 var x := 5} 
let function x(x : int) = let  in end in end
class x extends int {var x := 5 var x := 5} 
int {x = let class x extends int {}  in end, x = int {} } 
if new int then x.x[if 5 then "totor"].x.x(-for x := x(break, "totor") to int {x = 5}  do x.x(5, break), if -int {x = ()}  then x.x else x.x.x(nil*(), if "totor" then 5)) else let class x extends int {}  in end
type x = {x : int} class x {var x := 5} 
type x = class extends int{var x := 5} class x extends int {var x := 5} 
if (x[nil].x()) then let type x = int var x := 5 in x() end
type x = array of int
int {} 
function x(x : int) : int = -x("totor", nil)
if x["totor"].x[let var x := 5 in 5 ; 5 end] then if x.x.x.x(for x := int {x = "totor"}  to int [()] of "totor" do let  in 5 end, new int-x()) then int [int {} ] of if while "totor" do 5 then x.x() else break/() else let import "empty.tih" in x(break, nil) ; break end
class x {var x := 5}  var x := break class x {}  import "empty.tih"
for x := int {x = while new int do int {x = (5)} , x = let var x := 5 in end}  to let class x extends int {}  var x := 5 in -x ; x.x((), nil) ; nil end do x.x[x.x()].x.x(x.x.x.x(), let var x := 5 var x := 5 in x end)
class x {var x := 5 var x := 5}  function x(x : int) = x.x()
x()
function x(x : int) = for x := int {x = nil}  to (5) do x.x() class x {var x := 5}  class x extends int {} 
x.x.x.x.x
class x {var x := 5}  function x(x : int) = (5) function x() = nil import "empty.tih" var x := 5
x.x[new int].x.x
var x := x(5, break) type x = class {}
var x : int := let  in end
var x := x.x((), 5)
type x = array of int
class x {var x := 5} 
int {x = int {x = x.x.x, x = x.x&(5 ; 5)} } 
var x : int := if break then "totor" else ()
class x {var x := 5 var x := 5}  var x := () type x = int var x := 5
let type x = {} in end
function x(x : int) = x()+()-5 function x(x : int) = x.x()
function x(x : int) = int [new int] of while nil do () var x : int := 5 var x := 5
new int
type x = {x : int} function x(x : int) = nil|5 function x() : int = nil
if (x.x.x(nil|5, for x := () to break do nil)) then let class x extends int {}  import "empty.tih" var x := 5 in end else x()
function x(x : int, x : int) : int = for x := nil|break to int [nil] of nil do int {} 
x[nil].x[x(nil-5, while () do break)][x[nil][if 5 then () else "totor"].x(new int, -break+let  in 5 end)].x()
function x(x : int, x : int) = let var x := 5 in () ; 5 end class x {var x := 5}  function x() : int = () var x := 5 var x := 5
x["totor"].x.x.x := new int
x[break][int {x = nil} ].x.x.x()
class x extends int {var x := 5 var x := 5} 
x()+x(-int {} , if if let  in end then int {}  then x((5), int {} ) else let var x := 5 in "totor" end)
x["totor"].x.x[if new int then x[5].x()] := -x.x[int {x = "totor"} ].x(x[()], x.x.x(x(), x.x(5, 5)))
class x extends int {var x := 5 var x := 5}  type x = int var x := 5 import "empty.tih"
let var x := "totor" class x {}  var x := 5 var x := 5 in x() end
-x.x[x(break, break)].x := new int
function x(x : int) = if for x := "totor" to 5 do "totor" then x := 5
let function x(x : int) = let  in 5 end type x = int in (int [5] of break ; "totor") end
var x := x(break, ()) type x = array of int
while (x.x.x()) do x["totor"].x[(() ; 5)].x()
class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
x[5][int {x = 5} ][x(int {} , let  in end)][x.x[for x := "totor" to () do "totor"].x()].x(if x[()].x(while 5 do (), x.x())|if x then let  in end then int {} , int {x = int {} -let var x := 5 in () end} )
int {} 
type x = int function x(x : int) = if nil then "totor" class x extends int {} 
for x := if while -for x := nil to "totor" do "totor" do int {}  then int {x = while int {x = ()}  do let  in 5 end}  to x[nil].x.x.x(let import "empty.tih" var x := 5 in end, int {x = int {x = int {} , x = for x := "totor" to "totor" do "totor"} } ) do -if x[nil] := if "totor" then () else "totor" then while int {}  do x(5, nil)
x[5].x[int {x = let  in end} ].x
class x {var x := 5} 
var x : int := for x := () to 5 do break
var x : int := if () then 5 else nil var x : int := nil class x extends int {} 
int [x["totor"].x.x.x()] of x[5][x(5, 5)].x.x(if x.x()*()-5 then -int {x = 5, x = break} , x[nil].x.x())
function x(x : int, x : int) = new int class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
while for x := (nil ; 5)/int {x = int {x = 5, x = break} , x = int [()] of ()}  to int {x = int {x = int [()] of "totor", x = int {x = (), x = break} } , x = int {x = (5)} }  do x[()][for x := "totor" to 5 do nil] do x(int {x = -while 5 do nil, x = if x := () then x.x(nil, break) else for x := nil to "totor" do break} , int [int {x = for x := "totor" to nil do break} ] of (nil ; 5))
var x : int := x := break
class x {var x := 5}  function x(x : int) : int = (5)
class x {var x := 5 var x := 5} 
var x := if () then 5 else "totor"
x[break].x[x(for x := "totor" to break do (), int {x = nil, x = 5} )][new int]
var x : int := let  in end
type x = array of int
int {x = let import "empty.tih" in x := "totor" ; () ; 5 end, x = x(-x.x(), (()))} *x.x.x.x.x(x(), let import "empty.tih" in x(break, "totor") ; nil ; 5 end)
function x(x : int) : int = int {x = -()} 
new int
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = if () then "totor" function x() : int = nil
var x := x.x(5, break)
x()
if int {x = x.x.x.x(), x = if x.x then -(5)}  then int {x = let var x := 5 in "totor" end&x()} 
function x(x : int) : int = new int function x(x : int) : int = int [5] of () var x := 5
class x extends int {var x := 5} 
int [let class x extends int {}  import "empty.tih" in end] of x(-int [int {} ] of int [break] of 5, (x ; break))
int {x = (x() ; int {}  ; break), x = while x[5].x do while x.x.x(x.x(), int [nil] of nil) do let var x := 5 in end} 
-int {x = x.x[(5)] := let var x := 5 in end, x = int {x = x[5]} } 
let type x = int import "empty.tih" var x := 5 in end-let class x extends int {}  in end
class x {var x := 5}  class x extends int {var x := 5} 
int {x = new int, x = (x[5] := new int)} 
var x := x()
int {} 
type x = array of int
x.x.x.x.x.x(x.x.x.x, let function x() = () import "empty.tih" in end)
type x = class {var x := 5} function x(x : int) = x.x(break, "totor") class x extends int {}  import "empty.tih"
class x {var x := 5} 
int {x = x()} 
int {x = for x := while int {x = 5+break}  do x() to -int [-nil] of int {x = "totor"}  do let var x := 5 in new int end} 
var x : int := break&()
class x extends int {var x := 5} 
class x extends int {var x := 5} 
int [let type x = int in -int [break] of nil end] of int {x = int [while if "totor" then break do "totor"*()] of x(), x = x.x[x()] := new int} 
let class x {var x := 5}  in for x := x.x.x(int [nil] of break, x()) to let var x := 5 in end do let var x := 5 in end ; while x := break do x := () ; if 5 then () ; "totor" end
(let var x := 5 in x.x() ; "totor" ; 5 end ; if int [5] of 5 then x.x())
function x(x : int) = x(int [()] of 5, -break)
type x = class {var x := 5} function x(x : int) : int = if () then nil else 5
int {x = x.x*if x.x(nil, break) then int {}  else while "totor" do "totor"-if (nil ; 5) then -x((), 5), x = for x := x[nil][x.x()].x() to x[5].x do x(x[()].x(), x.x := new int)} 
type x = class extends int{var x := 5} class x extends int {var x := 5} 
if for x := while x() do for x := for x := 5 to () do nil to let  in 5 end do while nil do 5 to (let  in 5 end) do if int {}  then int {}  then for x := int {x = let var x := 5 in end}  to int {}  do int {} 
int {x = let var x := 5 var x := 5 in end&int {} } 
function x(x : int) = x() class x extends int {var x := 5} 
function x(x : int, x : int) = while x() do let  in 5 end function x(x : int) : int = int {x = nil, x = nil} 
if -int {x = if (5) then while () do break else while () do "totor", x = while x() do if "totor" then "totor"}  then x() else -if int {x = if "totor" then nil else "totor"}  then let var x := 5 in end else -x.x()
int {x = int {} , x = x[5].x[let var x := 5 in end] := x.x[new int].x()} 
var x : int := -break
int [x[break].x.x.x(int {x = if x() then x, x = if int {x = 5, x = nil}  then int {}  else let  in 5 end} , x())] of new int
int {} |x[break][x("totor", 5)].x := while for x := if break then "totor" to x do if () then nil else () do (break ; 5)
x.x.x.x.x()|if int [if if break then nil else 5 then (5)] of x(x(), new int) then int {} &x/if nil then break else for x := for x := x.x() to x() do new int to int {}  do if let  in end then int {} 
for x := if int {x = if "totor" then 5 else "totor", x = "totor"/break}  then x[()] := while "totor" do nil else while nil&5 do int {x = nil, x = 5}  to x[5].x do int {x = (5), x = -break} *if -break then if break then ()*int {} 
x()|x["totor"][new int].x.x()
int {x = if x.x.x := for x := while break do break to x(break, break) do int {x = break, x = break}  then x["totor"][x := 5]} 
type x = array of int
var x : int := int {x = nil}  type x = class {}
class x extends int {var x := 5 var x := 5}  var x := 5 type x = int import "empty.tih" var x := 5
-x.x[(5)].x.x()
int {x = int {x = new int, x = let import "empty.tih" var x := 5 in end} , x = -if new int then x() else int {x = x(), x = -nil} } 
x()
x.x.x.x[(int {x = "totor"} )].x()
class x extends int {var x := 5} 
function x(x : int) : int = new int
var x := for x := () to () do nil
x.x[int {x = break} ][("totor")][if new int then x[()]]
int {} 
function x(x : int) : int = if -5 then let  in 5 end else x.x(break, nil)
type x = class extends int{var x := 5}
x(x[5].x.x, int {x = let var x := 5 var x := 5 in x.x() end, x = x()} )
type x = int
class x {var x := 5 var x := 5}  class x {var x := 5}  class x {}  import "empty.tih"
while for x := x[break][int {x = "totor", x = ()} ] := -if nil then 5 else break to int {}  do x(int {x = let  in end} , int [for x := nil to break do ()] of -()) do int {x = x.x[if () then 5]} 
function x(x : int) : int = int {x = x := "totor", x = (5)} 
for x := int {x = x["totor"][int {x = break, x = 5} ], x = int {x = int {x = for x := nil to 5 do nil} , x = if int {x = nil}  then x(break, break) else if 5 then () else ()} }  to while int {}  do let import "empty.tih" in end do int {} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = for x := nil to nil do "totor"
if let var x := 5 in x() end then x.x.x[-while 5 do "totor"] := int {x = int {x = if () then break, x = x(nil, break)} , x = (break)} 
type x = class {var x := 5}
class x extends int {var x := 5 var x := 5} 
for x := int {}  to x[()][-()][(nil)].x(x(while -break do nil*nil, x[()] := if () then 5), x[()].x := int {} ) do while x.x[if nil then "totor" else nil] := while x := break do x.x() do new int
class x extends int {var x := 5} 
var x : int := while nil do 5 function x(x : int) = new int class x extends int {}  import "empty.tih"
var x := x
x[5].x["totor"|()|if "totor" then break][int {x = while x.x() do while () do break, x = x()+"totor"+break} ].x(x[5][int {x = break} ].x.x(), if let import "empty.tih" in end then int {x = int {} , x = while (5) do x}  else x.x.x.x(-x("totor", "totor"), x[()] := let  in end))
function x(x : int, x : int) = x["totor"] class x extends int {var x := 5} 
while for x := int {x = let var x := 5 in end}  to if x(x.x(), x()) then while for x := "totor" to () do nil do x() else if new int then let  in 5 end else int {}  do let var x := 5 in -"totor" ; break ; 5 end do while int {}  do while x.x.x() do if x(break, break) then int [5] of break else for x := "totor" to "totor" do nil
x(int {x = let var x := 5 var x := 5 in end, x = x[5][int {x = nil, x = 5} ]} , let class x extends int {}  in end)
x["totor"][if "totor" then "totor"][(nil)].x.x(x.x.x.x, ((nil) ; x := break))
class x {var x := 5} 
var x := let  in 5 end var x := "totor" type x = int
if if while new int do if break+break then x() then int {x = while x do int {x = nil, x = "totor"} , x = int {} }  else int {x = new int} +let  in end|x := () then for x := for x := for x := break to break do nil to int {x = 5, x = 5}  do -5 to let var x := 5 in end do new int/(5 ; 5)/let var x := 5 in end else let var x := 5 var x := 5 var x := 5 in int [new int] of x := nil ; x end
int [x.x.x[let var x := 5 in end].x()] of if new int then x[nil][(5)]
new int
int {} 
var x := let  in 5 end var x := nil type x = int import "empty.tih" var x := 5
function x(x : int) = int [x.x(nil, ())] of x.x("totor", 5)
x(x(int {x = (break)} , while int {x = int [break] of ()}  do let var x := 5 in end), int {} )
int {x = while -let var x := 5 in end do new int, x = (x.x := x)} 
class x {var x := 5}  class x {var x := 5}  class x extends int {}  var x := 5 var x := 5
x(let class x {}  in int {}  ; x() ; "totor" end, x(-for x := if "totor" then break else "totor" to int {}  do (5), x(x(), let  in 5 end)/(5 ; 5)))
-for x := let var x := 5 in "totor" ; 5 end to new int do x.x.x()&if while x.x do new int then while x.x.x(if "totor" then 5 else "totor", x := nil) do for x := int {x = (), x = break}  to x.x() do x(break, nil)
class x {var x := 5 var x := 5} 
function x(x : int) : int = int [int {x = nil, x = ()} ] of int {x = 5, x = break} 
x()
class x extends int {var x := 5 var x := 5} 
int [int {x = -if if break then () then x(nil, "totor") else x(), x = x[5][x.x((), ())]} ] of x.x[int {} ].x
while if x(let var x := 5 in break end, int {} ) then let import "empty.tih" var x := 5 in -"totor" ; break end else -x.x do int [if let var x := 5 in end then int {} ] of -if int {x = break, x = 5}  then int {x = ()}  else if break then "totor"
class x {var x := 5} 
for x := int [int {x = if x() then if nil then nil else (), x = int {} } ] of if x then if 5 then "totor" else x.x(break, break)|while while 5 do 5 do for x := break to () do () to x.x.x.x.x(x.x.x.x(for x := for x := nil to 5 do () to int {}  do x((), ()), x[()].x()), let import "empty.tih" in if "totor" then nil else () end) do let function x() : int = 5 in end
function x(x : int) : int = int {x = for x := () to 5 do "totor"}  function x(x : int) : int = x() class x {}  var x := 5 var x := 5
int {x = int {x = -let var x := 5 in end} , x = let function x() = break var x := 5 var x := 5 in end} 
-int {x = int {x = -while 5 do nil} } 
int {x = x(int {x = if "totor" then ()} |while let  in end do x(), x())} 
type x = int class x extends int {var x := 5}  class x extends int {}  import "empty.tih"
if int [x(x(), let var x := 5 in end)] of new int then int {x = for x := x := 5|while 5 do "totor" to if nil then 5&int {x = nil, x = ()}  do int {x = int {x = "totor"} } }  else x(for x := new int to int {x = -"totor"}  do new int, let var x := 5 var x := 5 in end)
type x = {x : int} type x = class extends int{}
if if let import "empty.tih" in x ; 5 end then if x/x((), break) then 5-"totor"|let  in 5 end then x[break].x[x[nil].x()] else (int {x = new int}  ; if break then "totor" else "totor" ; 5 ; 5)
while int {}  do int {x = let import "empty.tih" in end} 
int [x.x[while 5 do "totor"].x.x(new int, x[break].x.x())] of int {} 
class x {var x := 5} 
function x(x : int) = let var x := 5 in end var x : int := 5
type x = {x : int}
function x(x : int) : int = x.x(nil, nil)/int {}  function x(x : int) = for x := 5 to "totor" do "totor"
let class x {var x := 5}  in if for x := nil to nil do ()/x.x((), ()) then x(x("totor", break), int {x = 5} ) ; int {x = (), x = ()} |if nil then break end
var x : int := x((), break) type x = class extends int{} type x = int
int {} 
int {} 
class x extends int {var x := 5 var x := 5} 
let function x(x : int) : int = x.x(nil, break) in end
type x = int
function x(x : int, x : int) : int = x["totor"]
var x : int := (5)
var x := int {x = break, x = break} 
--x.x[new int]
x.x.x.x[x.x.x.x(int {x = x.x(break, nil), x = x := "totor"} , while let  in 5 end do int {x = nil} )].x()
x.x.x[x[()].x(nil+5, for x := break to "totor" do 5)][x.x.x]
while int {x = x(x[nil], x.x), x = x[break].x.x(-(5), x[5].x())}  do int [x[nil][int {x = break, x = "totor"} ]] of x.x.x.x()
x()
class x {var x := 5}  class x extends int {var x := 5}  var x := 5 var x := 5
x()&int {x = x.x.x := let var x := 5 in end} 
let class x {}  in x.x ; let  in 5 end ; () ; 5 end/let class x extends int {}  import "empty.tih" var x := 5 in new int|while break do () ; new int ; () end
-x()
int {x = let var x := 5 in end, x = if int {}  then int [int [x.x()] of int {x = "totor"} ] of let var x := 5 in "totor" ; 5 end} 
class x extends int {var x := 5} 
x[5][if 5 then break].x.x.x(x(), x[nil][let  in end][let var x := 5 in end].x())
if while if let var x := 5 in end then new int do if new int then -(5) then if int {x = int {x = x.x()} }  then (int {x = nil, x = break}  ; 5 ; 5) else if new int then if x() then int {x = "totor"&nil}  else x.x.x(let  in 5 end, x("totor", nil)) else if if ()/5 then x else x then if let  in end then x := break else if "totor" then nil
type x = array of int
class x {var x := 5 var x := 5}  type x = array of int var x := 5
function x(x : int, x : int) : int = int [x] of for x := "totor" to () do break function x(x : int) = let  in 5 end
for x := let function x() : int = "totor" in for x := break*break to x("totor", 5) do int {x = break, x = "totor"}  ; int [nil] of nil ; () end to -int {} &-int {x = ()/5}  do x[break][(5)].x.x()
function x(x : int, x : int) : int = int {} 
let var x := "totor" in int {x = if x then x() else "totor"+break}  end
class x {var x := 5} 
for x := x.x[new int] to x.x.x.x(-while break do (), x[break].x(x(break, 5), x.x(nil, break))) do let import "empty.tih" in end*x[nil].x[new int] := x.x.x.x(int {x = int {} , x = while nil do break} , int {} )
class x {var x := 5 var x := 5}  var x : int := 5
class x extends int {var x := 5 var x := 5}  var x : int := "totor" function x() : int = break var x := 5 var x := 5
class x {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int) = int {x = (5), x = int {x = break} } 
x()
new int
let class x extends int {var x := 5}  class x {}  in end
class x {var x := 5} 
x[break][new int].x.x := int {x = for x := x["totor"].x() to x() do if int ["totor"] of 5 then (5), x = x[nil].x.x(let var x := 5 in end, int {x = x, x = x := break} )} 
new int
int {x = x.x.x[x["totor"]], x = let function x() = "totor" in if x.x("totor", 5) then (5) else if "totor" then () else () end} 
new int
let var x := () function x() : int = 5 in end
if int [let var x := 5 var x := 5 in end] of (x.x()) then int {x = x[()][int {x = 5, x = ()} ], x = x.x[let  in end].x()} 
var x : int := x(break, "totor")
var x : int := let  in 5 end
let var x := nil function x() : int = nil import "empty.tih" in x(x := nil|int {} , int {} &int [5] of "totor") ; int [x.x()] of -"totor" end
int {x = new int, x = int [if break then "totor"] of x()-int {x = new int, x = x(break, ())} } &-int [for x := x := 5 to (5) do x.x(break, "totor")] of int [int {x = "totor", x = "totor"} ] of if "totor" then 5 else "totor"
while int {x = x[break][x.x("totor", nil)] := if for x := 5 to "totor" do "totor" then (5) else x.x("totor", "totor"), x = x.x.x()+x(let  in end, (5))}  do x(x(let var x := 5 in end, int {} ), int {x = for x := new int to int {x = break, x = ()}  do while "totor" do "totor"} )
x.x[int {} ][let var x := 5 in end].x := x[nil][if break then 5].x := int {x = (break ; 5), x = let var x := 5 in break end} 
x(x(), int {x = x["totor"].x(int {} , while nil do "totor"), x = if x.x((), nil) then int {x = 5} } )|for x := -int {}  to let import "empty.tih" var x := 5 in let  in end end do x(x(for x := "totor" to nil do "totor", int [5] of break), -int {x = 5} )
class x extends int {var x := 5 var x := 5} 
int {} 
while let class x extends int {}  in end do int {x = x.x.x.x(x(let  in end, let  in end), x(int {x = "totor", x = 5} , -nil)), x = if x() then let var x := 5 in end else x[nil]} 
x.x.x.x.x.x(if int {x = int [x.x()] of int ["totor"] of break}  then while x.x := x.x() do int [x(5, nil)] of let  in 5 end, (for x := for x := nil to () do 5 to (5) do while 5 do ()))
while if x[break].x := (5) then for x := x() to for x := new int to x() do while 5 do "totor" do x[break] else (x) do new int
var x : int := if 5 then "totor"
class x {var x := 5 var x := 5} 
x(if let import "empty.tih" in end then for x := (break ; 5) to x.x.x() do int {x = x.x((), 5)}  else x(-if () then break else break, int [()] of nil/int {x = ()} ), x.x[int [5] of 5][int {} *new int].x())
while (if x.x(5, break) then x() else -"totor" ; x()) do x()
type x = class extends int{var x := 5}
int {x = (x()), x = if let import "empty.tih" in end then x[break].x := x.x.x(int [nil] of "totor", int {x = "totor", x = ()} )} 
let function x(x : int) = -break function x() = 5 var x := 5 in end
function x(x : int, x : int) : int = x() class x {var x := 5}  class x {} 
let class x extends int {var x := 5}  in end
type x = {x : int}
if while for x := let var x := 5 in 5 ; 5 end to int {x = int {} , x = x()}  do x[nil] := x((), nil) do let import "empty.tih" in x("totor", nil) ; 5 ; 5 end then -int {x = x.x}  else if if x() then x.x then if -while "totor" do () then x.x := int {}  else int [-while 5 do break] of x[()] := int {x = ()} 
type x = {x : int}
class x extends int {var x := 5} 
x.x.x.x.x.x()
function x(x : int) = (nil) class x extends int {var x := 5}  function x() = nil var x := 5
function x(x : int, x : int) : int = if (5) then (5) type x = {}
function x(x : int) = int {}  type x = array of int function x() : int = "totor"
for x := int {x = new int}  to x() do x.x[let  in end][x()]
x(for x := --int {x = "totor"}  to for x := while if () then break do let  in 5 end to int {}  do int [if () then break] of new int do if while int [nil] of break do if "totor" then "totor" then x.x := int [nil] of "totor" else let var x := 5 in end, let class x extends int {}  import "empty.tih" in end)
x[()][x()][let var x := 5 in end][x[nil][let  in end]].x(x(let import "empty.tih" var x := 5 in int {}  end, x(x.x.x(), let var x := 5 in "totor" ; 5 end)), new int)
function x(x : int) : int = int [new int] of while 5 do nil
class x extends int {var x := 5} 
function x(x : int) = x[break] := x.x()
var x : int := x.x() class x extends int {var x := 5}  class x extends int {} 
class x {var x := 5 var x := 5} 
function x(x : int) : int = x.x.x(x, x("totor", "totor")) var x : int := break
function x(x : int, x : int) : int = int {x = (5), x = -nil} 
function x(x : int) : int = ()-5/x.x(break, break) class x extends int {var x := 5} 
class x {var x := 5} 
if x.x.x[int [let  in end] of x := nil].x() then let var x := 5 in end
class x {var x := 5}  class x {var x := 5}  class x extends int {}  import "empty.tih"
class x extends int {var x := 5}  var x : int := nil class x {} 
class x {var x := 5 var x := 5}  class x {var x := 5}  function x() = nil
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5} 
class x {var x := 5}  var x := () function x() : int = ()
if for x := x.x[let  in 5 end] to x.x.x(int [()] of (), ()*5)+int [x()] of int {x = 5, x = 5}  do let import "empty.tih" in x.x((), nil) end then x(int {x = x := 5} -let var x := 5 in () end, let var x := 5 var x := 5 in int {x = (), x = 5}  ; 5 ; 5 end) else int [x[()][x.x()].x(x["totor"] := let  in 5 end, x(if () then nil else break, int [nil] of break))] of -if x := nil then if nil then 5 else -nil
int [if x[5].x.x() then x[break].x := int {x = int {x = "totor", x = nil} } ] of int {x = -if let  in end then if nil then 5 else () else x, x = if if break+() then if "totor" then () else x("totor", nil) then if let  in end then break|() else -int {x = nil} } 
class x extends int {var x := 5 var x := 5} 
if for x := if let var x := 5 in end then x[break] := x((), nil) else while if "totor" then nil do x() to -x.x do x(-int [break] of break, new int) then (let var x := 5 in break end) else new int
int [x(int {x = int {x = x(), x = for x := 5 to () do ()} } , while int [x()] of x.x((), nil) do while "totor"-() do -5)] of int [let import "empty.tih" var x := 5 in if "totor" then () end] of x.x.x.x(x.x := let  in 5 end, for x := -break to new int do nil|5)
type x = int
var x : int := x.x(5, break)
type x = int class x extends int {var x := 5}  var x := 5
while if if x[break].x((5), x) then -if break then break else "totor" else x.x then let var x := 5 var x := 5 in for x := "totor" to "totor" do "totor" end else -int {x = new int}  do new int
function x(x : int, x : int) : int = (() ; 5) class x {var x := 5} 
type x = class {var x := 5} class x {var x := 5} 
function x(x : int, x : int) : int = if int {x = "totor"}  then new int else (5) var x : int := "totor" type x = int import "empty.tih"
function x(x : int, x : int) = for x := -5 to (5) do let  in end class x {var x := 5}  class x extends int {} 
class x {var x := 5 var x := 5}  var x := ()
if int {x = new int, x = x[break].x}  then if let import "empty.tih" in end then --nil|while if () then () else "totor" do -"totor"
x["totor"].x.x[x["totor"].x].x(int {} , for x := int {}  to x(x[5], new int) do if new int then let var x := 5 in nil ; 5 end else x[nil] := x)
x.x[x()][("totor" ; 5)].x
type x = int class x extends int {var x := 5}  class x extends int {} 
if x.x[int [()] of ()].x.x() then int {x = let var x := 5 in end} 
class x {var x := 5}  var x := "totor"
(x.x.x := int {}  ; x.x.x())
class x {var x := 5 var x := 5}  function x(x : int) = x.x()
x(while new int do x(-new int, if while () do "totor" then let  in end), (x.x := if nil then "totor" ; if nil then () ; 5))
var x : int := while nil do "totor" type x = int function x() : int = "totor"
x[()].x.x.x.x(if let var x := 5 in 5 ; 5 end then x(if 5 then "totor" else nil, ()+5)-x(), x.x.x.x.x())
function x(x : int, x : int) : int = -5&int [5] of break var x : int := () var x := 5
class x extends int {var x := 5} 
x[5][let  in 5 end].x.x := let type x = int var x := 5 var x := 5 in end
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
x.x.x.x[(x := "totor" ; "totor" ; 5)].x()
-if x(-if 5 then nil, int {x = while 5 do 5, x = for x := nil to "totor" do ()} ) then int {x = int {} }  else -int {} 
let type x = class {} function x() = nil in int {}  ; x.x.x() ; nil-nil end
function x(x : int, x : int) : int = x((5), new int)
x()
class x {var x := 5 var x := 5} 
type x = int var x := nil
(int {x = x()} )
int {x = x(), x = x(x[5].x, x[nil][let  in end])} 
function x(x : int, x : int) : int = x[nil].x(if "totor" then break, let  in end)
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = int [5] of nil type x = int var x := 5
x(for x := while x[()] := x() do let var x := 5 in nil ; 5 end to int [x(x.x(nil, 5), new int)] of x() do int {x = new int, x = if "totor" then () else ()} /-x(), x(if let var x := 5 in end then int {}  else int {x = int {} } , new int))
class x extends int {var x := 5}  type x = class {}
(x(new int, while int {x = 5, x = 5}  do int {} ) ; int {x = int [break] of "totor", x = new int}  ; while () do () ; break ; 5)
type x = class extends int{var x := 5} class x extends int {var x := 5}  class x {} 
class x {var x := 5 var x := 5} 
if while new int do x.x.x := int [let  in 5 end] of for x := nil to break do () then int [x((5)*(5), int {x = new int, x = for x := () to break do nil} )] of while x.x.x() do x(int {x = 5} , x()) else x.x.x[x()] := let var x := 5 var x := 5 in (5) end
x[break][int {} ].x.x
function x(x : int) = x.x.x(int {} , let  in 5 end)
class x {var x := 5} 
type x = class extends int{var x := 5} function x(x : int) = x.x() var x := 5 import "empty.tih" var x := 5
function x(x : int, x : int) = if int {x = (), x = 5}  then int {x = "totor"}  else for x := break to () do "totor"
int {} 
type x = class extends int{var x := 5} var x := 5
class x extends int {var x := 5 var x := 5}  type x = class extends int{} function x() = () var x := 5
type x = class extends int{var x := 5}
type x = array of int
x.x.x[x[5]][x.x.x := let var x := 5 in 5 ; 5 end].x(if x.x[while () do nil].x() then x.x[int ["totor"] of nil].x() else x[nil].x.x(new int, let var x := 5 in end), x()+x.x-(() ; 5))
let function x(x : int) : int = if 5 then break in x.x[x] ; -new int ; int [5] of 5 ; () ; 5 end
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  class x {}  import "empty.tih" var x := 5
function x(x : int) : int = x.x.x()
x(x(int [x.x.x()] of int [(5)] of x(), x.x.x.x(for x := x.x() to int {x = ()}  do x := 5, let var x := 5 in break end)), new int)
function x(x : int, x : int) = if int {x = break, x = break}  then x
class x {var x := 5}  function x(x : int) = x := () var x := 5
var x := for x := break to break do break
function x(x : int) = int {x = x.x(nil, break), x = x.x()}  class x {var x := 5} 
class x {var x := 5 var x := 5}  type x = {} function x() = 5 var x := 5 var x := 5
function x(x : int) : int = (() ; 5)
type x = {x : int}
var x := let  in end class x {var x := 5}  function x() : int = 5
function x(x : int, x : int) : int = x.x
function x(x : int) : int = x()
int {x = x[5].x.x, x = x(for x := x[nil] to x[5].x(if nil then "totor", int [()] of ()) do let var x := 5 in "totor" end, x.x.x.x(for x := let  in end to x do x(), x(let  in end, int {x = (), x = nil} )))} 
class x extends int {var x := 5 var x := 5}  var x : int := break
function x(x : int, x : int) : int = int {x = -(), x = x(break, nil)} 
class x {var x := 5}  var x : int := 5
function x(x : int) : int = int {x = (5), x = if break then 5}  class x extends int {var x := 5}  class x {} 
class x {var x := 5 var x := 5} 
function x(x : int) : int = let var x := 5 in end
while int {x = int {} }  do new int*-x(let var x := 5 in end, x.x.x())
int {x = int [x[break][int {x = nil, x = ()} ].x((() ; 5), for x := let  in 5 end to if () then 5 else () do for x := nil to "totor" do ())] of if (break) then -()*"totor", x = int {x = int [new int] of new int} } 
x()/for x := let var x := 5 in end to x.x.x(x, break*break) do while x.x((), 5) do if () then ()+int {} 
(let import "empty.tih" var x := 5 in end ; x.x.x((5), new int) ; int {x = ()} )
for x := if x.x := x := break then new int to x(new int, while for x := () to break do nil do int {} ) do (if nil then nil else 5 ; () ; 5)/int [let import "empty.tih" in end] of new int
x.x.x[x[5] := let  in end][int {} ].x(-x.x[x()], while x.x.x() do int {x = int [break] of "totor"} -x.x[x()].x(for x := x() to if 5 then 5 else 5 do x(), if break+"totor" then -break else new int))
x["totor"][if break then 5 else nil][x(x(), for x := break to nil do ())].x.x(x(int {x = new int} , x[nil].x), -if x["totor"] then -int {x = "totor", x = break}  else for x := int [break] of "totor" to x(nil, break) do new int)
function x(x : int, x : int) : int = while if 5 then break do let  in end
int [while x(let var x := 5 in end, x.x.x(x(break, ()), (5))) do int [for x := if break then nil to int {x = nil, x = break}  do new int] of -x(5, 5)] of while int [let var x := 5 in end] of int {x = int {x = nil} , x = x}  do x[5][if 5 then break else break].x(x(let  in 5 end, int [break] of "totor"), if (5) then -break else x(break, "totor"))
function x(x : int, x : int) = for x := if break then 5 to 5-break do x((), 5)
x[5][while "totor" do break][x()].x.x(x(x(), x[break].x.x(for x := nil to nil do "totor"-if () then break else (), int [if 5 then break else nil] of while "totor" do nil)), x(let import "empty.tih" var x := 5 in end, x[()].x.x(int {} , x := "totor"-int ["totor"] of break)))
while --x[5] do x["totor"].x.x.x(int {} , int {x = x(x.x(), x := "totor"), x = (() ; 5)} )
int {x = x[break].x.x := for x := if int {}  then -() to let var x := 5 in end do x(), x = int [new int] of int {x = x(), x = let var x := 5 in end} } 
var x : int := if "totor" then break else nil class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int, x : int) = int {x = -break}  var x := () function x() : int = 5 var x := 5 var x := 5
if x() then x.x.x.x else new int&int {x = x.x, x = for x := x := nil to int [()] of break do if nil then "totor"} 
int {x = x[nil][if nil then "totor"].x(new int, x())&-x(while break do break, new int), x = x[5].x[(nil ; 5)].x(int {} , x[nil].x := for x := x.x() to int {x = 5, x = nil}  do int {x = "totor", x = "totor"} )} 
class x extends int {var x := 5} 
(while x() do x.x()-int {}  ; x[break].x(while () do nil, break-()) ; (5))
var x : int := if "totor" then () else "totor" class x extends int {var x := 5}  var x := 5 import "empty.tih"
int [new int] of new int
while if int {x = for x := let  in 5 end to x.x(nil, "totor") do x.x(), x = x()}  then while int {x = -"totor", x = int {x = 5, x = break} }  do new int else x.x[while 5 do break].x(x.x := x.x((), 5), int {} ) do x()
function x(x : int, x : int) : int = for x := let  in 5 end to int {x = 5}  do x.x(break, break) function x(x : int) = for x := () to () do "totor"
if let var x := 5 in (nil ; 5) end then x["totor"].x.x
function x(x : int, x : int) : int = let var x := 5 in break end
x.x[while 5 do nil].x.x.x()
var x : int := x.x()
function x(x : int, x : int) : int = x["totor"] class x {var x := 5}  class x extends int {}  var x := 5
function x(x : int, x : int) = x.x.x(x(5, 5), int [5] of "totor") class x {var x := 5}  type x = int import "empty.tih" var x := 5
--x(if if break then "totor" else "totor" then let  in end, let var x := 5 in 5 end)
new int
int [if if for x := while () do () to -break do x then x[5].x(int {x = "totor", x = "totor"} , -nil) else x.x := if "totor" then "totor" else "totor" then x.x.x.x(let var x := 5 in 5 ; 5 end, int [x.x(nil, "totor")] of break|()) else while x(if "totor" then nil else "totor", x := nil) do for x := let  in 5 end to new int do (5)] of int {x = if (()) then if int {}  then int {x = break, x = "totor"}  else int {x = (5), x = let  in 5 end} } 
x.x[()-"totor"].x[if x(new int, x.x(break, "totor")) then if int {}  then int {x = ()} ].x()
int {} 
new int
class x extends int {var x := 5 var x := 5}  type x = class extends int{}
function x(x : int) = int {}  function x(x : int) = if "totor" then break else nil class x extends int {} 
int {x = -if let var x := 5 in "totor" ; 5 end then let var x := 5 in end, x = while x[5][let  in end] do let import "empty.tih" in end} 
var x : int := x function x(x : int) : int = -"totor" type x = int
let class x {var x := 5}  function x() = () import "empty.tih" in end
--let var x := 5 in while 5 do "totor" end
x(x.x.x[let var x := 5 in 5 end].x(x(int [x((), 5)] of int {x = break, x = ()} , (break)), x[break][x := 5]), x[break][break&break].x := x())
int {} 
int {} 
(x[break].x)
for x := new int to -int {x = new int} +int [-nil-5|()] of int [x] of x.x() do x.x.x[let var x := 5 in end]
new int
class x extends int {var x := 5 var x := 5} 
let class x {var x := 5}  in x(x[nil].x(), if let  in 5 end then x.x("totor", nil)) ; int {x = x.x(), x = let  in end}  end
class x extends int {var x := 5}  var x := 5 class x {}  import "empty.tih"
if int {x = x["totor"].x(), x = x[()]} /(x := break) then x[break].x.x
x[5].x.x.x.x(let class x {}  var x := 5 in end, x["totor"].x[let var x := 5 in end] := -x(int {} , if nil then nil else 5))
if int {}  then int {x = -(() ; 5)}  else int {} 
while int [let var x := 5 in end] of x() do int [x()] of -x()
class x extends int {var x := 5 var x := 5}  var x : int := break
if x.x[if "totor" then "totor" else 5][-x.x(5, ())].x(if if while "totor" do break then let  in end then x&x := "totor", int {x = for x := let  in end to nil&() do for x := 5 to () do 5, x = int {x = int ["totor"] of (), x = "totor"-break} } ) then int {x = if --break then let var x := 5 in end, x = let import "empty.tih" var x := 5 in end} 
if x.x.x.x := for x := (()) to int {x = x("totor", break), x = for x := break to 5 do break}  do if -break then x() then for x := x.x[x.x(break, "totor")] := if -break then int {x = break, x = break}  to -let var x := 5 in end do let var x := 5 in x(break, nil) end else while int {}  do x(-"totor", int {x = "totor"} )-x[nil].x()
function x(x : int, x : int) : int = x["totor"] := for x := () to 5 do nil
class x {var x := 5} 
function x(x : int) = int {x = x}  var x : int := "totor"
let function x(x : int) = new int in end
while if for x := int {}  to x() do for x := if 5 then nil else break to let  in 5 end do if nil then break then x[5].x.x() else while for x := int {}  to int [break] of nil do if break then break else 5 do if int ["totor"] of 5 then x do int {} 
function x(x : int, x : int) = if (5) then if break then break else break else if "totor" then nil else nil class x extends int {var x := 5}  function x() : int = () var x := 5 var x := 5
class x extends int {var x := 5} 
-int {} 
var x : int := 5&5
x.x.x[x()][int {} ].x()
-let class x extends int {}  in end
type x = array of int
x[nil][int {x = (), x = 5} ][int {x = if break then break else "totor", x = x.x()} ].x := let class x {}  in x.x.x((5), int {x = break} ) ; (5) ; break end
class x {var x := 5 var x := 5} 
var x := for x := break to "totor" do nil
class x {var x := 5} 
let type x = class extends int{} in x() ; x.x end
x["totor"].x[x[()].x(if () then (), let  in end)].x.x()
class x {var x := 5 var x := 5} 
function x(x : int) : int = (break)
x.x[x.x(nil, break)].x.x.x(x[5][break+break].x.x(int {x = let var x := 5 in end, x = for x := int {}  to if nil then 5 do let  in end} , x.x[int {x = nil, x = break} ].x()), x())
let type x = class {} in end
class x {var x := 5 var x := 5}  function x(x : int) : int = for x := "totor" to nil do () type x = int
if x() then int {} 
x()|x()
let function x(x : int) = x.x(nil, "totor") in let var x := 5 in end-x[break].x() ; int {x = if "totor" then "totor", x = new int}  ; new int ; break ; 5 end
class x {var x := 5 var x := 5}  function x(x : int) = while nil do nil class x extends int {} 
let function x(x : int) = new int in end
var x := while "totor" do () type x = array of int function x() = ()
-int [int {} ] of new int
function x(x : int) = if let  in end then nil/nil function x(x : int) = x := ()
x.x.x.x[x.x.x()-x(x := break, int {} )].x(while x(()-nil, let  in end) do x.x.x(for x := break to () do "totor", x((), nil))&x["totor"].x, int {x = x.x.x} )
function x(x : int, x : int) = int {}  var x := "totor" class x extends int {}  import "empty.tih"
int [int {x = let import "empty.tih" in end, x = int {x = x(let  in end, x := "totor")} } ] of (x() ; while "totor" do "totor" ; ())
x.x.x.x[x(int {x = let  in end} , let var x := 5 in end)]
type x = class {var x := 5}
x[nil][x.x((), break)].x.x := (x.x)
x()
x[nil][x()][new int-x]+let class x extends int {}  var x := 5 var x := 5 in end
if x[break][int ["totor"] of "totor"][while (5) do int {} ] := x[5].x(int {} , let  in end)|let var x := 5 in end then (new int)
x.x.x[for x := x() to let  in 5 end do int {x = "totor", x = "totor"} ].x.x()
int {} 
while x[5][-nil].x.x(x[nil][x.x()].x(), (x())) do let function x() = 5 in int {x = int {} }  ; x.x(nil, "totor") ; () ; 5 end
class x {var x := 5 var x := 5}  function x(x : int) = (5) function x() : int = () var x := 5 var x := 5
type x = class extends int{var x := 5} var x := () class x extends int {}  var x := 5
class x extends int {var x := 5 var x := 5}  function x(x : int) = 5&5 class x {} 
int {} 
x()
var x : int := x("totor", nil)
(int {}  ; new int)
x[5].x.x/x["totor"].x[int {x = x.x()} ].x()
while x() do new int
while int {}  do for x := for x := x(int {x = "totor"} , x((), "totor")) to if for x := break to nil do () then int {x = break}  else x.x("totor", nil) do if x() then x() to if x["totor"] then int {}  else x["totor"] := if 5 then 5 do for x := x((), break) to if nil then "totor" do int {x = "totor"} |x(new int, x.x())
let var x := break in x.x[x(break, ())] ; x.x.x() end
function x(x : int) = for x := x(nil, 5) to int ["totor"] of nil do (5)
type x = int class x {var x := 5} 
x.x.x[int {x = new int} ].x.x(x.x[x].x := x.x[x := break] := -if 5 then nil, if x.x[for x := 5 to "totor" do 5] then for x := int {x = "totor"/"totor", x = int {} }  to x[break].x(for x := 5 to nil do "totor", x.x()) do x())
function x(x : int, x : int) = for x := x(break, ()) to x do x class x extends int {var x := 5} 
-let function x() = "totor" var x := 5 var x := 5 in for x := if "totor" then "totor" else nil to let  in end do break|5 ; let  in 5 end ; nil end
class x {var x := 5 var x := 5} 
x()
class x extends int {var x := 5 var x := 5} 
if new int then x["totor"][x].x.x(int {} , new int) else int {} 
class x extends int {var x := 5 var x := 5} 
let class x extends int {var x := 5}  in x() end
-int {x = -x(let  in 5 end, int ["totor"] of ())} 
int {} 
x["totor"][int {x = 5, x = break} ][while x.x((), break) do int {} ].x.x()
for x := int {x = new int}  to (let var x := 5 in end ; x := 5 ; 5) do for x := int [-break|(5)] of for x := x.x((), nil) to int [nil] of "totor" do x(5, 5) to int {} &if x.x(5, ()) then if 5 then 5 else () else int ["totor"] of () do let var x := 5 var x := 5 in for x := 5 to nil do "totor" ; 5 end
for x := for x := int {x = (nil)}  to new int-int {x = (5)}  do x() to int {x = x.x.x := for x := int ["totor"] of 5 to int {}  do for x := () to 5 do nil}  do int {} 
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = x.x() class x {} 
(x.x.x)
if int [int [int {} ] of int [nil] of ()|int {x = "totor", x = break} ] of x[()][x := nil] := (nil ; 5) then while x.x.x do int {} 
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
int {x = -int [x()] of x(5, ())} -x(x[5].x.x(), x.x.x)
function x(x : int, x : int) : int = x() type x = int
int {x = let class x extends int {}  var x := 5 in while "totor"|break do int {x = break, x = break}  ; if break then nil ; break end, x = let class x {}  in (break ; 5) end} 
function x(x : int) : int = let var x := 5 in end
var x : int := x()
function x(x : int, x : int) = (nil)
function x(x : int, x : int) : int = int {x = for x := nil to 5 do break, x = x()}  function x(x : int) : int = x()
type x = class extends int{var x := 5}
class x {var x := 5 var x := 5} 
for x := int {x = x(int {x = int {} } , while -() do if break then nil), x = x.x.x}  to x() do (if -"totor" then x() else int [break] of 5)
for x := if new int then for x := let var x := 5 in end to let var x := 5 in break ; 5 end do new int else int {}  to x() do let var x := 5 in int [let  in 5 end] of let  in 5 end end
class x extends int {var x := 5 var x := 5} 
int {x = x.x.x.x.x(if while new int do (5) then int {x = if break then "totor"}  else if if 5 then 5 then x((), ()) else int {x = ()} , x(int {} , x["totor"].x(x.x((), 5), x()))), x = int {} } 
while x() do new int
int {x = new int} 
function x(x : int, x : int) : int = if -nil then 5-() else x.x() type x = class {}
x[break].x[let var x := 5 in break end].x := for x := (-nil) to int {x = x("totor"+nil, -"totor"), x = -break|nil}  do -x(new int, if break then nil else break)
function x(x : int, x : int) : int = (5 ; 5) class x extends int {var x := 5}  class x extends int {} 
while int {x = if int {x = let  in 5 end}  then if break*5 then -() else let  in 5 end, x = if for x := "totor" to 5 do 5/int {}  then int {}  else x["totor"] := if break then break}  do x.x.x[int {x = -"totor"} ].x(let var x := 5 in end, int {} )
-x()
function x(x : int, x : int) : int = for x := int {}  to (5) do (5)
var x := x := "totor"
let class x {var x := 5}  in int {x = -while "totor" do break, x = x["totor"]}  end
let type x = int in end
if (x[break] ; x(break, "totor") ; "totor" ; 5) then x.x[nil/break][int [x((), "totor")] of x()]
function x(x : int, x : int) : int = x[5].x((5), x) class x extends int {var x := 5} 
int {x = x.x.x.x, x = -int {x = int [int {} ] of x()} } 
function x(x : int) : int = (()) var x := break
type x = {x : int}
class x {var x := 5} 
class x extends int {var x := 5 var x := 5}  var x := break class x extends int {}  import "empty.tih"
if int [(x.x())] of let var x := 5 var x := 5 in x.x(break, 5) ; 5 end then int {x = x[()].x(int ["totor"] of break, new int)+int {x = x} , x = let var x := 5 in end-int [new int] of for x := () to "totor" do ()} 
var x := int ["totor"] of break
function x(x : int, x : int) = let var x := 5 in "totor" end
x[()].x.x.x(while x() do new int, new int)&int [x[break].x] of x.x[x].x()
function x(x : int) : int = while if 5 then 5 else break do x function x(x : int) = x.x(5, break) function x() : int = "totor"
type x = {x : int} var x := 5
function x(x : int) = if x.x("totor", ()) then int [nil] of "totor" else int {}  class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
class x extends int {var x := 5 var x := 5}  type x = int function x() = 5 var x := 5
class x extends int {var x := 5} 
function x(x : int, x : int) = int [let  in end] of int {x = nil, x = break}  function x(x : int) = for x := 5 to break do break class x {} 
class x {var x := 5 var x := 5} 
int {x = for x := int {x = new int}  to (x := ()) do int {x = x(), x = while x do if 5 then () else "totor"} , x = x.x[x.x(break, break)].x.x()} 
x.x[x.x()].x[for x := int {x = 5|nil, x = let  in end}  to if while "totor" do break then "totor"+() do x[nil] := new int].x(let var x := 5 in end, for x := int {x = 5, x = nil}  to if "totor" then "totor" do int {x = nil, x = break} /x()-while x(let  in 5 end, if "totor" then 5) do let var x := 5 in end)
-int {x = (5-5 ; "totor")} 
new int
int [new int] of int {x = x(int {x = if break then "totor" else "totor"} , int {x = x.x("totor", break)} )} 
function x(x : int, x : int) = int {x = x("totor", "totor"), x = int {x = break} } 
type x = class extends int{var x := 5} type x = array of int function x() = 5 var x := 5
class x extends int {var x := 5 var x := 5} 
let function x(x : int) : int = int {}  in end
for x := x.x.x.x to for x := x(let var x := 5 in end, int {x = x.x()} ) to int [int {x = x} ] of int {x = (5)}  do x.x := int ["totor"] of nil&x() do -if if int ["totor"] of nil then int {x = break, x = nil}  then x[break] := new int else (break)
int {x = x(), x = if let import "empty.tih" var x := 5 in x.x(break, ()) end then int {x = int {} }  else x(if int [()] of nil then let  in end, int {x = x("totor", break), x = x.x()} )} 
for x := int {x = -if let  in end then int {}  else while () do 5}  to new int do let function x() = break in end
int [x[5][if break then 5][let var x := 5 in "totor" ; 5 end].x(int {x = new int, x = -x()} , let import "empty.tih" in end)] of x[()][(5)].x.x()
type x = {x : int}
let type x = int class x {}  var x := 5 var x := 5 in x(let var x := 5 in end, if if "totor" then () then new int else x(5, 5)) end
class x {var x := 5}  class x extends int {var x := 5}  function x() : int = nil
-(if int [()] of () then let  in 5 end else let  in 5 end)
class x extends int {var x := 5 var x := 5}  type x = {} class x {} 
class x {var x := 5 var x := 5} 
type x = class extends int{var x := 5}
function x(x : int) = while int {x = ()}  do if 5 then nil
x((while x.x() do if 5 then () else nil), -while while "totor" do "totor" do -nil*for x := (nil) to -int {}  do int {} )
int {x = (x(break, 5)+int {x = nil, x = break} )} 
function x(x : int, x : int) = (())
class x extends int {var x := 5 var x := 5} 
function x(x : int) : int = x.x.x()
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() = break var x := 5
type x = class {var x := 5} class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  type x = array of int
function x(x : int, x : int) = int {x = x("totor", ())}  function x(x : int) = new int function x() : int = "totor" import "empty.tih"
int [for x := x.x.x := let var x := 5 in break ; 5 end to -new int do for x := int {x = if () then break else "totor"}  to int {}  do x[5] := for x := break to 5 do 5] of x()
x[break][x.x()].x()*let import "empty.tih" in new int ; 5 end&for x := new int to let var x := 5 in if () then 5 else "totor" ; () ; 5 end do let import "empty.tih" var x := 5 in end
x.x.x.x[int {x = x()|for x := "totor" to () do "totor"} ].x()
x()
int {x = x[5].x[int {x = new int, x = let  in 5 end} ].x(if (break ; 5) then int {x = x.x((), nil)}  else -int {} , x[5][x.x()])} 
x.x[x.x("totor", "totor")][let var x := 5 in end][new int].x(-for x := while -nil do let  in end to while (5) do (5) do for x := while 5 do () to if "totor" then 5 do int {x = "totor", x = nil} , --let var x := 5 in "totor" end)
while let class x {}  in new int ; x.x() ; break end do for x := (()*nil ; () ; 5) to x.x := if "totor" then nil+x.x.x() do x(x[break], (break))
let function x() = break import "empty.tih" in end/x()
int {} 
int {} 
function x(x : int) = int {x = let  in 5 end} 
function x(x : int, x : int) = int {x = -"totor"}  class x {var x := 5}  class x {} 
for x := let class x extends int {}  in x.x.x() ; if "totor" then () end to x[break]["totor"+()] := x["totor"] := int {x = break, x = ()} &-int {x = -5}  do x(int {} , if if new int then int {}  then if for x := "totor" to nil do 5 then new int else int ["totor"] of "totor")
class x extends int {var x := 5 var x := 5} 
var x := for x := 5 to "totor" do break function x(x : int) = let  in end
function x(x : int) = for x := int [5] of break to x := () do -()
x.x.x[(5 ; 5)].x.x(for x := int [x.x] of int {x = let  in end}  to while while let  in 5 end do if () then break else "totor" do if x then let  in 5 end do for x := new int to int [x.x()] of x.x() do int {x = int {} } , if int {x = x.x, x = x.x.x()}  then x.x[int {x = (), x = break} ] else (int {} ))
x.x[int [nil] of "totor"].x.x
class x {var x := 5 var x := 5}  class x {var x := 5}  function x() : int = "totor" import "empty.tih" var x := 5
function x(x : int) = for x := "totor"+() to int {}  do x() var x : int := ()
function x(x : int, x : int) = int {x = x := ()}  var x := 5
int [let import "empty.tih" in end&let var x := 5 in ()/5 ; () end] of (if if "totor" then "totor" else 5 then -"totor")
class x extends int {var x := 5} 
function x(x : int, x : int) : int = if if () then "totor" then -5 else x() function x(x : int) = (5)
class x {var x := 5} 
class x {var x := 5 var x := 5} 
x(let function x() = () in end, int {x = if for x := let  in 5 end to for x := () to break do nil do x.x("totor", "totor") then x.x} )
type x = class extends int{var x := 5} var x : int := () class x {}  var x := 5
let var x := break in end
type x = class extends int{var x := 5}
function x(x : int) : int = x.x.x(while "totor" do break, x(nil, ())) class x extends int {var x := 5}  type x = int import "empty.tih" var x := 5
type x = class extends int{var x := 5} class x {var x := 5}  type x = int
type x = {x : int}
x[nil][int {x = (), x = "totor"} ][if x.x(break, ()) then nil*nil else x()].x.x()
x()
int {x = -if x() then int {x = x("totor", nil)}  else int {x = if "totor" then "totor" else break} , x = int {x = if int {x = int {x = nil} }  then if x() then if "totor" then break else x.x := x.x("totor", 5), x = int {x = int [x := 5] of (5), x = while x do x.x()} } } 
x.x.x.x.x := x.x[let  in end].x.x(-for x := x() to int {}  do x := (), x(x.x.x(), while if "totor" then () else break do let  in 5 end))
function x(x : int) : int = int {x = x, x = new int} 
class x extends int {var x := 5}  type x = array of int
type x = class {var x := 5}
for x := if if x(int {x = break, x = ()} , let  in end) then int {x = while nil do nil}  then while int {}  do new int else while let  in 5 end&x := break do if new int then x to for x := if x() then while int {x = ()}  do x() else x["totor"] := int [5] of break to if let var x := 5 in end then new int do int [x()] of x(int {x = nil, x = ()} , x.x()) do for x := let var x := 5 var x := 5 in int {}  ; nil end to int {x = x.x, x = x[()]}  do new int
x[break][while nil do "totor"][x[nil].x(x.x(break, ()), let  in 5 end)].x.x(x[nil][let  in end].x, (int [(5)] of 5&5 ; new int ; nil ; 5))
for x := while x(x[5].x(), x()) do int {x = int {x = 5, x = nil} -x.x((), ()), x = let var x := 5 in end}  to int [if x() then -5] of int {} &for x := x["totor"].x(-(), x := ()) to (5 ; 5) do if let  in 5 end then new int else if 5 then () else "totor" do while for x := x[5] := x((), break) to (nil ; 5) do if 5 then nil else "totor"/(5) do new int
while int [while x() do new int+5|()] of int {x = x.x.x()}  do if int {}  then x.x.x.x(x(), x(x := "totor", let  in end)) else if while if nil then () else break do -5 then x[break].x(x, int [()] of break) else x.x
x()
var x := int [5] of nil
x[nil][let  in end].x[int [int {} ] of x.x] := x()
(x[nil].x.x() ; x[5] ; x("totor", break) ; ())
type x = class extends int{var x := 5}
x.x[let  in 5 end].x.x.x(x.x.x[while (5) do new int].x(if x.x := x := "totor" then int {x = x()}  else for x := while nil do break to x do if "totor" then "totor", x.x.x := for x := int {x = nil, x = "totor"}  to x do for x := () to 5 do 5), let class x {}  in end)
class x extends int {var x := 5}  class x {var x := 5}  function x() : int = ()
((int [break] of 5 ; 5))
for x := (int {x = x((), "totor")}  ; x.x("totor", break) ; 5 ; 5) to x.x[x := ()].x.x() do (int {x = x(), x = -"totor"} )
x[break].x.x[x["totor"][if 5 then () else break] := x(if () then "totor", int {x = nil} )].x()
var x := int {x = nil} 
if while while int {}  do new int do x.x.x.x() then -x.x[for x := "totor" to break do break].x()
class x {var x := 5 var x := 5} 
if x[5][x := ()].x then int {x = int {x = new int, x = for x := int [5] of break to while break do "totor" do if 5 then 5 else nil} } 
class x extends int {var x := 5} 
int {x = new int} 
type x = class extends int{var x := 5} function x(x : int) : int = int {}  function x() = nil import "empty.tih"
x(x.x.x[int [while break do break] of x(break, "totor")] := for x := x[break].x() to new int do int {} , let function x() = nil var x := 5 var x := 5 in int {x = for x := () to nil do 5}  ; int {x = break}  end)
if -x() then int {} 
class x {var x := 5} 
for x := int {}  to if x(x.x.x(x("totor", nil), if break then break else break), int {} ) then let import "empty.tih" in end do if new int then int {x = int {x = int {} , x = ()*()} , x = let var x := 5 in end}  else x(let var x := 5 in end, while x("totor", break) do let  in 5 end)
function x(x : int) = ("totor" ; 5) function x(x : int) = new int class x extends int {} 
if x.x[let  in 5 end][x()].x(for x := x(while nil do break, (5)) to let var x := 5 in end do x.x.x(new int, while 5 do 5), x[nil].x.x(new int, x.x)) then if int {x = let  in end} |let var x := 5 in end then x[()].x := int {x = x.x()}  else x.x[break-5].x(if x() then if break then "totor" else "totor", for x := int {x = (), x = ()}  to int {}  do int {x = break} )
x.x[let  in 5 end][int {} ].x.x((x[5].x(x, x) ; while "totor" do nil ; ()), int {x = int {x = int {} } , x = for x := if if break then () else "totor" then int {x = ()}  else (5) to x["totor"] do x.x.x()} )
if let var x := 5 in end then let function x() : int = () var x := 5 in end else int {x = let var x := 5 var x := 5 in end} 
function x(x : int, x : int) = x.x()|x.x(5, ())
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  var x := 5
x.x.x[let var x := 5 in "totor" end][let var x := 5 in new int end] := for x := let import "empty.tih" in let  in 5 end ; break end to int {}  do -new int
int {x = new int} 
new int
let class x extends int {var x := 5}  in int [for x := -break to if nil then nil else 5 do (5)] of x[5].x() ; x(x := (), int {} ) ; for x := () to nil do nil ; 5 end
-for x := while if let  in end then x := 5 else let  in 5 end do (break ; 5) to int {}  do x((nil ; 5), x["totor"])
x.x.x.x.x.x(for x := x["totor"].x to let var x := 5 in 5*5 ; break ; 5 end do if x()/int [break] of nil then if x.x() then x else x := 5 else x[5].x(), x())
var x : int := break/break
class x extends int {var x := 5 var x := 5} 
x[()][if nil then 5 else ()][x[5].x(x, x.x())].x.x(x[5][int [()] of nil][new int].x(), x())
class x {var x := 5 var x := 5} 
class x extends int {var x := 5} 
let class x extends int {var x := 5}  class x extends int {}  in int {x = (5), x = if -5 then (5) else x()}  end
x[5].x[for x := x("totor", 5) to (5) do x()][x[nil][x(nil, break)] := x(int {} , (5))].x(int {} , x.x.x := while x() do int [break] of nil*x[break][(5)])
class x {var x := 5 var x := 5}  var x := nil function x() = "totor" var x := 5 var x := 5
type x = class extends int{var x := 5}
function x(x : int) : int = while x() do let  in 5 end class x extends int {var x := 5} 
function x(x : int, x : int) : int = let var x := 5 in () ; 5 end function x(x : int) : int = int {} 
type x = class {var x := 5}
class x {var x := 5 var x := 5} 
function x(x : int, x : int) = let var x := 5 in "totor" end
x()
class x {var x := 5}  type x = class {} function x() : int = 5
class x extends int {var x := 5 var x := 5}  function x(x : int) = x.x(break, break)
let function x(x : int) = new int in end
(int {x = int [while break do ()] of x} )
function x(x : int, x : int) = let var x := 5 in () ; 5 end
class x {var x := 5} 
int {} 
class x extends int {var x := 5 var x := 5}  var x : int := () function x() = 5
class x {var x := 5 var x := 5}  function x(x : int) : int = x.x(break, ()) class x extends int {} 
function x(x : int, x : int) : int = x.x.x(x(break, 5), x.x())
let class x {var x := 5}  in end
class x {var x := 5 var x := 5}  function x(x : int) = x.x()
if x.x.x.x() then x.x.x.x()|if -while x do let  in end then let var x := 5 in end else x[()][let  in end] := if 5 then 5 else 5&x := nil
class x {var x := 5} 
x.x[for x := () to () do "totor"].x.x.x(int {} , while for x := x["totor"] := int {}  to x[5].x() do int {}  do int {} )
class x {var x := 5 var x := 5} 
class x extends int {var x := 5} 
type x = class {var x := 5}
function x(x : int) = new int
int {} 
let function x(x : int) = while () do "totor" in (for x := nil to () do ()) ; let var x := 5 in end end
function x(x : int, x : int) = x[()] := x()
x[()].x[if break then () else 5|x].x
var x := new int class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
x[nil].x.x[let import "empty.tih" var x := 5 in int ["totor"] of nil end].x(-let import "empty.tih" var x := 5 in end, new int|int {} )
class x {var x := 5} 
int {x = -(int {} ), x = -if let var x := 5 in end then x("totor", nil)*int {}  else x[nil].x()} 
class x {var x := 5}  class x {var x := 5} 
int [x(x(), (let  in end ; nil))] of x()
x()
class x extends int {var x := 5} 
-int {x = int {x = x(), x = x.x := if nil then nil else ()} , x = new int} 
let var x : int := nil var x := 5 in end
for x := if let var x := 5 in end then new int else let var x := 5 in x.x() ; "totor" ; 5 end to if let import "empty.tih" var x := 5 in end then if x(new int, (5)) then x.x.x(x.x(), for x := () to () do ()) else x.x.x() do new int
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  var x := 5 import "empty.tih" var x := 5
type x = array of int function x(x : int) : int = x := nil function x() : int = break import "empty.tih"
type x = {x : int}
if x.x[let  in end].x.x() then x.x[while 5 do break].x
var x := for x := 5 to break do nil class x extends int {var x := 5}  type x = int
if x.x[x.x((), 5)].x.x(while while for x := "totor" to break do break do int {x = break}  do x[break].x(), int {} ) then let function x() : int = "totor" in int {x = x := nil}  end else if x() then x.x.x else let import "empty.tih" in let  in end ; nil end
int [x()] of for x := int [x["totor"].x(x(), while break do nil)] of let var x := 5 in 5 ; 5 end to x[5].x.x() do int {x = -if "totor" then break} 
for x := let class x extends int {}  in end to let function x() : int = () in end do int {} 
if x.x.x.x.x(int {} , if x.x := let  in end then let var x := 5 in break ; 5 end else let var x := 5 in "totor" ; 5 end) then x()
function x(x : int) = int {} 
function x(x : int) : int = x.x
class x extends int {var x := 5} 
while int {x = (if nil then 5 else break)}  do -x.x.x
function x(x : int) : int = while if nil then "totor" do let  in end
class x {var x := 5}  class x {var x := 5}  type x = int import "empty.tih" var x := 5
class x {var x := 5}  function x(x : int) = x(5, break) var x := 5
class x extends int {var x := 5}  class x extends int {var x := 5}  function x() = break var x := 5 var x := 5
function x(x : int, x : int) = new int
x["totor"][while () do break][int [int {} ] of (5)].x
function x(x : int) = x(if () then nil, for x := "totor" to 5 do break) function x(x : int) = nil-() function x() = "totor" var x := 5 var x := 5
var x : int := int {x = "totor"}  class x {var x := 5} 
function x(x : int, x : int) : int = int [new int] of -"totor" function x(x : int) : int = if 5 then 5 else nil
int {x = int {} , x = int {} } 
class x {var x := 5}  class x {var x := 5}  var x := 5 var x := 5
new int/let function x() : int = nil in x.x.x(x.x(), x()) end
x[()][x].x[x(let  in end*x.x(), x.x)] := if int {x = if () then "totor"-x.x(5, break)}  then let import "empty.tih" var x := 5 in int [break] of 5 end
x[break][x.x(5, break)][x()].x := int [while if while "totor" do () then for x := "totor" to "totor" do "totor" else -() do for x := int [break] of nil to while nil do nil do let  in end] of int {x = new int, x = x(let  in 5 end, if 5 then 5 else 5)} 
class x {var x := 5 var x := 5} 
var x := x() function x(x : int) = let  in 5 end
int {x = while (x.x() ; ()) do new int} 
var x := for x := break to break do () function x(x : int) : int = nil|nil
function x(x : int) = x["totor"].x()
function x(x : int, x : int) : int = x[5].x(int {} , let  in end) var x := break type x = int
type x = class {var x := 5} function x(x : int) : int = let  in end
-x.x.x[int {x = let  in end, x = int {} } ]
for x := x(int {x = int {} , x = let var x := 5 in end} , int {x = new int, x = x()} ) to x.x[x.x(nil, break)].x.x(x[5][int {} ], x(x.x(), if nil then "totor" else 5)-int {x = if 5 then break, x = if "totor" then nil} ) do x.x.x[int [x.x()] of -nil]
int [int [x((5), if break then () else break)] of let var x := 5 in end/x.x[while 5 do ()]] of int {x = x.x.x, x = for x := while let  in end do x(5, 5) to x() do x[break]} 
-x.x[nil+nil].x(for x := break|nil to for x := break to 5 do nil do if break then 5 else (), int {x = int {x = ()} , x = if () then nil else break} )/int {x = x[()].x(if break then 5, (5))} 
class x {var x := 5 var x := 5} 
while new int do let class x {}  var x := 5 in end
class x extends int {var x := 5 var x := 5}  function x(x : int) = (5)
int {x = int {x = x[5].x := x[5] := int {x = "totor"} , x = if new int then int ["totor"] of break/x := () else new int} } 
x[break][let  in 5 end].x.x
x[break][int {x = break} ].x.x
class x {var x := 5 var x := 5} 
x.x.x.x.x.x(int {x = if if let  in 5 end then -nil else break&5 then int {x = -(), x = x.x(break, break)}  else if for x := break to nil do break then int {x = nil, x = break}  else x.x()} , int [int {} |if int {}  then int {x = (), x = nil}  else let  in end] of x())
x.x[x(break, break)][x.x.x(x(), int {} )][if new int then x.x := let  in 5 end] := int {x = while x[nil].x() do while if nil then () else nil do x, x = int [int {x = nil} ] of if nil then nil else "totor"/x[5].x()} 
function x(x : int, x : int) = if while nil do nil then x.x() else x type x = class extends int{}
let var x := () class x {}  in end
function x(x : int, x : int) : int = x.x.x(if 5 then 5, -5) class x extends int {var x := 5}  type x = int import "empty.tih"
x[break]["totor"|break][x()][x(int [x.x((), nil)] of x(), x.x := let  in 5 end)] := x()
for x := int {}  to while for x := if int [()] of () then if break then break to if let  in 5 end then -break else let  in 5 end do --break do x.x.x.x() do new int
class x {var x := 5 var x := 5}  function x(x : int) : int = int {}  function x() = () import "empty.tih" var x := 5
x.x.x.x[x.x[while nil do ()].x()]
type x = {x : int} function x(x : int) : int = -break var x := 5
-(int {x = while 5 do 5} )
var x : int := if break then nil else break
function x(x : int, x : int) : int = x.x := int {x = 5, x = 5} 
type x = class {var x := 5} class x {var x := 5} 
x[break][x := 5].x[while for x := (5) to nil*"totor" do (5) do -x := nil].x()
function x(x : int) : int = if x("totor", "totor") then (5) else break-5 function x(x : int) : int = if nil then "totor" else "totor"
var x : int := x.x() var x := nil
class x {var x := 5 var x := 5} 
function x(x : int) : int = x[()].x() var x := ()
-int {x = x(), x = int {x = x(), x = if -() then x.x(5, ())} } 
if -x[break][int {} ].x() then new int else x.x[if "totor" then nil][new int]
let class x extends int {var x := 5}  class x {}  in end
class x {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) = for x := break to break do nil
x.x.x[(5)][new int].x()
int {x = x(x[()][if 5 then nil], new int), x = for x := int {x = if int {x = (), x = "totor"}  then x.x(5, nil), x = int [if 5 then nil] of let  in end}  to x.x.x.x(int {} , for x := "totor"&() to for x := "totor" to () do break do x := "totor") do (x.x())} 
x.x[int {x = nil, x = ()} ][x[nil].x(while () do nil, int [5] of ())][new int].x(while x() do x.x[int {x = break} ], let function x() : int = "totor" import "empty.tih" in end)
function x(x : int) : int = if -nil then x(break, "totor") else nil+()
x.x[int ["totor"] of ()].x.x.x()
function x(x : int, x : int) : int = for x := while () do () to int [()] of break do x.x() function x(x : int) : int = 5&"totor"
class x {var x := 5}  var x := "totor"
function x(x : int, x : int) : int = -new int
type x = {x : int}
let function x(x : int) = if nil then "totor" else "totor" class x extends int {}  in int {}  ; x[break].x() ; let  in end end
while int {}  do int {} 
int {x = new int} 
var x : int := int {}  class x {var x := 5} 
for x := x["totor"].x.x to int {x = int [int {x = int [nil] of break} ] of if if nil then break then if () then "totor" else x("totor", ())}  do int {} 
function x(x : int, x : int) = x.x class x extends int {var x := 5}  function x() = 5 import "empty.tih" var x := 5
class x {var x := 5}  var x := 5 class x {}  var x := 5
type x = class {var x := 5} class x {var x := 5}  var x := 5
function x(x : int) = let var x := 5 in end
x.x.x[x[nil].x()].x := -new int/int [if 5 then 5 else nil] of (5)
int {} 
function x(x : int, x : int) : int = int {} 
x["totor"][x].x[int [int {} ] of for x := nil&5 to ()|"totor" do for x := "totor" to "totor" do nil]
function x(x : int, x : int) = x() var x := nil function x() : int = "totor" var x := 5
if let type x = int in if (5) then while "totor" do 5 else int {}  ; x := () ; break end then while let var x := 5 var x := 5 in x.x(nil, nil) end do while while int {}  do x.x() do int {}  else int {x = -if break then "totor"} |-if if 5 then 5 else nil then x else while () do 5
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
var x : int := let  in end function x(x : int) : int = new int
function x(x : int, x : int) = -x.x(nil, break) function x(x : int) = -() class x {} 
type x = array of int function x(x : int) : int = let  in end function x() = "totor"
int {x = int {x = if while for x := break to break do () do let  in 5 end then x["totor"].x(), x = let import "empty.tih" in x() ; "totor" end} , x = x.x[x.x()][int {x = int {} } ] := let var x := 5 var x := 5 in if 5 then 5 else 5 end} 
var x := if () then nil
(x[break][let  in end] := let var x := 5 in end ; if 5 then "totor"+int {}  ; let  in end)
var x : int := int {x = "totor", x = "totor"}  function x(x : int) : int = x()
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  class x extends int {} 
x.x[new int][new int].x.x(x.x.x[for x := int [()] of break to int {}  do while nil do ()] := let import "empty.tih" in x("totor", 5) end, if x.x.x := -()+break-5 then int {} )
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
class x {var x := 5}  var x : int := nil
class x extends int {var x := 5}  class x {var x := 5} 
let function x() : int = 5 in end*let class x {}  in x.x end
class x extends int {var x := 5 var x := 5} 
x()
x.x[if "totor" then ()].x[-int {} ].x()
x(new int, x(x((break), int {x = int {} } ), int {} ))
class x extends int {var x := 5} 
type x = class {var x := 5}
-for x := x.x.x(int {} , x := ()) to if x((), nil) then -nil else x.x() do -x.x()|x.x.x.x()
class x {var x := 5 var x := 5} 
class x {var x := 5 var x := 5}  var x : int := ()
int {x = x(-if x := nil then -break else let  in 5 end, if x(int {x = "totor", x = 5} , new int) then x[()].x(x.x(), new int))} 
class x extends int {var x := 5} 
new int
function x(x : int, x : int) = x[5].x() function x(x : int) : int = x var x := 5
let function x(x : int) = int [()] of nil var x := 5 in x.x[if 5 then break else ()] ; x.x.x() end
x[5][x := 5].x[int [if int {}  then x()] of int {x = (5), x = let  in end} ]
x.x.x[if x(5, nil) then int {x = 5} ][x.x.x] := new int
function x(x : int) = x.x.x(-"totor", int {} ) function x(x : int) = x() function x() = ()
int [x.x.x.x.x((int {x = (), x = "totor"}  ; nil ; 5), x())] of x()/let var x := 5 in x.x(5, ()) end
class x extends int {var x := 5 var x := 5} 
while x() do if x["totor"]|x() then int {}  else while int {x = int [()] of break}  do x[()] := int {x = break, x = "totor"} 
class x extends int {var x := 5}  var x : int := 5
type x = class {var x := 5} var x := "totor" var x := 5
x.x.x[let var x := 5 in end][-int {x = if () then break else ()} ].x()
function x(x : int, x : int) = x.x class x {var x := 5} 
class x {var x := 5}  function x(x : int) = int {}  class x extends int {} 
class x extends int {var x := 5} 
var x := x := () function x(x : int) : int = x
let var x := () var x := 5 in end
new int&-x[()].x := int {} +-5
function x(x : int) : int = x.x.x()
x.x[x((), nil)][x()].x.x(int {x = x[()].x()-int [let  in 5 end] of (5), x = x.x[x(5, "totor")].x()} , new int)
int {x = x()/int [if let  in end then int {x = break}  else nil*()] of int {x = let  in 5 end, x = let  in 5 end} , x = let var x := 5 var x := 5 in let  in 5 end ; break ; 5 end-x.x[x := nil].x()} 
(new int ; x(let  in end, if "totor" then nil else 5) ; 5|break)
x.x[break&"totor"].x.x
let var x := 5 import "empty.tih" var x := 5 in x := ()+-5 ; int ["totor"] of 5 end&x[break].x.x.x()
var x : int := x.x() type x = int
function x(x : int, x : int) = if let  in 5 end then new int var x := nil class x {} 
var x : int := int {x = "totor"}  class x extends int {var x := 5}  class x extends int {} 
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5}  class x extends int {var x := 5} 
x.x.x.x.x
class x {var x := 5 var x := 5} 
for x := int [x.x] of let var x := 5 in break ; 5 end|let import "empty.tih" var x := 5 in 5|"totor" ; nil end to let type x = int var x := 5 var x := 5 in (()) ; let  in end ; 5 end do for x := let import "empty.tih" in end to int {x = int {} , x = x["totor"].x()}  do (break)|let var x := 5 in end
for x := x[nil].x[x[5] := new int].x() to let var x := 5 in (5) ; break end-(int {x = nil} ) do -new int|x.x := int {} 
int {x = int {} , x = x[5][x.x()][int {x = int {x = break} , x = int {x = nil, x = break} } ]} 
if int {}  then int {}  else if -while for x := nil to () do "totor" do while () do () then new int else x(int {} , let var x := 5 in end)
let function x(x : int) = if break then nil class x {}  in x[5][x.x()].x() end
class x {var x := 5} 
function x(x : int) = if x then int {x = nil}  else while nil do 5
x["totor"][int {x = (), x = 5} ].x.x
int [x.x[int {x = "totor"} ][x()/x.x()] := (x.x(break, nil) ; nil ; 5)] of for x := x[5].x.x(for x := int [()] of 5 to -break do x.x(nil, "totor"), x(if break then break else nil, x())) to x.x[new int] do x[()][new int].x()
int {} 
function x(x : int, x : int) = new int class x {var x := 5}  function x() = break import "empty.tih" var x := 5
var x : int := x.x((), break) function x(x : int) = x.x(5, 5)
x(-while let var x := 5 in break end do x(int {x = "totor", x = 5} , int {x = break, x = "totor"} ), x.x[(5)].x)
var x : int := new int function x(x : int) : int = int [nil] of break
function x(x : int) = -x := nil
var x : int := -5 function x(x : int) : int = x := break type x = int import "empty.tih"
var x := x.x(nil, "totor")
type x = array of int
x.x[int {} ][for x := while 5 do () to int {x = nil, x = break}  do x].x
let type x = {} function x() = nil import "empty.tih" var x := 5 in end
function x(x : int) = for x := int {}  to ()*() do (5) function x(x : int) : int = x() type x = int
x.x[break|5][int {} ].x := int {x = let import "empty.tih" in while "totor" do 5 end, x = int {} } 
var x := x()
for x := --let  in end-int {x = int {x = break} , x = if "totor" then () else nil}  to -int [new int] of new int do x.x.x.x := x(x(x.x(), x()), (5))
var x := new int
(int {x = for x := int {x = nil}  to let  in end do let  in end} )
class x extends int {var x := 5 var x := 5}  function x(x : int) = int {x = break} 
let class x {var x := 5}  var x := 5 in end
function x(x : int, x : int) = x() var x := nil
var x := (5)
new int
if x()+x(int {} , let var x := 5 in "totor" end) then new int else if new int then int {} 
class x extends int {var x := 5 var x := 5} 
class x {var x := 5}  type x = class {} type x = int import "empty.tih"
int {x = x.x[x].x := while x.x.x(while () do (), if "totor" then nil else 5) do x[5].x(x.x(), x())} 
(-if int [()] of nil then x := break else if break then ())
class x {var x := 5 var x := 5} 
let class x extends int {var x := 5}  in if x(x.x("totor", break), int {} ) then x.x := x(nil, ()) ; int {x = new int}  end
int {} 
x()
new int
int [int {x = if let var x := 5 in break ; 5 end then 5/nil|int {x = "totor", x = nil} , x = let var x := 5 var x := 5 in end} ] of x.x[x.x(5, 5)].x.x()
var x : int := int {} 
function x(x : int, x : int) = x(5&5, while "totor" do nil) class x {var x := 5}  var x := 5
while if int {}  then int [x.x.x(x.x("totor", ()), x.x())] of for x := x((), ()) to if () then nil else break do let  in end else x() do -int [if int {}  then while "totor" do "totor" else -"totor"] of if int {x = "totor"}  then x
function x(x : int, x : int) : int = x[break].x(let  in end, if 5 then nil) var x : int := ()
if new int then x.x[x(nil, nil)].x.x() else while x.x[let  in 5 end].x() do new int
function x(x : int, x : int) : int = for x := -nil to ()/() do x
if x.x[if break then "totor"][x[break].x()] := while x[break] := x(5, nil) do x.x := int {x = 5}  then if x[5].x := int {x = 5-nil}  then while int {x = while "totor" do ()}  do if (5) then x.x() else -x.x[-nil].x(x(), while if () then break else break do break|5)
for x := while for x := if x := "totor" then x((), "totor") to new int do x.x := -"totor" do int {}  to -(new int ; nil ; 5) do -x()
int {x = x.x.x[int {} ] := let var x := 5 in ()*break ; () end} 
x(-if int {x = (5)}  then let var x := 5 in "totor" end, x["totor"][for x := "totor" to nil do nil].x.x())
-if while while nil do "totor" do x()|new int then int {x = -x := ()} 
x()
function x(x : int) = x.x function x(x : int) : int = if () then nil function x() : int = () var x := 5
-int {} 
x[break][(5)].x.x.x(int {x = int [x((5), let  in end)] of (break ; 5), x = (x := break ; 5)} , new int)
function x(x : int) : int = -x
new int
int {x = x(new int, int {x = x.x.x(for x := nil to () do 5, x.x())} )} 
x.x.x.x[int [int [for x := 5 to break do "totor"] of x] of for x := if () then () to x(5, break) do x()].x(let function x() = "totor" in let var x := 5 in end ; for x := "totor" to 5 do break ; () ; 5 end, x.x.x[x[()]].x(-let  in end+x.x.x(), int [int {x = x.x(5, nil), x = x(5, break)} ] of x[()].x(while () do "totor", int {x = nil} )))
type x = array of int
class x extends int {var x := 5 var x := 5} 
while x[break].x[if x := 5 then int {x = break, x = "totor"}  else x.x()].x() do x[nil].x|let var x := 5 var x := 5 in end
function x(x : int) = let var x := 5 in end class x {var x := 5} 
int {x = x(x.x[let  in end].x(), (x("totor", 5) ; nil ; 5)), x = -x.x.x.x()} 
(while x.x()-for x := 5 to break do 5 do int {} )
let function x(x : int) = x() in x[nil].x ; x[()] := (5) end
x[5].x.x[if -break-() then (break)].x(let var x := 5 in for x := break to nil do break ; "totor" ; 5 end&x.x.x.x(int [int {} ] of if break then break else break, int [-()] of let  in end), if new int then for x := x(x, let  in end) to let var x := 5 in end do x[nil])
for x := x.x.x[x[nil].x(int [5] of break, int {x = break, x = break} )] := while int {x = new int}  do int [x.x()] of int {}  to if int {x = (5 ; 5)}  then x.x.x.x() do for x := if let var x := 5 in end then x(new int, x) else x(x(), if "totor" then break else 5) to new int do for x := for x := int {x = 5, x = ()}  to int {x = nil}  do int {}  to x-int {x = ()}  do x()
for x := x.x[x.x()][-"totor"|nil] to for x := if int [x()] of if break then 5 else () then let var x := 5 in end else if if () then "totor" then int [break] of nil else if "totor" then () to x(int {x = x.x(), x = int {} } , x()) do -x[5] := x("totor", nil) do new int
new int
function x(x : int) = for x := x.x(nil, 5) to while nil do nil do x
var x : int := x
var x : int := 5-"totor" var x : int := 5 type x = int
function x(x : int, x : int) = x.x.x() class x extends int {var x := 5} 
type x = array of int
class x {var x := 5 var x := 5} 
int [int [if x.x then if new int then x(5, "totor") else (5)] of let var x := 5 in x end] of x.x[x.x(5, nil)].x := int {x = x.x(nil, ()), x = int {} } |for x := -"totor" to for x := "totor" to 5 do () do x()
function x(x : int, x : int) = x() class x {var x := 5}  type x = int import "empty.tih"
class x extends int {var x := 5} 
function x(x : int) = int {x = let  in end, x = int {} } 
if x[()].x.x.x() then x() else --let var x := 5 in break ; 5 end
x()
x.x.x.x.x.x(if for x := x.x.x() to let var x := 5 in end do int [x.x()] of break-break then if let var x := 5 in nil ; 5 end then while x := "totor" do x("totor", ()) else x[nil].x(x(), if () then nil else "totor"), x[5][let  in 5 end][let var x := 5 in () end].x())
new int
function x(x : int, x : int) = x.x.x(x.x(), x())
class x extends int {var x := 5} 
(int {x = let var x := 5 in end} )
function x(x : int, x : int) : int = if let  in end then (5)
(let import "empty.tih" in end ; new int ; let  in end ; nil)
let class x extends int {var x := 5}  type x = int in while new int do x[nil].x(new int, x.x()) end
class x extends int {var x := 5} 
type x = array of int class x extends int {var x := 5}  var x := 5 var x := 5
x[()].x[let var x := 5 in end].x := let function x() = nil in x.x.x((5), x) end
class x {var x := 5 var x := 5}  var x : int := nil function x() : int = "totor"
function x(x : int) = int {} 
x[()][let  in end][(() ; 5)][x["totor"].x := if x then x := break else let  in 5 end] := x()
function x(x : int) : int = for x := x.x(nil, nil) to if () then () do int {}  type x = int
x.x.x[x(let  in 5 end, (5))].x.x()
var x : int := x function x(x : int) : int = x.x() function x() = nil var x := 5
new int
class x {var x := 5 var x := 5} 
x(let type x = int var x := 5 in int {}  ; if 5 then () ; 5 ; 5 end, x())
type x = {x : int} type x = {}
class x extends int {var x := 5}  type x = int var x := 5 var x := 5
if -if x.x then (5) else while while () do () do int [break] of break then -int [x.x := nil&()] of (break ; 5)
int {} 
let class x extends int {var x := 5}  in if (()) then int {x = x(break, nil)}  ; int {x = x.x(), x = break*nil}  ; int {x = (), x = "totor"}  ; nil end
function x(x : int, x : int) : int = x(x(), new int) class x extends int {var x := 5}  class x {}  import "empty.tih" var x := 5
type x = {x : int}
let class x {var x := 5}  class x {}  in -int [x] of int {x = 5, x = ()}  end
if while x()+int {x = if break then 5, x = x}  do x() then let var x := 5 in for x := for x := () to 5 do nil to x.x() do ()-5 end
var x := x((), break) class x {var x := 5} 
let function x(x : int) : int = (5) function x() = 5 in end
type x = class extends int{var x := 5} function x(x : int) : int = int {}  type x = int import "empty.tih" var x := 5
(while if nil then break|(5) do if x then if nil then () else break else x.x())
type x = class {var x := 5} function x(x : int) = int [()] of nil
type x = {x : int}
class x {var x := 5}  class x {var x := 5} 
int {x = -let import "empty.tih" in -() ; () ; 5 end, x = let function x() : int = 5 in while x() do x ; int {x = nil, x = 5}  ; () ; 5 end} 
type x = class extends int{var x := 5}
new int-if -let var x := 5 in end then let import "empty.tih" var x := 5 in int ["totor"] of break end else if x.x then for x := for x := nil to break do "totor" to while "totor" do "totor" do x := break
class x {var x := 5 var x := 5}  var x : int := () class x {}  var x := 5 var x := 5
class x {var x := 5} 
function x(x : int, x : int) : int = int {} 
function x(x : int, x : int) = x.x := for x := () to break do nil
int {} 
int {x = x(int [x()+x.x("totor", break)] of let var x := 5 in "totor" ; 5 end, x())} 
type x = class extends int{var x := 5} type x = class extends int{} class x extends int {} 
function x(x : int) : int = int {x = -()} 
int {x = x[()][int {x = nil} ][if let  in 5 end then x.x()].x(for x := int {x = while 5 do (), x = new int}  to int {x = x()}  do x[()], x.x[if nil then nil else 5].x()), x = let class x extends int {}  import "empty.tih" in end} 
type x = array of int var x := "totor"
class x extends int {var x := 5}  function x(x : int) = new int var x := 5
x.x.x[int {x = if () then nil} ][x[break][let  in end]].x(for x := int {}  to x.x.x := int {}  do int [x["totor"] := int {x = "totor"} ] of int [int {x = "totor"} ] of ()+"totor", int {} )
int [int [x.x[int {} ].x(if 5 then nil*x("totor", ()), x("totor", 5)*x.x((), break))] of x.x[(5)].x(int [while "totor" do "totor"] of if nil then nil, while int {x = "totor", x = break}  do x)] of if for x := int [while () do 5] of if () then "totor" to new int do x() then if x[()] then while break-() do (5) else let var x := 5 in break end
class x extends int {var x := 5 var x := 5} 
function x(x : int) = while for x := () to () do nil do int {x = (), x = 5} 
class x {var x := 5 var x := 5}  type x = array of int
x["totor"].x[if -5 then let  in end].x.x()
type x = {x : int} class x {var x := 5}  type x = int
type x = array of int
function x(x : int, x : int) = if while 5 do nil then if 5 then nil else 5 else -break
function x(x : int) : int = x+if nil then nil else () function x(x : int) : int = -5
x[()][let  in end].x[int [let  in 5 end] of x(break, ())|(nil)]
class x {var x := 5 var x := 5}  function x(x : int) = while 5 do ()
let function x(x : int) : int = x(nil, 5) var x := 5 in x.x|int [x] of if 5 then "totor" else "totor" end
class x extends int {var x := 5 var x := 5} 
class x {var x := 5}  class x {var x := 5} 
type x = class extends int{var x := 5}
class x extends int {var x := 5 var x := 5} 
function x(x : int) = int [x := 5] of while break do 5 class x {var x := 5} 
-while int [(nil ; 5)] of x.x := x() do let import "empty.tih" in end
x.x.x[x.x := let  in end].x
class x {var x := 5} 
x.x[if nil then break].x.x := x[()].x.x.x()
class x extends int {var x := 5}  class x {var x := 5} 
int {x = x[()].x.x.x(x.x[-"totor"] := new int, int {x = new int, x = let var x := 5 in break ; 5 end} )} 
int [x()+-x(int {} , (5))] of (while while nil do break do if "totor" then nil else 5)
let function x(x : int) = x := "totor" class x {}  import "empty.tih" in x[nil]+if while 5 do 5 then int {}  else x := () end
class x extends int {var x := 5}  class x extends int {var x := 5}  class x extends int {}  var x := 5 var x := 5
function x(x : int, x : int) = for x := int ["totor"] of 5 to x() do "totor"-"totor"
int {x = int {x = x.x.x := x["totor"].x(int {x = 5, x = 5} , let  in end)} , x = (for x := new int to new int do int {x = nil, x = 5} )} 
class x {var x := 5}  class x extends int {var x := 5} 
class x {var x := 5}  class x {var x := 5} 
x.x.x.x[x[nil][-break]] := if x[5].x then let import "empty.tih" var x := 5 in end else x.x.x.x(int {x = x := nil} , int {} )
x[nil][int {} ][if int {x = break}  then if () then nil][if let var x := 5 in 5 end then x(x, x.x(nil, nil))] := int [int {x = ("totor")} ] of x[5][while nil do nil]
x[()][(5)][-new int].x
function x(x : int) : int = x[()] type x = array of int class x extends int {} 
function x(x : int, x : int) : int = while for x := "totor" to () do "totor" do x
function x(x : int, x : int) = x()
-let class x {}  import "empty.tih" in int {x = if "totor" then 5 else 5}  ; int {}  end
var x : int := int {} 
class x {var x := 5 var x := 5}  function x(x : int) : int = while "totor" do "totor"
-int {x = x[()].x := x.x.x(), x = if ("totor") then int {} } 
x((int {} ), -let var x := 5 var x := 5 in end)
type x = class extends int{var x := 5} class x {var x := 5} 
int [x[break][int [nil] of ()][x.x.x()].x(for x := int {}  to x.x.x(for x := 5 to () do 5, let  in end) do x.x((), ())-int {} , x.x.x.x(if if () then 5 then while break do 5 else x.x(break, break), x[5] := int [break] of ()))] of if new int then if int {x = x.x()}  then int {} /for x := nil to break do 5 else int {x = x := "totor", x = -break} 
let class x extends int {var x := 5}  class x extends int {}  in for x := x(int {x = "totor", x = ()} , -break) to x(while () do 5, x()) do new int end
function x(x : int, x : int) : int = while new int do for x := break to "totor" do break
-for x := int {}  to let import "empty.tih" in end do -new int
function x(x : int, x : int) : int = new int function x(x : int) : int = for x := nil to "totor" do "totor"
var x := nil*"totor"
function x(x : int) : int = x["totor"] := x.x(break, "totor") var x : int := break
type x = {x : int} class x {var x := 5} 
function x(x : int, x : int) = x(break, break)+for x := "totor" to 5 do break
let var x := 5 in let var x := 5 in break end ; new int end+(new int ; if 5 then 5 ; "totor" ; 5)
x["totor"].x.x.x.x()
for x := for x := int [if int ["totor"] of nil then -break else for x := "totor" to nil do break] of if break*break then int {}  to x.x[x := nil] := x() do for x := x.x := new int to while int {}  do new int do x.x := int ["totor"] of () to int {x = while int {}  do x["totor"] := x((), 5)}  do new int
if if x["totor"].x.x(if if break then nil else "totor" then x := "totor" else for x := nil to () do break, (break)) then (int {x = (), x = 5}  ; 5 ; 5) then -x.x.x.x() else for x := (x.x()) to int {}  do x.x.x.x(let var x := 5 in end, int [x.x()] of x.x("totor", ()))
int {x = if int {x = int {x = (5)} , x = int {} }  then x["totor"].x.x(x.x(break, "totor")&int {x = break} , x(x.x("totor", 5), -())), x = -if int {}  then -if "totor" then nil else 5 else if if nil then break then let  in 5 end else for x := 5 to nil do 5} 
type x = class {var x := 5} class x extends int {var x := 5} 
class x {var x := 5} 
type x = int
var x := while break do break
class x extends int {var x := 5 var x := 5}  function x(x : int) = while () do 5
(int {x = x(), x = new int} )
if let class x extends int {}  in int [x.x("totor", 5)] of x(nil, 5) ; int {}  end then x()
x()
x()
type x = class {var x := 5} function x(x : int) = (5)
x[()][()-5].x.x := if int {x = x[nil].x()}  then int {x = x[break].x(), x = let var x := 5 in end} 
function x(x : int, x : int) = x(if break then "totor", int {x = nil} )
var x := let  in 5 end
x[()].x.x.x := let class x {}  in x[nil] ; if nil then nil end
x.x.x.x.x := int {x = for x := (5) to x((), ()) do if 5 then nil else "totor"*x[()] := if break then ()} 
new int
x.x[new int].x[int {} ] := x[()].x.x.x(int [(())] of if (5) then x((), "totor"), x.x.x := while x.x() do int [break] of "totor")
int {x = if if new int then let  in end then int {x = x.x(), x = x.x()}  else int [int {x = "totor", x = ()} ] of break-5&x.x[let  in 5 end].x(new int, while int {x = (), x = "totor"}  do (5))} 
function x(x : int, x : int) : int = int {x = let  in 5 end} 
class x extends int {var x := 5}  function x(x : int) = x.x()
let function x() : int = 5 in while -nil do while "totor" do "totor" ; new int end-x(x.x[x.x()] := x(), new int)
var x : int := x.x(break, break) class x {var x := 5} 
x.x[int {x = nil, x = 5} ][int {x = -"totor", x = (5)} ].x
let function x(x : int) : int = if break then "totor" else "totor" type x = int in -x[break].x(-break, x.x("totor", ())) ; let var x := 5 in nil end end
class x {var x := 5 var x := 5} 
int {} 
if int {}  then int {}  else let function x() : int = () var x := 5 var x := 5 in x.x.x() end
(-x-for x := break to break do nil ; if break then "totor" else ()/int [break] of nil)
for x := (x()|(5)) to x["totor"].x.x.x(x[nil][while nil do 5] := let var x := 5 in end, int {x = int {x = let  in end, x = int [()] of break} , x = if 5 then break&int {x = ()} } ) do x[break][x()].x := while x["totor"] := (5) do let var x := 5 in end
int {x = x.x.x.x := int {} } 
var x : int := x()
function x(x : int) = x()
var x : int := int {} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = x var x := 5
let type x = class extends int{} class x {}  in end
type x = class extends int{var x := 5} class x {var x := 5}  function x() = nil
for x := x[break].x[x.x := for x := "totor" to nil do break].x() to if while if x := 5 then if nil then "totor" else () do let var x := 5 in break ; 5 end then int [if x.x("totor", break) then if nil then "totor" else nil else x := "totor"] of int [if nil then "totor"] of (5) do -int {x = int {x = int {x = "totor", x = "totor"} } } 
(x["totor"][x.x()] := for x := x() to let  in end do for x := () to nil do "totor" ; x.x := if break then "totor")
int {x = while while if x := break then x.x() do for x := x() to let  in end do int {}  do int {x = x["totor"]} , x = x(-x[5] := if "totor" then (), new int)} 
int {x = if let import "empty.tih" in end then x.x.x.x() else let import "empty.tih" in (5) ; "totor" ; 5 end, x = x[break][x(break, "totor")][int [x := "totor"] of x(5, ())].x(int [-x()] of while (5) do int [nil] of nil, int [let var x := 5 in end] of int [int ["totor"] of nil] of int [break] of nil)} 
x.x.x.x.x.x(x["totor"][x((), 5)].x.x(), new int)
if for x := if int {x = int [5] of nil}  then x.x.x(-break, x((), nil)) to x[5][int {x = nil} ] := x.x := -break do x.x[x(5, ())].x(int [x.x()] of int {x = break, x = nil} , if x() then x() else x.x((), break)) then x["totor"][int {x = nil, x = break} ].x.x() else x[nil].x.x.x()
function x(x : int) : int = let var x := 5 in end class x {var x := 5} 
int {x = if let var x := 5 in x() end then int [for x := let  in 5 end to -() do x(break, 5)] of x["totor"] := (5)} 
(x())
if x[nil].x.x.x(x.x[x()] := x(if 5 then 5, nil/nil), int {} ) then new int
class x {var x := 5 var x := 5} 
type x = class extends int{var x := 5}
class x extends int {var x := 5}  function x(x : int) = (5) class x extends int {}  var x := 5
type x = {x : int}
if x((x(5, ())), (let  in 5 end ; "totor" ; 5)) then int [let var x := 5 in 5 end|x[nil].x()] of while int {}  do -5*let var x := 5 in "totor" ; 5 end else for x := if (nil ; 5) then x[break] else x.x to if x[5].x((5), (5)) then x.x := break-nil else x.x do int [-int {} ] of x[()]
type x = {x : int} class x {var x := 5} 
int [x[break][new int][let var x := 5 in 5 end].x()] of if x[break][x(5, ())] := x() then x[()][let  in end].x() else while x.x.x(new int, -5) do x(x(), let  in 5 end)
x.x.x.x[(while break do "totor")].x()
type x = array of int
int {x = x(let var x := 5 var x := 5 in x() ; () end, let var x := 5 in x((), "totor") end)} 
while int [let var x := 5 in () ; 5 end] of x.x := x.x()*if x.x.x(int {x = nil} , int {x = (), x = "totor"} ) then let var x := 5 in end do int [x[()][int {x = (), x = ()} ].x(int {x = x := "totor"} , new int+let  in end)] of int {x = while let  in 5 end do new int, x = let var x := 5 in () ; 5 end} 
(x() ; x[break] := if nil then nil else 5)
function x(x : int, x : int) = int {x = break+"totor"}  var x := nil
x.x.x.x.x := x[nil].x.x.x(int {x = if x() then new int else x.x("totor", break)} , int {x = x.x.x()} )
x(x(-let var x := 5 in nil end, if new int then x.x else let var x := 5 in "totor" ; 5 end), int {x = x.x[for x := nil to 5 do 5] := int [int [5] of ()] of int {x = nil} , x = if let var x := 5 in break ; 5 end then let var x := 5 in 5 ; 5 end} )
int {x = (for x := -() to x do x(nil, break) ; x := "totor" ; 5 ; 5)} 
let class x extends int {var x := 5}  in new int ; if -nil then nil/nil end
type x = {x : int}
type x = class extends int{var x := 5} function x(x : int) : int = x()
x.x.x.x.x.x(x[nil].x.x.x(), x())
while x[break] do x.x&new int|let var x := 5 in end|let type x = int in end
var x : int := new int
type x = class extends int{var x := 5}
var x := while 5 do break var x := 5
for x := x.x[int {x = (), x = nil} ].x(x[nil], x[nil] := if 5 then () else ())*while if 5 then 5 else () do int {x = break} -x.x.x(x(nil, break), int {x = "totor"} ) to new int do let import "empty.tih" in end/x.x[if "totor" then 5 else ()] := int [let  in end] of x()
new int
x.x[nil/nil].x[x.x.x.x()]
new int
x(int {} , x())
let function x(x : int) : int = int {}  class x {}  var x := 5 var x := 5 in end
x.x.x[(nil ; 5)][int {} ].x()
x.x[x.x(5, ())].x.x
class x extends int {var x := 5 var x := 5} 
x.x.x.x.x.x(int {x = x[()].x := int {x = if break then "totor" else "totor", x = -()} , x = if x["totor"] := new int then for x := int [nil] of () to x((), ()) do -nil else x()} , x(int [x.x.x()] of while int [5] of () do (5), int {x = x[break], x = x.x} ))
var x : int := ()|5 type x = int type x = int var x := 5 var x := 5
while if let var x := 5 var x := 5 in end then x.x[for x := "totor" to () do nil] := int {x = x(), x = -break}  else x[5][x.x()] do new int
if x[()][int {x = nil} ][x.x].x(let import "empty.tih" var x := 5 in x := () ; "totor" ; 5 end, (() ; 5)&if x() then let  in 5 end) then for x := x() to int {}  do let import "empty.tih" var x := 5 in end
x()
if let type x = int in end then x() else x()
x.x[new int].x.x.x()
int [new int] of if x() then x() else x[nil].x.x()
new int
while int {x = x.x*int {x = x(), x = nil/()} , x = new int}  do let class x {}  var x := 5 var x := 5 in if -break then while nil do break end
int {x = x(while new int do int {x = int {x = 5, x = "totor"} , x = for x := 5 to "totor" do nil} , ((5))), x = let import "empty.tih" in int {x = (), x = ()}  end-x[nil][for x := () to break do break].x()} 
class x extends int {var x := 5}  type x = array of int
let class x extends int {var x := 5}  class x {}  import "empty.tih" var x := 5 in x[nil].x.x(int {x = int {x = 5, x = break} , x = int {x = break, x = nil} } , x(let  in end, let  in 5 end)) end
int {x = x.x[while "totor" do 5][if int {}  then int {x = "totor", x = ()} ].x(x.x.x := let var x := 5 in 5 ; 5 end, x["totor"].x.x(x(), let  in 5 end+x()))} 
if x(int [x(x.x(break, nil), int [break] of 5)] of while while 5 do "totor" do if "totor" then (), int {x = for x := for x := 5 to () do "totor" to x() do new int, x = int {x = x.x(), x = int {x = "totor", x = 5} } } ) then int {x = -int {} }  else if x[nil].x then if if x := "totor" then int {x = (), x = break}  else x := "totor" then int [()&"totor"] of int [break] of 5 else x[nil].x.x()
function x(x : int, x : int) = int {x = x.x(), x = let  in 5 end}  function x(x : int) = x.x((), break)
function x(x : int, x : int) : int = int {x = int [break] of 5, x = new int}  class x extends int {var x := 5} 
x[nil][5-5][x[break].x()][int {x = int [if "totor" then ()] of x(break, ()), x = x(int {x = (), x = break} , x(break, "totor"))} ].x()
let class x {var x := 5}  in end
class x {var x := 5 var x := 5}  class x {var x := 5} 
if int [x.x.x := if x("totor", "totor") then x] of int {}  then let class x extends int {}  in end else int {x = let var x := 5 in x() ; break ; 5 end, x = int [-for x := "totor" to "totor" do break] of while x := "totor" do while 5 do 5} 
class x extends int {var x := 5}  class x {var x := 5} 
function x(x : int) = while new int do x.x(break, break)
x(if int {}  then int {}  else int {x = if while break do 5 then for x := nil to "totor" do "totor" else x.x(break, ()), x = int {x = if nil then nil} } , -let  in end/int {x = break} &(nil))
x[()].x[if new int then -() else (5)].x.x(-if (5) then int {} |if x() then (5) else int {x = ()} , x.x[if () then ()][-int {} ].x(x(), x.x[int {x = (), x = "totor"} ]))
((int {}  ; ()))
var x := x.x() type x = class {}
let function x(x : int) = let  in end type x = int import "empty.tih" in while int {x = ()*nil, x = int {} }  do while x("totor", 5) do x.x((), "totor") ; if ()|"totor" then if () then nil ; if "totor" then nil end
type x = {x : int}
function x(x : int, x : int) : int = let var x := 5 in break end function x(x : int) = x
x()
function x(x : int) : int = ("totor")
int {} /let class x extends int {}  import "empty.tih" in x[5].x() end
var x := x()
x.x[x := 5].x.x.x(if if new int then new int then int {x = while int [5] of nil do let  in 5 end} , int {x = while while () do break-int {}  do let var x := 5 in 5 end, x = if (nil) then while nil do "totor"&int {x = break} } )
function x(x : int) : int = x(x(), int {} )
function x(x : int, x : int) : int = x[nil].x() function x(x : int) : int = x function x() : int = "totor" var x := 5 var x := 5
x.x[x.x()].x.x.x()
class x {var x := 5}  function x(x : int) : int = int ["totor"] of break function x() = nil import "empty.tih"
var x : int := if 5 then nil class x {var x := 5} 
x[nil][x()][int {x = let  in end, x = int [nil] of ()} ][-x.x.x(int {} , int {} )].x(int {x = for x := int {} +x := () to x[()] do -nil+(5), x = if x[nil] then if if "totor" then break else "totor" then let  in 5 end else x()} , new int)
int [for x := while x(x(break, break), new int) do if x() then new int to int {x = let var x := 5 in 5 end, x = let  in end/new int}  do let var x := 5 in int {x = 5, x = break}  ; "totor" end] of x["totor"].x.x()|int [x.x.x()] of x(nil, 5)&if 5 then ()
int {} 
function x(x : int) = int {x = let  in 5 end, x = if "totor" then () else "totor"}  function x(x : int) = for x := break to 5 do nil
new int
function x(x : int, x : int) = if (5) then -"totor"
x()
class x {var x := 5 var x := 5}  type x = class extends int{}
class x extends int {var x := 5 var x := 5}  type x = {} class x extends int {} 
x[nil][int {x = break, x = 5} ][int {} ].x.x(let function x() : int = 5 in end, x["totor"].x[int {x = x(), x = x()} ])
new int
let class x extends int {}  import "empty.tih" var x := 5 in end*-for x := x("totor", ()) to new int do x(nil, "totor")-int [x.x.x(new int, int [()] of 5)] of (nil)
x.x[int {x = ()} ][new int].x.x()
x.x[x.x()].x[int {} ].x(new int, let type x = int in if new int then x := () end)
x.x.x[int [for x := break to 5 do nil] of x.x()][if x(x(nil, nil), -break) then if int {x = 5, x = nil}  then if nil then nil else () else (5)]
x()
class x extends int {var x := 5}  var x : int := () var x := 5
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
class x {var x := 5} 
-x[nil][if nil then ()].x := let var x := 5 in x() ; 5 ; 5 end
class x extends int {var x := 5 var x := 5}  function x(x : int) = x class x {}  var x := 5 var x := 5
new int
function x(x : int) : int = int {} 
if new int then x.x[-"totor"][if let  in end then int {x = break, x = 5} ]
class x {var x := 5 var x := 5} 
x.x[nil/()].x[for x := x() to int {}  do int {} ].x(if let import "empty.tih" var x := 5 in end then new int, for x := int {}  to if int {} |if break then nil then x[nil].x(if nil then break, -"totor") else while int {x = "totor", x = "totor"}  do int ["totor"] of break do if x() then x["totor"])
function x(x : int, x : int) : int = x(int [5] of break, -nil) var x : int := "totor" type x = int
-(int {x = int {x = ()} }  ; let  in end ; nil)
function x(x : int, x : int) : int = x[nil]
class x extends int {var x := 5} 
(x(if "totor" then 5 else "totor", new int))|let var x := 5 var x := 5 var x := 5 in end
if int {x = int {x = for x := for x := "totor" to () do break to "totor"&nil do let  in end} , x = int {} }  then int {}  else (x.x.x() ; for x := 5 to 5 do break ; break)
let class x extends int {var x := 5}  in end
type x = array of int
type x = class {var x := 5}
(x[break][int [nil] of ()].x(int {x = x.x(nil, "totor"), x = x.x()} , if nil then break/if break then nil))
x.x.x.x.x := for x := (() ; 5)+if x := () then int [break] of break else "totor"*nil to int {x = let var x := 5 in 5 end}  do x()
type x = int
class x {var x := 5 var x := 5} 
var x := if break then break else "totor" class x extends int {var x := 5}  function x() = 5
(new int ; let var x := 5 in end)
type x = int function x(x : int) = while nil do break
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = int [5] of ()
(x["totor"].x.x(-x := (), new int) ; if x := () then "totor"+() ; x.x())
var x := (5) class x extends int {var x := 5} 
type x = class extends int{var x := 5}
while x.x[(5)].x do (int {}  ; x())
int {x = int {} , x = x(if (5)&if break then nil then --() else int {} , int {x = x[break], x = let var x := 5 in end} )} 
while int {}  do x["totor"].x[if int {}  then x() else int {x = nil} ].x(while int [nil/break] of x.x() do new int, new int)
class x {var x := 5} 
class x {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int) = let var x := 5 in "totor" end function x(x : int) : int = x.x(nil, "totor")
let var x := () in x() end
new int
if x[5][let  in 5 end][new int].x(if x.x := new int then let var x := 5 in break end, int {x = new int} ) then int {}  else for x := x.x.x := x.x()&while break do () to if x[break].x(let  in end, x.x()) then if x.x() then int {}  else -(5) do if int {}  then x.x := new int
(while x(if break then nil, x) do let var x := 5 in end ; int {x = x := (), x = x := ()} )
function x(x : int, x : int) = x.x.x()
x[break][int {x = break} ][x[break] := 5|nil][int {x = if for x := () to 5 do nil then let  in 5 end} ].x()
int {} 
-if int {x = nil}  then let  in 5 end else if 5 then ()|if x[break].x() then int {} -int {x = ((5)), x = int {} } 
-int {x = let import "empty.tih" in x := "totor" end} 
class x {var x := 5} 
if x[5][x.x()].x.x(x[5].x.x(-if () then nil, let var x := 5 in nil ; 5 end), (-"totor" ; nil)) then for x := x.x.x.x() to x[nil][int {x = "totor"} ].x(int {x = x.x(), x = x := nil} , x()) do x[5].x else x[5].x[5+nil&int {} ].x(if int {x = int {x = "totor", x = 5} }  then x.x.x(), while int [-break] of x.x() do while let  in 5 end do new int)
let function x(x : int) = -break var x := 5 import "empty.tih" var x := 5 in end
class x {var x := 5} 
x.x[if nil then break].x.x
function x(x : int, x : int) : int = (5 ; 5)
let function x(x : int) : int = if () then break class x {}  in end
-x(let import "empty.tih" var x := 5 in x := () ; nil ; 5 end, if -if "totor" then nil then (() ; 5) else if x(5, "totor") then x.x(5, "totor"))
class x {var x := 5 var x := 5} 
type x = array of int var x := ()
(let import "empty.tih" in int {x = 5, x = "totor"}  ; () end)
x.x.x[for x := x.x((), ()) to x.x() do x := ()].x := int {} 
new int
type x = {x : int} class x extends int {var x := 5} 
int {} 
var x := if () then () else break
function x(x : int) = x[nil] := let  in end var x := break
-new int|while for x := for x := while break do nil to -break do int {}  to new int|x.x() do for x := break to 5 do "totor"*x.x() do if int {}  then x() else x.x.x()
function x(x : int) = new int var x := 5
new int
class x extends int {var x := 5}  class x extends int {var x := 5} 
x.x.x.x[x.x[new int]]
new int
-x(x[()][let  in end], for x := while (5) do x to while int [break] of "totor" do (5) do int {x = x(nil, ())} )
function x(x : int, x : int) : int = if -break then int {x = "totor"}  function x(x : int) : int = (5) var x := 5
type x = class {var x := 5}
let class x extends int {var x := 5}  var x := 5 in end
int [(x[nil] := x.x() ; x.x())] of new int
x()
x[nil].x[int {x = let  in 5 end} ][for x := x.x.x(let  in end, x) to x.x := if break then () do let var x := 5 in break end] := x()
(int {x = if int {}  then x.x() else let  in end}  ; if x := () then for x := break to () do nil)
var x : int := if () then "totor" class x {var x := 5} 
class x {var x := 5}  class x extends int {var x := 5} 
function x(x : int, x : int) = if new int then let  in end
var x : int := let  in 5 end
function x(x : int, x : int) : int = while while 5 do "totor" do int {} 
type x = class extends int{var x := 5}
int {x = for x := let  in end to if 5 then "totor" do x := break-x.x} &while let import "empty.tih" in end do let import "empty.tih" in end
function x(x : int) = int {x = x.x(break, nil), x = if 5 then () else break}  class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  class x {var x := 5} 
int {x = if (nil ; 5)/(5 ; 5) then x.x[5-5].x() else int {} &while int [5] of "totor" do let  in end, x = x.x[break+nil][if for x := nil to 5 do "totor" then 5&()] := x(int {x = (5)} , new int)} 
new int
x["totor"].x[int [x.x(5, nil)] of 5|()].x.x()
x["totor"][if 5 then ()][x()-x].x
int {x = while if int {x = 5}  then int {x = 5, x = 5}  else for x := 5 to break do break do -x.x(), x = int {} } &(int [let  in 5 end] of new int)
type x = class extends int{var x := 5}
function x(x : int) : int = let var x := 5 in break end class x extends int {var x := 5} 
int [for x := x.x.x to for x := if x() then new int else while () do break to x[nil].x(if "totor" then () else "totor", if 5 then nil) do ("totor" ; 5) do x.x[int [()] of break] := let var x := 5 in () ; 5 end] of while if let var x := 5 in break ; 5 end then x.x := (5) do while x[nil] do let var x := 5 in 5 end
var x : int := int {x = 5, x = ()} 
function x(x : int) = x()
x.x[let  in end][if x() then let  in 5 end else int {x = nil, x = ()} ][int {x = x.x.x(if break then (), (5))} ] := while x(while int {x = nil, x = nil}  do x := (), let var x := 5 in 5 end) do int {x = if int {x = 5}  then if () then 5 else new int, x = new int} 
let class x extends int {var x := 5}  in end
function x(x : int) = let var x := 5 in end type x = class {} class x extends int {} 
(for x := (break) to x(x((), 5), while "totor" do "totor") do if x then x())
type x = class extends int{var x := 5}
type x = class {var x := 5} class x {var x := 5}  class x extends int {} 
for x := x["totor"].x.x to new int do x(x[nil].x.x(-int {x = ()} , while x() do let  in 5 end), x[break].x)
while if if int {}  then let var x := 5 in end else new int then x[break][x()].x(int {x = for x := break to nil do nil} , while x() do x := break) do while x["totor"].x do int {x = if "totor" then nil else 5, x = int [5] of "totor"} -("totor" ; 5)
x[break].x.x[while -break/nil do x(while "totor" do nil, x := ())].x(let var x := 5 in end, if if int {x = let  in end}  then ("totor" ; 5) else int [new int] of x.x(5, 5) then x.x[x.x("totor", 5)].x(let var x := 5 in "totor" ; 5 end, x["totor"].x(while 5 do 5, while nil do 5)))
x[()][let  in end][int {x = int {x = break} } ][for x := if int {x = (), x = break}  then -5 else int ["totor"] of "totor" to x[nil] do x[5].x()].x()
-if int {}  then if int {x = for x := () to () do nil}  then -x("totor", nil) else if if new int then x() else x then let  in 5 end&for x := nil to () do 5
class x {var x := 5} 
type x = int function x(x : int) = for x := nil to () do 5
var x := if () then 5 type x = {}
class x {var x := 5}  class x {var x := 5} 
class x {var x := 5}  class x extends int {var x := 5} 
(x[5].x := let var x := 5 in end)
class x {var x := 5 var x := 5}  type x = {} class x extends int {} 
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() = 5
-x.x[for x := break to nil do "totor"].x.x()
class x {var x := 5 var x := 5} 
int {x = -x()} 
var x := "totor"*nil
var x := let  in 5 end class x extends int {var x := 5} 
class x {var x := 5}  class x extends int {var x := 5} 
class x {var x := 5} 
x["totor"][int {x = ()} ][int {} ].x(while int {}  do (()), x(int {} , if "totor" then 5 else "totor")+x())-for x := -(()) to for x := new int to x.x.x() do int {}  do x[nil].x.x()
function x(x : int, x : int) = x--nil class x {var x := 5}  var x := 5
var x := if 5 then 5 else ()
if if int [int {x = x := nil} ] of if while () do nil then x.x(break, "totor") else x(5, ()) then for x := x() to int {x = x.x(), x = let  in end}  do for x := for x := "totor" to nil do () to let  in end do int {x = break}  else int {}  then x[break][let  in end].x.x()
function x(x : int, x : int) : int = x.x var x : int := nil var x := 5
function x(x : int, x : int) = int [x()] of new int
while for x := if x.x.x() then int {x = (5)}  to (x.x("totor", "totor")) do x[5][for x := break to break do nil].x(int [new int] of x.x(), let var x := 5 in "totor" ; 5 end) do -if x.x.x() then int {x = int {} } 
class x extends int {var x := 5} 
let var x : int := break in -x.x ; x[nil] := x := 5 end
class x {var x := 5 var x := 5}  function x(x : int) : int = -nil type x = int import "empty.tih"
while while if for x := 5*"totor" to let  in 5 end do let  in end then new int do new int do int {x = int [x["totor"].x()] of -int [nil] of 5} 
for x := let import "empty.tih" var x := 5 in x.x() end-(if break then () else nil ; "totor" ; 5) to for x := new int to let import "empty.tih" in end do int {x = x(let  in 5 end, if 5 then "totor" else nil), x = -x("totor", ())}  do int {x = let var x := 5 var x := 5 in nil-"totor" ; 5 ; 5 end, x = int {} } 
new int
if int {}  then if int {}  then int {x = for x := let  in end to x.x(5, nil) do if nil then 5 else "totor", x = int {} }  else x["totor"][x()][new int].x()
type x = class extends int{var x := 5}
x(while x[()].x.x() do int [x[5]] of x.x := x.x(), int [let var x := 5 var x := 5 in int [nil] of 5 ; break end] of (if "totor" then nil else break ; 5))
if x(if int {x = let  in 5 end, x = int [5] of break}  then x[5].x(new int, x()), x[()][break|()] := int {} |x.x(5, ())) then int [new int] of x.x[-()] := x(if nil then 5, x()) else x(new int, let import "empty.tih" in x ; nil ; 5 end)
class x {var x := 5}  function x(x : int) = for x := nil to () do 5 var x := 5 import "empty.tih" var x := 5
int {x = (new int ; int {x = "totor"}  ; 5 ; 5), x = int [x()] of int {x = x[()]} } 
let class x {var x := 5}  class x extends int {}  in end
x[break][for x := nil to nil do nil].x.x.x(int {x = if int [int {x = (), x = nil} ] of new int then x[nil].x(while "totor" do nil, new int), x = int [int {x = let  in 5 end} ] of int [x()] of int {x = nil} } , int {x = (let  in 5 end)} )
type x = {x : int} var x : int := 5 function x() = () var x := 5
-x()
int {x = let class x {}  var x := 5 in end} 
class x extends int {var x := 5 var x := 5}  var x : int := 5 type x = int
class x extends int {var x := 5}  class x {var x := 5} 
class x extends int {var x := 5} 
function x(x : int, x : int) = -5|x function x(x : int) : int = int {x = "totor"}  type x = int var x := 5
type x = array of int
var x : int := int [5] of break function x(x : int) = int {x = (), x = 5} 
class x extends int {var x := 5} 
int [for x := for x := x[nil] := int {}  to (5 ; 5) do let var x := 5 in end to let import "empty.tih" in x.x() ; nil ; 5 end do (5-"totor" ; ())] of if -x(int [nil] of 5, new int) then -x.x.x() else new int
class x extends int {var x := 5} 
function x(x : int, x : int) : int = int {}  function x(x : int) : int = x(break, "totor") function x() = nil import "empty.tih"
let var x := nil in end
var x : int := let  in 5 end class x {var x := 5} 
let type x = class extends int{} in for x := x[5].x() to x[nil].x((5), if nil then "totor") do if x() then if "totor" then () else let  in 5 end ; if if () then () then x.x() else int [break] of break end
int [x.x.x.x] of let type x = int var x := 5 in x() ; int {x = 5, x = nil}  end
(x[nil][let  in end].x() ; int {x = new int}  ; break*break ; 5)
x.x.x.x[x["totor"].x.x(-x, let var x := 5 in "totor" ; 5 end)].x(int {x = x[()][if break then break], x = x.x[-"totor"] := x[()] := let  in end} , int [x()] of int {x = x(x.x(), if nil then nil), x = x[5].x(-(), int [nil] of ())} )
function x(x : int) : int = int [if () then "totor"] of for x := break to break do break
class x {var x := 5}  function x(x : int) : int = while nil do () class x extends int {}  var x := 5
class x {var x := 5} 
class x {var x := 5 var x := 5}  function x(x : int) = while 5 do 5
class x {var x := 5 var x := 5} 
class x {var x := 5} 
function x(x : int) : int = while x.x(nil, ()) do if 5 then break else break
new int
new int
x[5][while "totor" do nil][-(5)].x.x()
var x : int := for x := nil to break do ()
var x : int := while 5 do nil
class x {var x := 5} 
if (x["totor"] := x() ; int [nil] of break ; () ; 5) then x["totor"].x.x.x() else let function x() : int = nil var x := 5 in new int end
int [if x(int {x = (5), x = for x := nil to "totor" do "totor"} , if x.x() then (5) else x.x((), 5)) then let import "empty.tih" var x := 5 in end] of -x.x[let  in 5 end].x(int [x := "totor"] of break&(), while x do int [()] of 5)
x.x.x.x.x
var x : int := x() var x : int := nil function x() = 5 var x := 5
function x(x : int, x : int) = int {x = x.x()}  class x {var x := 5} 
(x[()][int {x = (), x = break} ].x(x.x.x(), x.x.x(-nil, x((), 5))) ; if if nil then break else nil then if 5 then nil)
int [int {x = for x := let var x := 5 in break end to x(x.x(), "totor"|"totor") do let var x := 5 in end} ] of x[nil].x[-5+()]
class x {var x := 5} 
for x := new int to for x := let import "empty.tih" in end to x[nil].x.x(for x := -() to x do x := "totor", int {x = int {x = 5} } ) do -while while 5 do break do if break then 5 do x(int {} , int {x = for x := x.x(break, "totor") to int {x = 5}  do x, x = x[break].x()} )
class x {var x := 5 var x := 5}  class x {var x := 5}  class x extends int {}  var x := 5
if -if for x := new int to new int do -5 then new int else int {x = x.x()}  then new int else int {x = int {x = x, x = for x := "totor" to "totor" do nil} } |let import "empty.tih" var x := 5 in end
x.x.x[x()][x[break].x := x()] := x.x.x[int {x = let  in 5 end, x = int {x = "totor", x = "totor"} } ] := int [x(x(break, break), int {x = (), x = nil} )] of x(break/(), int [nil] of ())
x(let var x := 5 in if int {x = (), x = break}  then (5) else int {}  end, x["totor"].x.x)
type x = array of int function x(x : int) : int = int {x = 5}  class x extends int {}  import "empty.tih" var x := 5
if if int {x = x()}  then int {}  else let var x := 5 in (5) ; break end then if int {}  then int {x = int [x(5, ())] of x.x(break, ())}  else x.x.x else x.x[while () do nil].x.x(while if nil then break do x := 5*while x do let  in 5 end, x.x&int {} )
class x {var x := 5 var x := 5}  var x := 5 type x = int
var x := (5)
int {x = if int {x = x[break] := int {} }  then -int {x = let  in 5 end} , x = x()} 
new int
let class x {var x := 5}  var x := 5 in x[break][let  in end].x(int {x = x(5, ()), x = let  in end} , while let  in 5 end do while "totor" do "totor") end
new int
let var x : int := break in x[()].x := while if break then nil else break do new int end
int {x = -int {x = let var x := 5 in break ; 5 end, x = x()} } 
x[nil].x.x[let var x := 5 in nil end/int {} ].x()
int {x = new int-new int} 
let class x {var x := 5}  type x = int in end
new int
if let class x {}  in let var x := 5 in end ; int {x = ()}  ; "totor" ; 5 end then int {} 
type x = {x : int} function x(x : int) = int {}  function x() : int = break
let function x(x : int) = let  in 5 end class x {}  var x := 5 var x := 5 in end
function x(x : int, x : int) = let var x := 5 in end function x(x : int) = while () do 5
-int {x = if x.x.x(x := break, int {x = (), x = nil} ) then int {}  else for x := x := break to x.x(5, 5) do -()} 
class x {var x := 5} 
class x extends int {var x := 5 var x := 5} 
type x = array of int
x()
function x(x : int) = let var x := 5 in () end type x = int
int {x = x.x.x.x.x(), x = int {x = int {x = x()} } } 
var x : int := x := break var x : int := "totor" class x {} 
function x(x : int) : int = int [let  in end] of new int
class x {var x := 5 var x := 5}  type x = int
function x(x : int) : int = x.x := while nil do nil
x()
x[5][(5)].x.x.x(x.x.x.x.x(x.x[let  in end].x(let var x := 5 in end, new int), x[nil][()&break].x()), if x[nil].x.x(x(), int {x = int {x = nil, x = 5} } ) then int {x = x[()].x()}  else x.x[x(5, "totor")] := int {} )
if int [x.x[let  in end].x(new int, new int|x)] of x.x[new int].x() then while while x() do let var x := 5 in end do x(-int {} , -()&int [break] of 5)
int {x = new int} /-while x() do new int
var x : int := x() class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
function x(x : int) : int = int [while 5 do break] of new int class x {var x := 5}  function x() : int = 5
class x {var x := 5}  var x := () type x = int
function x(x : int, x : int) = int [-5] of new int
function x(x : int) : int = x[break]
for x := while x[break].x := let var x := 5 in end do int {x = x[()].x()}  to x.x.x.x := int {x = x[nil]}  do if int {}  then x[nil].x else x()
for x := int {x = x((()), int {} )}  to while x["totor"].x do x.x.x do x()
let function x(x : int) = -() class x extends int {}  in end
function x(x : int, x : int) = while (5) do int [break] of break
int [((nil) ; x("totor", "totor") ; 5 ; 5)] of int {x = x(), x = if if x() then x.x() else for x := () to () do () then x(int {} , int {x = 5, x = 5} )} 
class x {var x := 5 var x := 5} 
function x(x : int) = x() class x extends int {var x := 5} 
(let var x := 5 in end)
x()
x.x[-5][x(x, new int)][-x.x()&new int].x()
class x extends int {var x := 5}  class x extends int {var x := 5}  type x = int
int {} 
class x {var x := 5} 
var x : int := x class x {var x := 5}  function x() = 5 import "empty.tih"
function x(x : int, x : int) = x[5] class x {var x := 5}  class x {} 
function x(x : int) : int = ("totor") function x(x : int) : int = for x := 5 to nil do nil var x := 5
int [if x[5].x.x(let var x := 5 in end, x[5].x(-nil, ()|nil)) then new int] of for x := while -int {x = "totor", x = break}  do int {}  to x.x.x := x.x.x(x, x(nil, break)) do int {} 
var x : int := (5)
x[()].x[x()][if if x() then x.x(nil, 5) then let var x := 5 in end] := x.x.x&let import "empty.tih" var x := 5 in end
let var x := 5 class x extends int {}  in end
x()
let var x := nil class x {}  in if let var x := 5 in break end then int {}  else -int {x = (), x = nil}  end
let class x extends int {var x := 5}  function x() = break import "empty.tih" var x := 5 in (let  in 5 end ; 5 ; 5) end
x.x[if () then "totor"].x[x.x[x := 5] := -while "totor" do break].x()
int {x = x["totor"].x.x.x(), x = int {} } 
int {x = int [int [x["totor"]] of int [for x := 5 to 5 do nil] of new int] of x["totor"][int {x = nil, x = ()} ], x = -int [x[nil] := for x := () to "totor" do nil] of while for x := "totor" to 5 do "totor" do for x := () to break do nil} 
class x extends int {var x := 5} 
int [(x.x(break, "totor")*int {x = 5} )] of x.x.x[while int {x = nil, x = 5}  do if nil then 5 else nil].x(x[()][if break then "totor" else ()], if while ()/nil do new int then (()))
function x(x : int) = x.x.x() function x(x : int) = x type x = int import "empty.tih"
let function x(x : int) : int = if break then () else () class x extends int {}  in x.x.x.x(for x := if break then break else "totor" to x do int {x = break, x = nil} , (5 ; 5)) ; let var x := 5 in "totor" ; 5 end end
var x : int := x.x(nil, 5)
int [if let import "empty.tih" var x := 5 in end then while new int do -int {x = "totor", x = break}  else for x := x.x.x(x := break, x(break, break)) to int {}  do while 5 do "totor"|int {x = nil} ] of x[()][if "totor" then break else "totor"].x.x(int {x = x.x.x(x(), ()-())} , x[break].x := x[nil])
function x(x : int, x : int) = x(x.x(), int ["totor"] of "totor")
x()
function x(x : int, x : int) = new int
var x : int := (5)
if while int {x = x.x := x.x(), x = x(let  in end, x := 5)}  do let import "empty.tih" in int {x = break, x = nil}  end then new int
x()
class x {var x := 5 var x := 5} 
class x {var x := 5} 
type x = array of int
if x.x.x.x := let import "empty.tih" in -() end then int [x.x.x(for x := 5 to nil do (), int {x = (), x = nil} )] of x.x.x()|if int {x = int {x = "totor"} , x = let  in end}  then int {x = let  in 5 end, x = -"totor"} 
x["totor"][while nil do break] := x[5]-if int {}  then x[()]|int {x = x[nil].x := x[()].x(x.x(), "totor"+"totor")} 
class x {var x := 5} 
function x(x : int, x : int) = new int class x {var x := 5}  function x() = nil var x := 5
function x(x : int) = for x := x to int [nil] of "totor" do int {x = 5, x = 5} 
int [x.x[x()][int {} ].x((x(nil, nil)), for x := (nil ; 5) to int {x = int [break] of (), x = while "totor" do 5}  do if while () do nil then int {x = ()} )] of x(let var x := 5 in while "totor" do 5 end, for x := int {}  to int [x.x()] of int {}  do x(if nil then nil, x()))
function x(x : int, x : int) : int = int [x] of let  in end
while x[5][let  in end].x := if int {}  then int {} /int {x = nil, x = 5}  else x[5] := int {x = nil}  do int [int {x = let var x := 5 in end} ] of int {} 
let function x(x : int) = int {x = break}  in x.x[x.x((), 5)] ; -if nil then break else "totor" ; int {}  end
x.x.x.x := int {} +while x["totor"] := x.x((), nil) do x.x := if 5 then break else "totor"&x()
int {} 
function x(x : int, x : int) = x.x.x()
function x(x : int, x : int) = int {} 
int {} 
x.x.x[int {} ][int {x = int [x.x()] of x.x("totor", break), x = x["totor"].x()} ].x(x[()].x[x[()]], int {} )
x[()].x.x.x
function x(x : int, x : int) = int {x = (5), x = x.x()}  class x {var x := 5} 
function x(x : int) : int = (break ; 5) function x(x : int) : int = -5 type x = int import "empty.tih" var x := 5
x(int [int [x[()].x()] of new int] of let var x := 5 var x := 5 in x() end, x[break][int {} ].x.x())
class x {var x := 5 var x := 5} 
for x := x() to x.x.x := int {x = x(5, nil)}  do (x)|x.x[nil&()][int {x = let  in 5 end} ] := let var x := 5 var x := 5 in end
var x : int := int {} 
if let function x() : int = 5 in let var x := 5 in 5 end ; int {}  end then x() else int [for x := new int to x*int {x = break}  do x["totor"]] of int [int {x = x()} ] of int {x = x(nil, 5), x = let  in end} 
int [if x.x.x.x() then x["totor"].x()*int {x = (5)}  else x["totor"][x.x()].x((nil ; 5), if x() then if () then "totor" else break else int {x = 5} )] of x.x[-()].x.x()
int {x = let class x extends int {}  import "empty.tih" in for x := x.x(nil, "totor") to let  in 5 end do (5) end} 
type x = class {var x := 5} type x = array of int type x = int import "empty.tih"
function x(x : int, x : int) = x()
type x = class extends int{var x := 5}
x()
function x(x : int) = let var x := 5 in "totor" ; 5 end
function x(x : int, x : int) = while 5 do nil-while nil do nil
class x {var x := 5} 
function x(x : int) = let var x := 5 in nil end
x[5].x[x[break]][new int].x((int {x = if 5 then 5 else break, x = x.x((), nil)} ), let function x() = "totor" in end)
x[break].x[for x := int {x = 5}  to int {x = "totor"}  do x()][while while break&() do if 5 then break else nil do let var x := 5 in end].x()
class x extends int {var x := 5} 
function x(x : int, x : int) : int = if -break then new int function x(x : int) = int {x = break} 
x(while (x.x(nil, 5)) do x.x[if break then () else "totor"] := let var x := 5 in "totor" ; 5 end, if let import "empty.tih" var x := 5 in end then let import "empty.tih" in end)
function x(x : int) : int = let var x := 5 in end
while int {}  do (x[break] := int [break] of nil ; let  in 5 end ; nil ; 5)
--x.x.x
let function x(x : int) = x.x() var x := 5 in end
function x(x : int, x : int) = x()
var x : int := x()
function x(x : int) = x[break]
function x(x : int) : int = x.x.x() class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
function x(x : int) : int = new int class x extends int {var x := 5} 
type x = array of int function x(x : int) : int = x var x := 5 import "empty.tih"
let function x(x : int) : int = let  in end in end
x()
if for x := let import "empty.tih" var x := 5 in x(5, nil) end to -int [x.x()] of -"totor" do int [x.x := x := "totor"] of x(let  in end, -"totor") then int [x.x[if 5 then 5 else "totor"]] of let var x := 5 in end else new int
x()
x[break].x.x[x.x.x := let var x := 5 in end]
type x = class extends int{var x := 5}
int [int {} ] of x[nil][int {x = 5, x = nil} ][while let  in end do nil&5].x()
int {} 
for x := int {x = x[()].x, x = while -int {}  do x-let  in end}  to new int do if let import "empty.tih" var x := 5 in let  in end end then x() else if int {x = x("totor", ()), x = if 5 then nil}  then x[()].x(let  in 5 end, x(break, "totor"))
new int
var x := x.x()
new int
var x : int := x.x() function x(x : int) : int = -nil
function x(x : int, x : int) : int = for x := new int to int {x = nil, x = nil}  do x("totor", 5)
int {x = (let var x := 5 in end), x = x(x(), for x := new int to int {x = while () do "totor", x = int {x = break} }  do int {x = (5), x = int {} } )} 
function x(x : int) = int [int {} ] of nil+break
x.x.x.x[if x[()] then x[5]]
x.x.x[for x := new int to x := nil do if nil then "totor"].x.x(x[5].x[-for x := () to 5 do "totor"].x(), x[()].x.x)
if x(-let var x := 5 in end, -int {x = -5} ) then x()
let function x(x : int) : int = if nil then "totor" else "totor" in x() end
x.x.x.x[let import "empty.tih" in if 5 then 5 ; break ; 5 end] := for x := --x := nil to x(-"totor"+()+5, let var x := 5 in end) do int [x(x.x("totor", "totor"), x)] of if for x := 5 to 5 do nil then let  in end
class x extends int {var x := 5} 
function x(x : int, x : int) = int [x(nil, "totor")] of let  in end class x extends int {var x := 5}  class x {}  import "empty.tih"
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
new int
int {x = x["totor"][x].x.x(int {x = int [int {} ] of x(), x = while for x := break to "totor" do "totor" do for x := "totor" to 5 do 5} , for x := int {x = x.x()}  to let var x := 5 in end do let var x := 5 in end), x = x[5].x[while -"totor" do 5*()]} 
x(x.x.x[if x.x() then while break do () else x := break].x(), x(for x := x[5].x(let  in 5 end, new int) to x.x do int [int ["totor"] of break] of for x := break to nil do 5, int {x = x.x.x(), x = if if break then "totor" then if "totor" then () else () else let  in 5 end} ))
if x.x.x[for x := for x := () to 5 do () to int {}  do new int].x(if let var x := 5 in end then let var x := 5 in nil ; 5 end else x.x := let  in end, x[nil][int {} ].x(x[break], (nil ; 5))) then x[()][let  in 5 end][x.x.x(for x := () to break do nil, int [()] of "totor")].x(x[break][new int] := int {x = -break} , x[nil][5*"totor"].x()) else while int {x = while while () do 5 do x()}  do if x.x then for x := let  in end to for x := nil to () do () do while 5 do () else int [x] of x()
if x(int {x = x.x.x(), x = int {x = -break} } , let var x := 5 in (5) end) then -x()
function x(x : int) = x()
int [int {} ] of int [if int [x] of int {}  then x(int ["totor"] of "totor", x.x()) else new int] of for x := x((), nil) to -break do (5)+new int
class x {var x := 5} 
while x[5].x|if int {x = (5)}  then while let  in 5 end do x := () else int {x = x(), x = int [5] of "totor"}  do if x.x.x.x(if 5 then "totor"&x, x.x.x(int {x = "totor"} , if nil then nil else break)) then x() else x.x.x.x(int [int [()] of ()] of if nil then "totor" else (), while x((), break) do x := 5)
var x : int := while break do break class x {var x := 5} 
class x {var x := 5 var x := 5} 
function x(x : int) : int = for x := if "totor" then break else () to -() do for x := () to "totor" do break
type x = {x : int} class x extends int {var x := 5}  class x {} 
x[break].x.x[while if (5) then if break then nil else int [break] of "totor" do x["totor"].x(x, x)].x((x[nil].x(x, "totor"*"totor") ; x.x(5, break)), let var x := 5 import "empty.tih" var x := 5 in end)
class x {var x := 5 var x := 5} 
if let function x() : int = "totor" in x.x.x() ; x.x(5, break) end then while int {x = x[5].x()}  do x.x[if "totor" then nil else ()].x(x[()] := int [break] of 5, int {} ) else while let var x := 5 var x := 5 in end do new int
var x := x() type x = int function x() = break import "empty.tih" var x := 5
function x(x : int, x : int) : int = int [int {x = ()} ] of let  in 5 end
if x(((5) ; ()), x()) then x.x[int {x = (), x = ()} ][int {x = (5), x = (5)} ] := x(int {} , ("totor"))
class x extends int {var x := 5} 
type x = array of int function x(x : int) = while break do nil class x {}  var x := 5
while (let var x := 5 in end ; if "totor" then break) do x()
type x = class extends int{var x := 5}
class x {var x := 5}  class x {var x := 5} 
type x = int function x(x : int) = while "totor" do "totor"
function x(x : int) : int = for x := x.x((), ()) to x() do x.x()
int {x = let function x() : int = 5 import "empty.tih" var x := 5 in end, x = int {x = -x(int [()] of 5, (5)), x = new int} } 
type x = class extends int{var x := 5} type x = {} function x() : int = nil
function x(x : int, x : int) = int {x = (5)} 
int {} 
int {x = let class x extends int {}  in end} 
int {} 
class x {var x := 5 var x := 5}  type x = array of int
int [-x[nil][int {x = 5, x = nil} ].x(int {} , x(int {x = 5} , x := break))] of int {} 
class x extends int {var x := 5 var x := 5} 
int {x = x.x[x.x("totor", ())][int [new int] of new int] := while let var x := 5 in break ; 5 end do x.x.x()} 
int [let function x() = nil in x(x(), let  in end) end] of x["totor"][x.x(break, break)][x(let  in end, ()/())]
var x : int := int {x = ()}  var x : int := () function x() : int = nil
int [if x() then let var x := 5 in end|int {}  else x.x[new int].x(int {x = (5), x = if 5 then ()} , int {} )] of int {x = x(("totor" ; 5), new int)} 
let function x(x : int) : int = if break then () in end
while x(x.x[while "totor" do "totor"], int {x = int {x = x, x = int {x = nil} } , x = x.x := new int} ) do int {} 
class x {var x := 5}  var x : int := 5 function x() : int = break
if x[break].x[x.x := x(nil, 5)] then let function x() : int = nil in end
class x extends int {var x := 5} 
new int
type x = {x : int}
function x(x : int) : int = (nil)
function x(x : int) : int = -x(break, nil)
if x(-for x := x.x() to x() do x.x(), -int {x = if "totor" then "totor", x = x := nil} ) then int {}  else for x := x[break]+int {x = if 5 then 5, x = new int}  to for x := while break do 5 to x := nil do -nil|x() do for x := while int [5] of break do for x := () to 5 do 5 to --"totor" do let var x := 5 in end
type x = array of int class x extends int {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
var x := "totor"/() function x(x : int) = x := nil class x extends int {}  import "empty.tih" var x := 5
x["totor"][let  in 5 end][x.x()*x := nil].x.x(x(), if x[()][x.x()].x(if x.x() then (5) else x.x(), x()) then int {x = x.x, x = while if break then "totor" else 5 do int {x = 5, x = nil} } )
x["totor"].x[if "totor"*"totor" then while 5 do 5][if x() then if nil&break then int {}  else (5)].x(int {x = x(int {} , int {x = nil&"totor", x = x := ()} )} , int {x = x[5][x]} )
int {} 
function x(x : int, x : int) : int = x.x := if () then break
type x = int
class x {var x := 5} 
type x = array of int function x(x : int) = x("totor", "totor") function x() = break var x := 5
class x extends int {var x := 5} 
x.x.x.x[int {} ] := let class x extends int {}  in if int [()] of 5 then x(5, break) else x() ; int {x = break}  end
function x(x : int) = int {} 
function x(x : int) : int = let var x := 5 in 5 end
function x(x : int, x : int) : int = x() function x(x : int) = (5) class x extends int {}  import "empty.tih" var x := 5
type x = int
int {x = x.x.x[x[5].x(x := "totor", x.x(nil, ()))].x()} 
var x : int := int ["totor"] of nil
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
x.x[while 5 do 5].x.x := ((nil))
var x : int := new int
function x(x : int, x : int) : int = -x.x("totor", 5)
for x := let function x() = "totor" var x := 5 in int {x = int {} }  ; -nil end to x.x[-"totor"][x[break] := int {x = ()} ] := if -int {}  then for x := ()-() to for x := nil to break do 5 do if break then break else "totor" do x()
if if int {}  then int [-()] of int [break] of break-x.x.x := new int then (let var x := 5 in break ; 5 end) else x.x.x[for x := x to x.x() do ()*nil].x(x.x.x.x(x.x.x(), x(x.x("totor", nil), -break)), x[5].x := if int [5] of 5 then let  in end)
var x : int := x.x(5, break) function x(x : int) : int = int [break] of break function x() : int = nil
int {x = if let import "empty.tih" var x := 5 in end then int {x = (()), x = let var x := 5 in 5 ; 5 end} , x = new int} 
int {x = x(), x = int [for x := if if () then nil then if () then break else "totor" else let  in end to for x := 5/() to int {}  do let  in 5 end do int {} ] of new int&for x := let  in end to x(nil, 5) do (5)} 
var x : int := while break do break
type x = int
var x := for x := 5 to 5 do break type x = int
int [if x.x := let  in end then x[()] := x("totor", "totor")] of let import "empty.tih" var x := 5 in end&while int {x = for x := while "totor" do 5 to int {x = 5}  do int {} }  do x["totor"].x.x(new int, new int)
if let class x extends int {}  import "empty.tih" in end then if new int then x.x[let  in 5 end]
if -int {x = int [x := nil] of for x := () to 5 do nil}  then if int {x = if int {x = break}  then x(), x = -int [nil] of "totor"}  then int {x = x[5]}  else if int ["totor"] of ()*int {x = 5, x = nil}  then x["totor"] := while nil do () else int {} 
class x extends int {var x := 5 var x := 5} 
x(int {x = while nil-nil*while "totor" do "totor" do for x := (5) to let  in end do if "totor" then 5} , x())
class x {var x := 5}  var x := 5
type x = class extends int{var x := 5} class x extends int {var x := 5} 
x[5].x.x[if for x := int {x = (), x = "totor"}  to x() do int [nil] of nil then x[nil].x(while nil do "totor", x.x())].x()
function x(x : int, x : int) : int = x.x.x(x.x(), int {} )
x(if x[5].x := (() ; 5) then x.x.x.x(let var x := 5 in end, int [let  in 5 end] of let  in 5 end), let class x extends int {}  var x := 5 in end)
class x {var x := 5} 
class x extends int {var x := 5} 
--let var x := 5 in while nil do 5 end
new int
var x : int := new int
int {x = x[()].x[x(int {x = "totor"} , break&break)].x(-x.x.x(x, x.x()), x["totor"][int {} ]), x = int {x = let var x := 5 var x := 5 in x.x(break, "totor") ; nil end, x = int [x(5, "totor")] of if break then 5-if int {}  then x(5, ()) else int [5] of ()} } 
function x(x : int) = for x := x.x(nil, ()) to new int do 5&"totor" function x(x : int) = x := 5 function x() : int = ()
-int {x = x[()].x} 
x[()].x.x.x
class x extends int {var x := 5} 
class x extends int {var x := 5}  class x {var x := 5} 
class x {var x := 5}  function x(x : int) : int = x() function x() = nil
int [for x := new int to x.x[let  in 5 end].x() do x()] of x["totor"][int {x = "totor", x = "totor"} ][x(int {x = 5, x = "totor"} , x.x())] := x[nil].x
function x(x : int, x : int) = x.x function x(x : int) = int {x = nil} 
var x : int := let  in 5 end type x = {} class x {} 
function x(x : int, x : int) = x[nil] := x := nil var x := nil
x[nil][x.x()][int [for x := "totor" to () do break] of x.x()][if int {x = for x := 5 to "totor" do (), x = x.x("totor", 5)}  then x() else let var x := 5 in () ; 5 end].x(x.x[let  in end][int {x = (5), x = for x := 5 to 5 do 5} ] := x(), for x := while int {}  do int [if () then () else nil] of for x := () to "totor" do "totor" to x[nil][x.x()] := let var x := 5 in break end do int {x = x()&while 5 do break, x = x(if break then 5, x := 5)} )
let type x = class {} type x = int var x := 5 var x := 5 in (if 5 then 5 else "totor") ; x.x.x() ; "totor"-5 end
class x extends int {var x := 5 var x := 5} 
if x[nil].x.x.x() then int {x = let import "empty.tih" in int {x = 5}  ; "totor" ; 5 end, x = let var x := 5 var x := 5 in if nil then () ; () end}  else for x := new int to if let var x := 5 in end then -x.x() do new int
type x = array of int
while x.x[-nil].x()+new int do int {x = int {} } 
x()
class x {var x := 5 var x := 5} 
if (int {} ) then x[()][x.x(nil, break)][x(let  in end, x((), ()))]
class x extends int {var x := 5}  function x(x : int) = int {x = 5}  class x {}  import "empty.tih" var x := 5
x[()].x[x.x.x(for x := nil to nil do (), x.x())][let var x := 5 var x := 5 in int {}  end] := -let var x := 5 in end
(x(let var x := 5 in end, x[break]))
x[nil][int {x = ()} ].x.x
class x extends int {var x := 5 var x := 5} 
function x(x : int) = -(5) var x : int := "totor"
class x {var x := 5 var x := 5} 
class x {var x := 5 var x := 5}  type x = int class x {} 
type x = class extends int{var x := 5}
-let class x {}  in let var x := 5 in "totor" end end
x(x(), int {x = int [int {} ] of x[break] := (5)} )
int [while let import "empty.tih" in int [()] of () end do x["totor"][-nil]] of int {} 
x.x.x.x[int {x = x[5], x = x()} ].x()
(int {} )
let type x = {} function x() = () import "empty.tih" var x := 5 in end
int {x = new int} 
let class x extends int {var x := 5}  function x() = 5 in end
(x[5].x.x(for x := let  in 5 end to if break then () else break do int {x = (), x = ()} , x(let  in end, while nil do 5)) ; x(x, -"totor"))
int {} 
function x(x : int) = -x(nil, break) var x : int := break
int {x = for x := x.x[x()].x(while x(break, 5) do x.x(), x()) to (int {x = break, x = "totor"}  ; 5) do for x := nil/"totor"+(5) to int {x = if () then () else (), x = int [()] of 5}  do x(int {} , x.x())} 
let function x() = () in if x.x(break, break) then int {}  else let  in 5 end end+int {x = for x := x.x.x() to let var x := 5 in nil end do int [int {x = (), x = break} ] of x} 
function x(x : int) = x() class x extends int {var x := 5}  class x extends int {} 
(int {x = while x.x() do for x := () to break do "totor"}  ; -x := 5)
class x extends int {var x := 5 var x := 5}  function x(x : int) = int [5] of 5
int [int {} ] of int {x = -if -"totor" then -5 else if nil then 5, x = int [x()] of while int [nil] of nil do let  in end} 
function x(x : int) : int = x.x
function x(x : int) : int = x[nil] := x := nil type x = {} class x {} 
x()
(int {x = if int {x = 5, x = ()}  then x(), x = x.x}  ; int {x = "totor", x = ()} /x("totor", 5))
-new int
var x := int {x = break}  function x(x : int) = int {x = "totor"}  class x {} 
int {x = x[()].x.x()/int [new int] of let var x := 5 in end} 
function x(x : int) : int = let var x := 5 in end
x(x[break].x[x()], -let import "empty.tih" in x.x() end)
x[5].x.x[x[()][while break do nil].x()]
x["totor"].x[while let  in end do int {} ].x.x()
function x(x : int, x : int) = x.x.x() class x {var x := 5}  var x := 5
for x := -let var x := 5 in break end-while int {}  do if new int then int {}  to x(let import "empty.tih" var x := 5 in for x := 5 to 5 do () ; () ; 5 end, for x := (5) to if x then let  in 5 end do int {x = -nil} ) do int [int {x = x} &if ()/nil then x("totor", nil)] of if x[nil] then int {x = 5} |x(5, 5)
type x = class extends int{var x := 5}
class x {var x := 5} 
-let var x := 5 in end*-x((), break)*int {} 
type x = {x : int}
function x(x : int) : int = -new int function x(x : int) : int = for x := break to "totor" do ()
int {x = int {x = x(), x = let import "empty.tih" in -break ; () ; 5 end} , x = int {x = x(), x = int [if let  in end then x.x() else x.x()] of for x := let  in end to int {x = (), x = ()}  do if 5 then "totor"} } 
type x = class {var x := 5}
int {x = int {x = x.x.x.x()} , x = while x.x[x].x(x[()] := while break do break, int [for x := nil to 5 do ()] of int {x = nil} ) do for x := x.x.x() to x.x.x() do let var x := 5 in 5 ; 5 end} 
function x(x : int) = int {x = int [5] of break, x = x.x()} 
var x : int := let  in 5 end
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
function x(x : int) = let var x := 5 in break ; 5 end
var x := int {x = nil} 
int {x = x(if x()-int {}  then x.x else int {} , if for x := x := break to int {x = break}  do while () do () then let var x := 5 in "totor" ; 5 end)} 
function x(x : int) = -(5) type x = class {}
-x()
class x extends int {var x := 5}  class x extends int {var x := 5} 
function x(x : int, x : int) = int {} 
function x(x : int, x : int) : int = new int function x(x : int) = nil|5
x()
var x := x.x()
class x {var x := 5}  var x : int := nil
int {} 
class x extends int {var x := 5 var x := 5} 
x[nil][for x := break to () do break].x[x.x[nil+"totor"].x(let  in 5 end/int {} , x[nil])] := x(if int {x = for x := () to break do break}  then x[5], for x := -x to let var x := 5 in nil ; 5 end do int [if break then break else break] of int [nil] of "totor")
function x(x : int, x : int) = x["totor"] function x(x : int) : int = int {x = nil, x = ()}  class x extends int {} 
var x : int := int {x = 5} 
let type x = class extends int{} in x[()].x(let  in 5 end, 5+5)&x["totor"].x() ; int {x = while nil do nil, x = -break}  end
class x {var x := 5 var x := 5} 
x[break].x[if break/nil then int {x = break}  else new int].x.x(int {x = -x.x.x()} , x.x[if break then nil][x.x()|x()] := x())
x(x.x.x.x, --while let  in end do x := ())
x[break].x[let var x := 5 in break end][for x := x["totor"] to new int do while int {x = ()}  do -"totor"] := int {} 
class x extends int {var x := 5}  function x(x : int) : int = -"totor" function x() = 5
if x[nil].x[x.x.x()] then x.x[x()].x.x(for x := while "totor"|break do ()+5 to x[()] do if 5*() then (5), int {x = int {} , x = x[break].x(int {x = "totor", x = break} , x())} ) else x()
var x : int := int [5] of break class x extends int {var x := 5}  class x {}  var x := 5 var x := 5
type x = class {var x := 5} type x = int
function x(x : int) = new int
function x(x : int) = let var x := 5 in end type x = array of int var x := 5
x()
class x extends int {var x := 5} 
function x(x : int, x : int) : int = let var x := 5 in break ; 5 end class x {var x := 5} 
var x : int := for x := () to "totor" do ()
function x(x : int) = x.x := int {x = nil, x = "totor"}  type x = int function x() : int = () var x := 5
new int
x()-let function x() : int = nil in x() end
(x.x.x()-int {} )
class x extends int {var x := 5} 
int {x = int {x = new int} } 
-x()
int {x = int {x = let var x := 5 var x := 5 in end, x = x(if 5 then "totor" else 5+int {x = "totor", x = 5} , new int-x(nil, break))} , x = x(int {} , if x.x := (5) then let var x := 5 in () end else x.x := while "totor" do nil)} 
while x[()].x[-let  in end].x() do x[nil][let  in end].x.x()
class x extends int {var x := 5}  var x : int := () class x extends int {}  var x := 5 var x := 5
int {x = int {x = (int {x = 5, x = 5} )} , x = new int} 
int {x = for x := while x(x.x(), x := ()) do for x := x.x() to x.x((), 5) do (5) to let import "empty.tih" in ()-() ; break ; 5 end do for x := int {x = int {x = break} }  to x.x do new int} 
x[5].x.x.x
var x := break/() function x(x : int) = x := 5
while x[nil].x[x(int {x = break, x = ()} , x())] do new int
let var x := nil class x {}  var x := 5 var x := 5 in end
x[break][(5)].x[x.x.x := x.x.x(for x := 5 to nil do break, if 5 then 5 else "totor")]
let class x {var x := 5}  in for x := x.x to x["totor"].x(x.x(), x.x()) do int {}  ; x.x.x() ; int [5] of 5 end
class x {var x := 5 var x := 5} 
new int
let class x extends int {var x := 5}  in (int {x = break}  ; "totor") end
x.x[int {x = (), x = ()} ][new int][x.x.x].x()
class x {var x := 5} 
int {} 
type x = {x : int}
function x(x : int) = int {} 
class x {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
x[5][x := "totor"].x.x
int [x[()].x.x] of int {} 
function x(x : int) : int = x[nil].x((5), x)
function x(x : int, x : int) = int {}  type x = class {}
class x {var x := 5}  function x(x : int) = int [break] of nil function x() = break
int {x = x[break].x[new int] := x.x[if "totor" then "totor" else 5].x(while x.x(5, nil) do int {x = nil} , x.x.x(int {x = "totor"} , x.x())), x = x(x.x.x, if int {}  then x(break&nil, x := break))} 
class x extends int {var x := 5}  function x(x : int) : int = let  in 5 end type x = int
type x = {x : int}
var x := x class x extends int {var x := 5}  class x {} 
if if x.x.x := int {}  then x["totor"][x()].x(x["totor"] := -nil, new int-int {x = break, x = break} ) then x()
x()
x[break].x.x[x.x[x := nil].x(-x.x(), if x.x() then int {x = break}  else -"totor")].x(int [if if int [5] of () then int {x = "totor", x = break}  then for x := x.x(5, break) to let  in end do x := nil] of x["totor"].x := if int {x = (), x = ()}  then x := nil, let var x := 5 in end)
let var x := () in int {}  end
int {} 
function x(x : int) : int = int {}  type x = {} function x() : int = () import "empty.tih" var x := 5
for x := x[break][for x := "totor" to "totor" do "totor"].x to x["totor"].x[x[nil]].x() do (x.x.x())
if new int then (int {x = let  in 5 end} ) else if int {}  then (x(nil, nil) ; nil ; 5) else (nil)|int {} 
function x(x : int, x : int) = x() function x(x : int) : int = break&5 type x = int
var x : int := if nil then "totor"
class x {var x := 5}  type x = {} type x = int import "empty.tih"
class x extends int {var x := 5 var x := 5}  type x = int
var x : int := x.x()
function x(x : int) = int {x = let  in end} 
var x := int {} 
while (if nil then 5-let  in 5 end) do let function x() : int = 5 in if x.x((), break) then x() end
var x := if break then break var x := 5
function x(x : int) = while if 5 then "totor" else 5 do x()
function x(x : int) : int = -(5)
while int {x = while if (5) then x do while break do break+-break, x = int {} }  do let var x := 5 in end
function x(x : int, x : int) = let var x := 5 in end
if int [int {} ] of int {x = let var x := 5 in end}  then int {} 
-while x.x[let  in end].x() do int {x = int {} } 
class x {var x := 5 var x := 5}  type x = int
var x : int := -"totor" function x(x : int) = x.x() function x() : int = break import "empty.tih"
for x := x.x[-5][if x("totor", nil) then let  in end else x.x(break, nil)].x() to new int do x((x()), int {x = if -"totor" then if break then nil else (), x = int [int {} ] of 5&"totor"} )
new int
type x = {x : int}
x.x.x.x.x := int {} 
var x : int := -5 function x(x : int) : int = (5)
for x := int {}  to --x/x[nil][(5)] := let var x := 5 in end do new int
int {x = int {x = let var x := 5 in if break then "totor" ; nil ; 5 end} } 
var x : int := int [nil] of 5
if int [for x := new int to let  in 5 end do x.x((), ())] of x.x.x()-x.x.x then while int {x = while int {x = nil, x = break}  do (5)}  do new int+if let  in 5 end then while 5 do break else int {x = x(), x = x((5), new int)|let var x := 5 in end} 
type x = {x : int}
var x : int := x.x(break, 5)
int {x = if new int then int [-5/nil] of x[nil] := while () do 5} 
class x {var x := 5 var x := 5}  type x = class extends int{} class x extends int {} 
function x(x : int, x : int) = x(x.x(), nil+break) function x(x : int) : int = new int var x := 5
var x := while () do () function x(x : int) = x function x() = ()
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  type x = int var x := 5 var x := 5
class x {var x := 5}  type x = array of int class x {}  var x := 5 var x := 5
int {x = (let var x := 5 in end ; if "totor" then "totor" ; nil)} 
class x {var x := 5}  type x = int class x extends int {} 
type x = class {var x := 5}
function x(x : int) = let var x := 5 in end
-x.x[for x := "totor" to () do "totor"][int [x := break] of x.x()].x()
function x(x : int) : int = x.x.x(let  in end, x := "totor")
int {x = let type x = int in end, x = if x((5), x := nil) then -x := nil/if while int [break] of break do x then int {x = x, x = break/break} } 
x()
x.x.x[x()][int [if x.x() then -() else x.x(nil, 5)] of (break ; 5)].x()
for x := x()+x["totor"].x.x((break), int [x.x((), nil)] of x := nil) to x(let var x := 5 in let  in end ; 5 ; 5 end, let var x := 5 in x(nil, nil) end) do let function x() = break import "empty.tih" var x := 5 in end
while let var x := 5 in end do x.x[while break do break][int {} *x("totor", "totor")]
function x(x : int, x : int) : int = x()
-if x.x[(5)] then let import "empty.tih" in if break then "totor" end
x.x[int {x = "totor"} ][x.x][x["totor"][int {x = "totor", x = break} ]]
int [while x[break][int ["totor"] of nil].x() do int [if int {x = nil}  then x := break else 5-()] of int {x = int [nil] of (), x = new int} ] of let class x {}  in x.x := x.x() end
class x {var x := 5 var x := 5} 
var x := for x := break to () do break
function x(x : int, x : int) : int = x.x.x(for x := () to break do nil, x)
class x {var x := 5 var x := 5}  class x {var x := 5} 
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = x
for x := int {}  to -x(for x := int {x = (), x = nil}  to -nil do break|nil, x(while "totor" do "totor", let  in 5 end)) do -let import "empty.tih" var x := 5 in let  in end ; break ; 5 end
type x = class extends int{var x := 5}
for x := while int {x = if -"totor" then int {} }  do if x(let  in 5 end, for x := "totor" to 5 do "totor") then if break|nil then break*break else if x.x((), 5) then (5) to new int do -for x := x(x := 5, for x := 5 to nil do nil) to if int [5] of "totor" then x.x() else x.x() do let var x := 5 in 5 end
type x = int function x(x : int) = for x := () to nil do ()
function x(x : int, x : int) : int = let var x := 5 in end class x {var x := 5}  class x {} 
class x extends int {var x := 5 var x := 5} 
while x[nil].x[while (5) do let  in 5 end] do if x(while int {x = break, x = ()}  do x(5, ()), let var x := 5 in () ; 5 end) then -let var x := 5 in nil end else x.x.x(()+"totor", for x := 5 to () do nil)-for x := x(nil, nil) to let  in 5 end do x((), 5)
x()
x.x.x.x.x := new int
class x {var x := 5}  type x = class {}
if int {x = x()}  then int {x = new int/int {} } 
class x {var x := 5}  type x = array of int
x()
int [if let var x := 5 var x := 5 in -"totor" ; "totor" end then while x() do int {x = int {x = 5} , x = -()} ] of (let var x := 5 in "totor" end ; x ; () ; 5)
x()
x.x.x[x(int [()] of "totor", int [break] of ())][x(for x := int {x = break, x = ()}  to nil/5 do x := break, x(new int, int {x = break} ))].x()
x["totor"].x.x[if x[()] := if () then () then x.x := let  in end].x(-if x.x.x() then let var x := 5 in "totor" ; 5 end else ("totor"), new int)
while x.x.x[x.x.x()] := -if 5 then break else break/x(break, 5) do (while -break do let  in end ; if break then "totor" ; ())
if x.x[x.x((), break)][new int] then int {} 
function x(x : int) = let var x := 5 in () ; 5 end
let function x(x : int) : int = if () then "totor" else nil class x {}  in end
int {} 
class x {var x := 5 var x := 5} 
class x extends int {var x := 5}  function x(x : int) = int {x = 5}  type x = int var x := 5 var x := 5
int {} 
type x = class {var x := 5} var x := 5
new int
class x {var x := 5}  function x(x : int) = x var x := 5
let type x = array of int type x = int import "empty.tih" var x := 5 in x[()].x.x() end
let class x {var x := 5}  in for x := let var x := 5 in end to new int do let var x := 5 in end ; if while 5 do break then int {}  else x.x(nil, ()) ; x.x() ; nil end
class x extends int {var x := 5} 
class x {var x := 5} 
class x {var x := 5} 
var x : int := int {}  function x(x : int) : int = new int class x {}  import "empty.tih"
let function x(x : int) = let  in 5 end var x := 5 import "empty.tih" var x := 5 in end
new int
class x {var x := 5}  class x {var x := 5} 
var x := x() function x(x : int) = x()
type x = array of int function x(x : int) = let  in end
class x {var x := 5 var x := 5} 
int [let class x extends int {}  in end] of int {x = if int {x = for x := () to nil do 5}  then if if nil then () then new int else int [()] of break, x = x.x.x.x(while int {x = ()}  do if "totor" then 5, x.x.x(x(), while break do break))} 
function x(x : int, x : int) : int = (() ; 5) class x {var x := 5} 
let function x(x : int) = if break then 5 else "totor" in let var x := 5 var x := 5 in end ; x() ; x() ; 5 ; 5 end
while x(-while for x := 5 to 5 do 5 do x.x((), "totor"), -new int) do -for x := x.x.x(int {} , if break then 5 else "totor") to int {x = x(break, ()), x = int [break] of break}  do x.x := int {} 
type x = class {var x := 5} var x : int := break
var x : int := while 5 do nil
x[5][int [nil] of 5][while int {x = ()}  do int {x = ()} ].x
while x[break].x[-int {} ].x(if let var x := 5 in 5 end then new int else x(int {} , break&()), if x.x := x := break then int [x()] of (5) else while nil+break do (5)) do while let var x := 5 in end do if let var x := 5 in nil ; 5 end then x.x.x() else new int
new int
function x(x : int, x : int) = (break ; 5)
int {x = x["totor"].x[x.x.x()].x()} 
if int {}  then x.x.x[while int {x = 5}  do x()].x((let  in end), for x := (5) to let var x := 5 in end do x.x := for x := () to break do break)
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = x()
class x {var x := 5 var x := 5}  class x {var x := 5} 
type x = class extends int{var x := 5}
function x(x : int, x : int) : int = let var x := 5 in end
x.x.x[while (5) do int {x = nil, x = "totor"} ][(int {x = 5}  ; () ; 5)] := int [x.x[let  in 5 end].x()] of x.x[-nil].x(int {x = for x := () to break do 5, x = new int} , -int [5] of ())
class x extends int {var x := 5}  var x : int := ()
function x(x : int) : int = x["totor"]
-x.x[while nil do 5].x.x()
let class x {var x := 5}  in x(new int, (break ; 5)) ; x.x := -() ; -"totor" ; "totor" end
if while x(while if nil then nil do x(5, ()), x[5] := x()) do x[break].x := for x := x.x() to 5-5 do x.x() then if x.x.x := new int then if let var x := 5 in () ; 5 end then let var x := 5 in end else x.x := x else new int
let class x extends int {var x := 5}  function x() = () var x := 5 in let import "empty.tih" in int [break] of () end end
new int
var x : int := if "totor" then 5 else "totor"
x(x.x[for x := 5 to break do "totor"][new int].x(x.x.x.x((() ; 5), while x() do if 5 then nil), for x := int [int {} ] of int {x = "totor", x = "totor"}  to x(new int, if 5 then ()) do for x := x(break, ()) to new int do int {} ), int {} )
class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = int [()] of nil class x extends int {}  var x := 5 var x := 5
class x extends int {var x := 5}  class x extends int {var x := 5}  function x() : int = 5 var x := 5 var x := 5
var x := let  in 5 end
-while if let var x := 5 in "totor" ; 5 end then int {}  else x.x do while if -5 then int {x = nil}  do let var x := 5 in 5 end
x()
class x extends int {var x := 5 var x := 5} 
if x.x.x.x then if x() then if x := nil then x := 5 else x := 5&x[break] else while (x.x()) do if x((), nil)*x := "totor" then x() else x[nil]
var x : int := x()
let var x := break in x(--nil, -nil&nil) ; for x := () to () do "totor"|x() ; if 5 then "totor" else () ; nil ; 5 end
(-(break ; 5))
int {x = x.x.x.x(int {x = x, x = int {x = ()} } , x())&for x := --"totor" to -if "totor" then "totor" do -new int} 
function x(x : int, x : int) : int = int [if nil then nil else ()] of int {}  function x(x : int) = while 5 do 5
while x.x[x()][-x((), break)].x(int [new int] of for x := nil to () do 5-x.x(5, "totor"), x()) do let class x {}  import "empty.tih" in x[()].x() ; (5) ; "totor" end
let function x(x : int) : int = nil&() type x = int var x := 5 var x := 5 in end
int {} 
function x(x : int) = x["totor"] := int ["totor"] of 5 function x(x : int) : int = for x := () to nil do break type x = int import "empty.tih" var x := 5
type x = {x : int} class x {var x := 5}  var x := 5 var x := 5 var x := 5
var x := int {x = 5, x = "totor"}  class x {var x := 5} 
x()*x(int {x = int {x = int {} } , x = let var x := 5 in end} , x[()].x)
let class x extends int {var x := 5}  in end
int [int {x = if new int then int {} , x = int {x = x(new int, 5+nil), x = for x := new int to int {x = break}  do x.x()} } ] of x[nil].x.x.x()
function x(x : int) = x.x.x(x.x(nil, 5), x := ())
function x(x : int, x : int) : int = -x.x() var x := ()
type x = class {var x := 5}
function x(x : int) : int = int [while break do "totor"] of let  in end function x(x : int) = (5) class x extends int {} 
int {x = for x := x.x.x.x(int [5&nil] of if nil then () else "totor", if x := break then let  in end) to x(let  in end, x := nil)&new int do -while x := () do x(), x = for x := -x() to if for x := x(5, break) to ()|break do x((), nil) then if x.x() then x() else while () do break do for x := (() ; 5) to new int do x.x} 
class x {var x := 5}  class x extends int {var x := 5}  class x {} 
-let function x() : int = "totor" in end
var x := x.x(break, nil) function x(x : int) = int {x = "totor"}  function x() = () import "empty.tih"
-int {x = x(), x = -int {} } 
if new int then x.x[if () then () else ()].x.x(int {x = let var x := 5 in break end} , int {x = while int {}  do break-()} ) else new int
class x extends int {var x := 5 var x := 5} 
if int [int {x = let var x := 5 in break end, x = -x := ()} ] of int {}  then if x[break][int [break] of 5].x() then int {x = let  in end-int {x = (), x = break} , x = int {x = x.x()} }  else x[nil].x.x.x()
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  var x := 5
type x = int
class x {var x := 5 var x := 5} 
function x(x : int, x : int) : int = for x := "totor" to 5 do nil*int {x = 5}  type x = class extends int{}
int [int [5&()] of if "totor" then ()&let var x := 5 in "totor" end] of if -int {}  then x[break] := x.x() else int {x = int {x = "totor", x = 5} , x = -5} *int [x[()][x.x((), ())].x()] of if int {}  then x()
int {x = int {x = -("totor" ; 5)} , x = int {} } 
while -x.x.x.x(let var x := 5 in break end, x[break]) do if int {}  then x.x.x.x(int {} , new int)
var x : int := -5
let class x {var x := 5}  class x {}  in new int ; while x() do new int end
function x(x : int, x : int) = x.x
class x {var x := 5} 
(int {x = int [x(break, 5)] of int {} , x = (())}  ; let var x := 5 in "totor" end)
new int
function x(x : int) : int = x[5]
var x : int := break-5 class x extends int {var x := 5}  var x := 5
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) = x.x.x(x := "totor", x())
class x extends int {var x := 5 var x := 5}  type x = class {}
var x := if 5 then nil function x(x : int) = x := "totor"
x[5].x[let var x := 5 in end][int {x = let var x := 5 in nil end, x = if int {}  then if "totor" then nil else break else int [break] of 5} ]
int {} 
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5} 
int {x = (for x := int {}  to new int do ()/"totor")} 
class x extends int {var x := 5 var x := 5} 
type x = {x : int}
for x := let class x {}  import "empty.tih" in x.x.x(int {x = 5, x = "totor"} , (5)) ; (5) ; () end to int {}  do for x := while x[nil] := int {}  do x(x := "totor", int {x = 5, x = nil} ) to int {x = if x.x(break, nil) then -(), x = x.x}  do for x := int [(5)] of "totor"&nil to ("totor" ; 5) do int {x = int {x = nil, x = break} , x = int {x = break} } 
new int
x["totor"].x.x.x(int {x = int {x = int {x = break, x = 5} } } , int {} )-let var x := 5 in end
x[nil][x].x[if if ()-break then x else x("totor", ()) then x[nil].x()].x(x["totor"][int {x = nil, x = ()} ].x.x(), if for x := x(for x := nil to break do (), while 5 do break) to x.x := let  in end do int ["totor"] of 5*"totor"*nil then int {}  else x[5][x(nil, ())].x())
function x(x : int, x : int) : int = x[5] class x extends int {var x := 5} 
x.x.x[x.x][int {} ]
class x extends int {var x := 5} 
function x(x : int) : int = x[break] function x(x : int) : int = int {x = nil}  function x() = () import "empty.tih"
if if x.x.x := new int then x[5].x else x["totor"].x := x.x.x() then new int else let class x {}  import "empty.tih" in end
class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  type x = {}
var x : int := int {x = (), x = break}  type x = int var x := 5
x.x[let  in 5 end][-int {} ][int {x = let var x := 5 in 5 ; 5 end, x = if x := "totor" then x() else let  in end} ].x()
class x extends int {var x := 5} 
int {x = --let var x := 5 in 5 ; 5 end, x = (x[break] := x(5, ()))} 
x()
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
for x := int {x = int [x(if nil then 5 else (), x())] of let var x := 5 in end}  to let type x = int in while x() do if break then "totor" else () end do int {} 
int [int [let import "empty.tih" var x := 5 in end] of int {x = x.x := int {} , x = int {x = x()} } ] of x[break][-5][int {} ].x(while int [x.x()] of if break then nil do let var x := 5 in break end, (int [nil] of break ; nil ; 5))
for x := (x.x.x()) to for x := (()) to if new int then (5) else (5) do int {x = break-nil, x = int {x = "totor", x = ()} } /while while x do let  in 5 end do (nil) do -let import "empty.tih" var x := 5 in if break then "totor" else 5 end
int {x = x[break][int {x = break, x = 5} ][int {x = ()} |x.x()].x(-x((), nil)-x.x((), nil), int {x = if new int then x.x((), "totor") else let  in 5 end} )} 
int {x = (x() ; if () then () else break ; "totor" ; 5)} 
let class x extends int {var x := 5}  in x.x[int {x = ()} ] ; -5/5/() ; x := 5 end
x["totor"].x[x()][(x.x())].x(let function x() : int = "totor" in end, (let var x := 5 in 5 ; 5 end ; x ; break))
function x(x : int) = x.x.x() var x := () function x() : int = "totor" var x := 5 var x := 5
x[()].x[if -break then for x := () to "totor" do "totor" else (5)].x := let class x {}  import "empty.tih" in end
x()
if (()*break&x.x(5, nil)) then int {}  else --x()
type x = array of int
x.x.x.x.x
var x := int {x = break, x = break} 
function x(x : int, x : int) = if x() then "totor"/()
x.x[while "totor" do 5][let var x := 5 in end].x.x(int {x = x.x.x := x["totor"] := ()-break, x = x.x[(5)]} , x(x[nil].x.x(let var x := 5 in end, int {x = let  in 5 end} ), let var x := 5 in break end*int {x = while "totor" do nil, x = for x := 5 to 5 do nil} ))
type x = int function x(x : int) : int = if () then 5 else ()
var x := x.x()
x.x.x[int {} ][-x.x.x()]
class x {var x := 5}  type x = array of int class x extends int {}  import "empty.tih" var x := 5
x.x.x.x[if int {x = (5)}  then (break ; 5) else while for x := () to nil do "totor" do let  in end] := if x.x[int {x = nil} ] then int {x = if int ["totor"] of "totor" then x.x(break, "totor") else int {x = nil, x = nil} }  else let var x := 5 in end/if ()/nil then for x := 5 to 5 do nil else if () then () else 5
for x := --int {}  to x(x[5][(5)].x(while int {x = (), x = break}  do x, int [if nil then 5 else 5] of (5)), let var x := 5 var x := 5 in while "totor" do "totor" end) do -if (5 ; 5) then let var x := 5 in end
x[nil][if 5 then break].x[let import "empty.tih" in end].x()
function x(x : int) = x.x.x()
function x(x : int, x : int) = x()
x[5].x[for x := if () then break to int {x = break}  do let  in end][x.x[int {x = 5} ] := for x := x := break to while break do "totor" do x := ()].x(new int, if x.x.x then x.x[x.x("totor", "totor")] else int {} )
let type x = class {} in while x.x.x((5), new int) do x[5] := if 5 then nil else 5 ; x[break] end
x(new int, int [x.x.x] of while x[break] := (5) do int {x = new int} )
function x(x : int, x : int) = x&-nil type x = {}
x[5].x[x()][(nil ; 5)+int {} ].x(x[5].x.x.x(), x.x[x.x()].x := let var x := 5 in end)
class x extends int {var x := 5 var x := 5}  type x = array of int var x := 5
x(int {} , while if let var x := 5 in end then if break-5 then x else let  in 5 end else int {x = let  in end, x = int {x = 5} }  do if new int|nil|() then x.x)
x()*new int
let class x extends int {var x := 5}  function x() : int = () import "empty.tih" in end
function x(x : int) = let var x := 5 in break ; 5 end var x : int := "totor"
var x : int := x() type x = class extends int{} var x := 5
type x = {x : int} class x {var x := 5} 
type x = int
int [x()] of let var x := 5 in end
let class x {var x := 5}  function x() : int = "totor" import "empty.tih" var x := 5 in x[break][int {x = 5, x = 5} ].x() ; -x() ; if 5 then break ; 5 end
type x = int var x : int := nil function x() : int = () import "empty.tih"
class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
var x := int {}  var x : int := "totor" class x {} 
x[()].x[if x then x.x()][let var x := 5 var x := 5 in x ; () end] := let var x := 5 import "empty.tih" in new int end
int {x = int [-if nil*nil then x.x("totor", 5) else let  in 5 end] of x()} 
class x {var x := 5 var x := 5}  function x(x : int) = int [5] of nil type x = int
int {x = while let import "empty.tih" var x := 5 in int {}  ; "totor" end do (x)} 
class x extends int {var x := 5}  function x(x : int) : int = -"totor"
let function x(x : int) = if "totor" then nil else break in int {x = int {} , x = x.x(break, break)/()+()}  ; int [if () then "totor" else break] of (5) ; -break end
class x {var x := 5} 
class x {var x := 5}  function x(x : int) = while break do "totor" function x() = break
var x := int {x = "totor"}  class x {var x := 5} 
var x := x((), ()) var x := break var x := 5 var x := 5
int {x = x.x[new int][int {x = 5, x = break} /if 5 then "totor"].x(), x = -if x.x.x(x.x(), int [break] of "totor") then "totor"&()+-"totor"} 
type x = int type x = {} class x extends int {}  var x := 5 var x := 5
if int {x = x(x(x := (), let  in end), x.x := x((), nil))}  then if x[()].x.x(int {} , -x.x((), break)) then int {}  else x() else (for x := int {x = "totor"}  to if "totor" then nil do for x := "totor" to nil do ())
while x(let import "empty.tih" var x := 5 in int {x = 5, x = nil}  ; nil end, -while let  in end do new int) do int {x = let import "empty.tih" in int {x = 5}  end, x = int {x = new int|nil|()} } 
class x {var x := 5 var x := 5} 
function x(x : int, x : int) = if x() then while nil do break
(x())
int {x = x(if if nil then "totor"+if nil then () then let var x := 5 in "totor" end else let var x := 5 in end, if x[()] then let var x := 5 in end)} 
int {} 
-int [let var x := 5 var x := 5 in x end] of int {} 
function x(x : int) = -5&5
if (x[break]) then if int {x = if x then if break then 5 else (), x = if for x := "totor" to () do break then if () then nil else "totor"}  then while int {}  do x.x.x(new int, new int) else if x[nil][int {x = break, x = ()} ].x(x.x.x(), int [x()] of if 5 then nil) then let import "empty.tih" var x := 5 in end
int {} 
function x(x : int) = x("totor"+break, x) var x : int := 5
let function x(x : int) : int = -break var x := 5 in while x.x := new int do if new int then x() else x ; int {x = x()}  ; int [nil] of 5 ; "totor" end
var x := let  in 5 end
function x(x : int, x : int) : int = x[nil]
x((for x := if 5 then () to x.x() do ()&break ; if "totor" then "totor" else break ; 5), while x() do int {x = for x := int {}  to let  in 5 end do new int, x = -int {} } )
int {x = int {x = x[break][let  in 5 end] := int [-()] of int {} } , x = x[break].x.x.x()} 
x(x(let var x := 5 in int {x = (), x = nil}  end, int {x = let var x := 5 in end} ), x(x.x[let  in 5 end].x(), x[nil].x))
for x := x.x[new int].x.x(for x := int {}  to int {x = x(5, ())}  do --(), x["totor"].x := if let  in 5 end then -"totor") to x[nil].x.x := int {}  do let function x() = () var x := 5 var x := 5 in end
class x extends int {var x := 5} 
for x := x[5][int {x = "totor", x = break} ][if x("totor", 5) then while break do break else let  in 5 end].x() to if new int then int {x = int {} -let  in 5 end}  do if if x[break] then int [x] of let  in end else x[()] := int {x = "totor", x = 5}  then -x.x.x(if () then () else "totor", int {x = "totor"} ) else x["totor"].x.x(int {x = x.x((), ()), x = if "totor" then "totor"} , x.x.x(while break do break, x(break, "totor")))
let var x := () in int [int [if () then nil] of if break then nil else nil] of x[()].x(x, x := "totor") ; int {x = x()}  end
x[()].x[x[5]][let var x := 5 in nil*break ; 5 end].x(if x.x.x() then int {x = while "totor" do "totor", x = int {x = break, x = "totor"} }  else x(for x := () to nil do "totor", if nil then nil else ())|x.x.x := x(), -let var x := 5 var x := 5 in end)
int {x = x.x[(5)].x := x.x.x := int [x.x(nil, nil)] of x(5, 5)} 
x()
int [x.x.x[x.x]] of int {} 
let var x := nil in end
int {} 
function x(x : int, x : int) : int = int [x((), nil)] of x
let var x := "totor" in end
type x = int
for x := x.x.x.x to for x := -new int to if let var x := 5 in end then (5) do -int {x = x, x = for x := "totor" to 5 do break}  do new int
for x := x.x.x[-int {x = break, x = break} ].x() to int [let import "empty.tih" var x := 5 in for x := break to break do 5 end] of -if x("totor", "totor") then int {x = break}  else x(5, 5) do for x := x["totor"][int {x = 5} ].x() to x["totor"][new int].x() do int [x(x(), let  in end)] of for x := int [break] of 5 to if "totor" then () else () do for x := nil to nil do break
class x extends int {var x := 5} 
let function x() : int = break in end+let type x = int import "empty.tih" var x := 5 in x[5].x(x(nil, "totor"), x((), break)) end
let function x(x : int) = new int in new int end
for x := x(if let  in 5 end then x := () else int {} , int [x := "totor"] of int {} ) to if int [int [5] of nil] of -break then x[()] else while for x := 5 to break do nil do new int do -int [int {x = "totor"} ] of if break then "totor"-x.x.x.x.x()
x.x.x[let var x := 5 in nil end].x
var x := x.x()
int {} 
let function x(x : int) : int = x := "totor" in end
var x := int {}  type x = class extends int{}
int [-x.x|int [new int] of if let  in end then x.x() else x.x(break, 5)] of x[()].x[int {x = let  in 5 end} ].x()
function x(x : int, x : int) = int [let  in end] of x.x() var x : int := "totor" function x() : int = break
if int {x = int {x = x[5].x()} , x = x.x[int {x = break, x = break} ].x()}  then x.x[int {x = ()} ][let var x := 5 in nil end].x(int {x = -x, x = new int} , for x := let var x := 5 in nil end to (nil ; 5) do int {x = x(), x = x.x("totor", 5)} ) else x.x[let  in 5 end].x.x()
function x(x : int, x : int) = x(new int, if "totor" then nil else ())
function x(x : int, x : int) = x.x.x(x.x(), int ["totor"] of break) var x : int := 5
function x(x : int, x : int) = int [if () then nil else "totor"] of if 5 then "totor" else "totor" function x(x : int) : int = for x := break to 5 do nil class x extends int {} 
x()
int {x = x[break].x.x} 
int {x = -if int {x = x.x(nil, 5), x = int [5] of break}  then -int {x = nil}  else x.x := x := "totor"} 
var x := x.x(5, "totor") class x extends int {var x := 5}  class x {}  var x := 5
type x = {x : int} function x(x : int) : int = x.x((), "totor") var x := 5 import "empty.tih"
let function x(x : int) = 5*() in x(for x := for x := "totor" to break do "totor" to while 5 do break do for x := break to () do nil, x()) end
x[()].x[int {x = x.x(), x = int ["totor"] of 5} ].x
var x : int := x.x()
class x extends int {var x := 5 var x := 5} 
int {x = x.x.x.x.x(x[break][let  in 5 end], if while int {x = ()}  do let  in end then int {} ), x = x(-int {x = int {x = 5} , x = int {x = break, x = "totor"} } , x(-break+break, x(let  in 5 end, -())))} 
x()
function x(x : int) : int = int {x = new int, x = x.x((), ())} 
type x = int
int {x = (x(let  in 5 end, while nil do nil) ; int {x = ()} ), x = -x["totor"].x} 
type x = array of int
var x := int {x = nil} 
function x(x : int, x : int) : int = x.x function x(x : int) = ()-5
var x : int := let  in 5 end
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = int {x = x()}  class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
class x {var x := 5} 
-new int
class x {var x := 5 var x := 5} 
if x["totor"].x.x then let class x extends int {}  in int {}  ; for x := () to () do 5 end else x.x.x.x := int {x = x[()], x = let var x := 5 in end} 
-(let var x := 5 in () ; 5 end ; 5*5)
class x {var x := 5 var x := 5}  var x : int := "totor" class x extends int {}  import "empty.tih" var x := 5
-int {x = x[break][-5] := if x(nil, ()) then int {x = 5}  else x := 5, x = x["totor"][while () do nil] := for x := x.x("totor", break) to let  in end do let  in end} 
x.x.x[int {x = if nil then (), x = if () then ()} ][x.x := x&x.x]
function x(x : int, x : int) : int = (() ; 5) class x extends int {var x := 5}  function x() : int = nil
int [int {x = x[nil].x, x = x["totor"][x]} ] of x[()].x.x.x()
if new int then x.x.x[x[break].x(new int, x)].x(-new int, for x := x[nil] to int {x = x(), x = int {} }  do let var x := 5 in "totor" ; 5 end)
class x extends int {var x := 5}  type x = class {}
-let function x() : int = 5 import "empty.tih" in while -"totor" do x end
x(int [for x := x[()].x() to let var x := 5 in "totor" ; 5 end do int {x = 5+(), x = x} ] of x(), x.x[5|break].x.x())
function x(x : int) : int = (5) class x {var x := 5}  class x extends int {} 
class x extends int {var x := 5}  type x = array of int
type x = class extends int{var x := 5} function x(x : int) = -break type x = int
class x {var x := 5}  var x := () var x := 5 import "empty.tih"
class x extends int {var x := 5}  type x = array of int function x() : int = nil
int {} 
let class x extends int {var x := 5}  class x {}  in int [if ()-"totor" then int [nil] of "totor" else for x := 5 to "totor" do "totor"] of x.x.x() ; x[()].x(if () then break else nil, (5)) ; x := 5 end
x(-int {x = (break)} , x.x.x[x[()].x(let  in 5 end, if "totor" then ())].x((int {x = 5, x = "totor"} ), int [if x() then for x := () to () do break] of while x() do x))
class x {var x := 5 var x := 5} 
int {x = x()} 
-x()
for x := x[nil][if () then break].x := if new int then x[break].x() to while x.x.x do for x := let var x := 5 in break ; 5 end to int [if 5 then 5] of x.x((), "totor") do int [int {x = "totor", x = break} ] of x.x((), ()) do x["totor"].x.x.x()
int {x = x.x[x.x()][x.x].x(x[()].x, int {x = x[break].x(-(), (5)), x = let var x := 5 in 5 ; 5 end} ), x = new int} 
class x {var x := 5 var x := 5}  function x(x : int) : int = (5) class x extends int {} 
-if -let var x := 5 in end then while x.x.x(if 5 then nil else "totor", let  in 5 end) do int {x = x}  else if if new int then x(5, ()) else x.x() then x[nil].x()
new int
x[nil][int {} ].x.x
function x(x : int) : int = int {}  class x {var x := 5}  function x() = 5 var x := 5 var x := 5
function x(x : int) : int = int {} 
let class x {var x := 5}  in end
(let var x := 5 in end)
class x {var x := 5} 
if new int then for x := x.x.x to x() do if -while nil do "totor" then int {}  else if for x := break to break do nil then if () then nil else for x := () to nil do nil else x()
x.x[if "totor" then break].x.x.x()
type x = class {var x := 5} class x {var x := 5} 
var x : int := (5) type x = {}
if if x.x.x.x(int [break|5] of (5), if for x := nil to () do nil then while nil do 5 else for x := "totor" to nil do break) then int {x = if int {}  then x() else new int, x = int {x = x(), x = x.x(break, break)} }  then int {x = if x() then int [5-()] of -(), x = if x(if 5 then (), int {x = (), x = nil} ) then (())}  else int {x = if x(int {x = 5, x = 5} , -break) then int {}  else int {x = if nil then 5 else break, x = new int} , x = int [let  in end] of x()|new int} 
function x(x : int) = while x := 5 do while "totor" do ()
var x : int := if "totor" then nil
x.x[new int].x[-x(break, "totor")/-int [5] of nil] := x.x.x[int ["totor"&"totor"] of int {x = (), x = ()} ] := x.x.x.x(int {x = x.x()} , let var x := 5 in () end)
function x(x : int, x : int) : int = let var x := 5 in end
type x = class extends int{var x := 5}
var x := while 5 do nil
new int
x((int {x = if break then nil} ), x[()][x()][-new int].x(new int, new int))
-int [if new int then let var x := 5 in end] of let var x := 5 in end
class x extends int {var x := 5 var x := 5} 
function x(x : int) = int [if break then nil] of x function x(x : int) = x()
for x := x(x.x[x].x(x(), int {x = int {x = ()} , x = for x := "totor" to () do "totor"} ), x()) to -let import "empty.tih" var x := 5 in end do x.x[while 5 do break][x()] := (x.x() ; 5 ; 5)
if while let import "empty.tih" in end do x[break][x := "totor"].x(int [x()] of if 5 then "totor" else break, (())) then let class x {}  in end else x[5][int [5] of ()][int {} ] := x.x[int {} ].x()
int {} 
let class x {var x := 5}  var x := 5 in end
int {} 
var x : int := int {} 
var x := x.x((), ()) function x(x : int) = int {x = (), x = nil}  function x() : int = break
x((x[break].x() ; for x := "totor" to 5 do 5), (x[()] := if 5 then () else nil ; ()-"totor"))
function x(x : int) : int = new int
-int {x = x((nil ; 5), x())} 
new int
x(x(), let var x := 5 var x := 5 var x := 5 in end)
var x := int {x = 5, x = 5} 
int [int {} ] of let class x {}  var x := 5 in let var x := 5 in "totor" end end
function x(x : int) : int = if while () do "totor" then if () then () else 5 type x = {} var x := 5
(new int)
var x : int := int {x = 5}  class x {var x := 5}  var x := 5
x["totor"][-()].x[x[break][for x := break to () do 5] := x[5] := if "totor" then () else ()].x()
int {x = x(int {x = ("totor" ; 5)} , x())} 
var x : int := while "totor" do nil class x {var x := 5}  type x = int
(for x := for x := nil to break do "totor" to let  in end do x := 5)-if if let  in end then -"totor"+if int [nil] of 5 then x := nil else x := 5 then x.x.x else (let  in end)
function x(x : int, x : int) = while let  in 5 end do if () then 5 else break class x {var x := 5} 
x(int [while int {}  do if int {}  then let  in 5 end else if "totor" then 5 else "totor"] of x[()].x.x(), int {x = for x := x() to int {}  do x["totor"]} )
x[nil].x[int {x = int ["totor"] of "totor"} ].x.x()
let function x(x : int) : int = x.x() var x := 5 import "empty.tih" var x := 5 in (new int) ; x(x((), "totor"), x.x()) end
class x extends int {var x := 5 var x := 5} 
(if x.x.x(let  in end, (5)) then x.x else (5 ; 5))
class x {var x := 5} 
type x = class extends int{var x := 5}
class x {var x := 5} 
x.x.x.x.x.x()
if for x := -for x := new int to (5) do int {x = "totor"}  to while for x := int {}  to x(nil, nil) do while nil do "totor" do int {x = ()+break, x = (5)}  do let var x := 5 in end then let type x = int var x := 5 in end else new int
var x : int := x function x(x : int) : int = int {x = ()} 
let function x(x : int) : int = int {x = break, x = 5}  in end
function x(x : int) : int = if for x := "totor" to nil do () then nil|() type x = array of int
let class x {var x := 5}  in end
class x extends int {var x := 5 var x := 5} 
new int
function x(x : int, x : int) : int = while int ["totor"] of break do x.x(break, ()) function x(x : int) = x := 5
int {x = x(let import "empty.tih" in end, int {x = x[()] := int {} , x = x.x} ), x = if x(while while 5 do nil do 5&break, let var x := 5 in break end) then int [int {x = x.x(break, break)} ] of -"totor"*nil} 
type x = class extends int{var x := 5} class x {var x := 5} 
function x(x : int, x : int) = if int {x = break, x = "totor"}  then if 5 then nil else int {} 
let class x {var x := 5}  in int [int {} ] of x.x.x(if () then "totor", let  in 5 end) ; let var x := 5 in end end
x()
x.x.x.x[x[()].x := int {} ].x(new int, int {x = new int} )
x()
x.x[int {x = (), x = 5} ][(nil ; 5)][x.x[-5]].x()
var x : int := 5/break class x {var x := 5} 
x.x.x[(5 ; 5)][x()]
x.x.x.x[x[nil].x := while x() do if 5 then 5 else ()].x()
type x = {x : int}
x["totor"].x[if int {}  then x][int [(break ; 5)] of while -5 do nil*()] := let type x = int in x.x.x() end
x()
function x(x : int, x : int) = x[5].x(x.x((), ()), let  in 5 end)
function x(x : int, x : int) : int = if x.x() then let  in end else x()
x()
x(while x.x.x do int {} /x["totor"] := int {x = "totor", x = "totor"} , let type x = int var x := 5 var x := 5 in end)
x.x[if "totor" then break else break][while int {}  do x.x(nil, "totor")].x.x(x.x[x := break][for x := for x := 5 to nil do nil to int {x = nil}  do int [5] of ()].x(), x())
type x = array of int function x(x : int) = (5)
var x := (5)
-int [x(()&"totor", int {} )] of int [x(nil, "totor")] of while nil do "totor"/x["totor"].x[for x := x.x() to "totor"+"totor" do int [()] of 5]
x.x[if 5 then 5 else ()].x.x := x(int {x = let var x := 5 in end, x = if while 5 do "totor" then int [break] of nil else int {x = 5} } , new int)
int {} 
let class x extends int {var x := 5}  in (if () then 5 ; ()) end
class x {var x := 5}  var x : int := 5
x.x[int [()] of nil][let var x := 5 in end][x.x.x].x()
(new int ; x())
class x extends int {var x := 5 var x := 5}  type x = array of int class x {}  var x := 5 var x := 5
-x(x[nil] := if nil then () else break, new int)/int {} 
class x extends int {var x := 5 var x := 5} 
function x(x : int) = x["totor"].x(let  in end, x := break) class x extends int {var x := 5} 
int [x()] of x(x.x.x(x.x(break, "totor"), new int)*-()|"totor", x(let  in 5 end, int {x = ()} )&new int)
function x(x : int, x : int) = x[()] := if nil then nil else ()
x.x.x[while int {x = "totor"}  do x()].x := -x.x[int {} ] := int [(5)] of if break then () else nil
var x : int := if "totor" then break function x(x : int) : int = while "totor" do ()
if while int {x = x := 5+x(break, 5)}  do let var x := 5 in end then (int {x = break} /break&"totor") else if while x.x := x := 5 do x.x := break|5 then if while x(break, "totor") do int ["totor"] of () then int {x = while () do "totor", x = for x := nil to 5 do 5}  else let var x := 5 in end
let function x(x : int) : int = int [()] of 5 var x := 5 in int [x()] of x()&x.x end
class x extends int {var x := 5} 
var x : int := x.x(nil, 5)
var x := int {x = (), x = nil}  type x = class {}
-while x.x.x(while 5 do break, new int) do ("totor")&x[break][x()].x()
type x = array of int var x : int := 5 function x() : int = break
class x {var x := 5 var x := 5} 
let var x : int := () in let var x := 5 in end ; for x := x.x(nil, nil) to int {x = "totor", x = 5}  do x((), break) end
var x : int := for x := nil to "totor" do break class x {var x := 5}  function x() : int = nil var x := 5 var x := 5
type x = class {var x := 5} type x = {}
function x(x : int, x : int) = -let  in end
var x := 5/break
function x(x : int, x : int) = let var x := 5 in "totor" end
class x {var x := 5 var x := 5} 
-x()
x["totor"][if "totor" then () else "totor"][int {x = -"totor", x = new int} ][x[()][let  in 5 end]].x(int {x = ---()} , while while x(nil|(), if nil then break) do new int do x.x.x)
type x = class {var x := 5} class x extends int {var x := 5} 
class x extends int {var x := 5} 
function x(x : int, x : int) : int = if -5 then int {}  else int {} 
if x(let var x := 5 in "totor" end*x.x.x(), int {x = x["totor"].x()} ) then let class x extends int {}  in end
x.x.x[if () then break else ()/while 5 do break].x.x(x[()].x[if for x := nil to nil do break then int [nil] of break] := let import "empty.tih" var x := 5 in x.x() ; "totor" ; 5 end, for x := let import "empty.tih" var x := 5 in new int end to int [x.x.x(new int, x)] of new int do int [-let  in 5 end] of x.x.x())
new int
if int {}  then x.x.x[int {x = x.x(5, ())} ].x(if int {x = x.x(), x = int {x = nil} }  then -x := 5, let import "empty.tih" in end)
int [x[()].x.x.x(int [x.x.x()] of int {} , int {x = x[()], x = x[nil]} )] of int [int [int {} ] of int {x = nil} &x] of (5)-int [-()] of (5)
function x(x : int, x : int) = let var x := 5 in break end type x = class {} type x = int
class x extends int {var x := 5} 
type x = array of int
int {x = x[break][new int].x.x(x(), let import "empty.tih" in x ; break ; 5 end), x = (let var x := 5 in () end ; x("totor", break))} 
x.x[if nil then break][x.x.x()].x
for x := x[nil].x.x() to x() do x[5][int {x = ()} ].x(if x then let  in 5 end else let  in 5 end, let var x := 5 in end)&int {x = x((nil ; 5), (5 ; 5))} 
let function x(x : int) : int = let  in end in end
function x(x : int, x : int) = if x() then x.x(nil, "totor") else x := nil var x := () function x() = ()
let function x() = "totor" in x[nil].x() end&int {x = x()} 
(new int ; x.x("totor", nil))&if if new int then if int {x = (), x = 5}  then while 5 do break then x(int {x = x.x()} , new int) else int {} 
function x(x : int) : int = int {} 
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  class x {} 
x.x.x.x.x.x()
class x extends int {var x := 5 var x := 5} 
if x[()].x.x.x(if -x then if while () do nil then nil/5 else int {x = "totor"} , x[5].x) then new int else (if for x := break to nil do "totor" then (5))
x.x[for x := 5 to 5 do "totor"][x[()].x(x := (), for x := () to break do "totor")][x(if new int then let  in end else -"totor", x.x.x())].x()
function x(x : int) : int = int {x = if "totor" then ()}  type x = {}
x.x.x.x[int {x = let var x := 5 in () ; 5 end, x = int {x = (5), x = for x := 5 to () do 5} } ].x()
let function x() : int = () var x := 5 in x["totor"] end/if new int then int [x()] of x/new int else x["totor"] := while break do ()+for x := int {x = (), x = "totor"}  to let  in 5 end do new int
class x {var x := 5} 
var x := int {}  var x : int := nil
x(if let import "empty.tih" var x := 5 in end then int {x = (())}  else int {} , int [int {x = for x := x() to x() do int {} } ] of while x[()] do int [let  in 5 end] of x := break)
new int
let class x {var x := 5}  var x := 5 in let var x := 5 in int [nil] of nil end ; int {}  end
x[()][x.x("totor", 5)].x.x.x()
let function x(x : int) = int {x = (), x = nil}  class x {}  in end
int {x = int {} } 
-let function x() = nil in end
type x = class extends int{var x := 5}
class x {var x := 5} 
function x(x : int) = x.x.x() function x(x : int) : int = 5-5 function x() : int = 5 import "empty.tih"
int {x = let function x() : int = () in end} 
class x {var x := 5 var x := 5}  class x extends int {var x := 5}  function x() : int = "totor" var x := 5 var x := 5
x()+int {x = let var x := 5 in end} 
var x := x.x() function x(x : int) = int {} 
type x = class extends int{var x := 5}
class x extends int {var x := 5} 
class x extends int {var x := 5}  var x : int := nil class x {}  var x := 5
function x(x : int, x : int) : int = int {x = x()} 
class x {var x := 5}  var x := break
if if int {}  then (new int ; ()) then int {}  else x(if int [5] of 5 then x := break, x.x.x())-int {} 
if x((x := "totor"), new int) then x["totor"].x[-if "totor" then 5 else break].x()
function x(x : int) = (5 ; 5)
var x := int {x = nil}  class x {var x := 5} 
x()
function x(x : int, x : int) : int = for x := x((), break) to if break then break else 5 do x()
x[()][5/"totor"].x.x.x()
function x(x : int, x : int) : int = int {x = int {x = break, x = 5} } 
type x = int function x(x : int) = x.x()
class x {var x := 5}  type x = class extends int{}
x[()].x.x.x
function x(x : int, x : int) = int [int [break] of ()] of int {x = 5}  class x extends int {var x := 5} 
var x : int := if 5 then 5
type x = class extends int{var x := 5} function x(x : int) = int ["totor"] of nil function x() = break import "empty.tih"
function x(x : int, x : int) : int = let var x := 5 in 5 end
class x {var x := 5}  class x extends int {var x := 5} 
class x {var x := 5 var x := 5} 
if let function x() : int = 5 var x := 5 var x := 5 in let var x := 5 in nil ; 5 end end then x(x.x.x.x((5 ; 5), while x("totor", ()) do int [()] of break), let var x := 5 var x := 5 in (5) end) else x()+for x := x() to x.x do int {x = int [5] of break} 
class x extends int {var x := 5 var x := 5} 
function x(x : int) = int {}  function x(x : int) : int = x := break
int {x = int [x.x[while () do 5].x(x.x.x(), (5)/x())] of x(x.x := x.x("totor", ()), x[5] := x)} 
class x {var x := 5} 
x.x.x[new int][for x := while int {}  do break|nil to 5+"totor"-int ["totor"] of nil do int {} ].x(if x(x[()].x(int {x = 5} , -()), for x := int {x = (), x = break}  to int {x = break}  do "totor"+"totor") then int {} , new int)
(if if () then nil else break then x.x(nil, 5) else int {} -x.x.x())
function x(x : int) = (5 ; 5)
function x(x : int) : int = int {}  class x extends int {var x := 5}  function x() : int = break import "empty.tih" var x := 5
-let function x() : int = break var x := 5 in end
-let class x extends int {}  var x := 5 var x := 5 in end
x[()][new int][int [int [()] of break] of x][x(int {} , if x then let  in 5 end)].x(x.x.x[x(for x := break to () do (), x(nil, break))], if int {x = let var x := 5 in "totor" ; 5 end}  then x[break].x else int {} )
x(let import "empty.tih" in end/for x := int [if nil then break] of -() to x[break] := int {x = nil}  do let var x := 5 in () end, for x := x[nil].x to if x.x := x(5, break) then (()) do if int [(5)] of new int then x["totor"] := int {}  else let var x := 5 in 5 end)
type x = array of int
var x := x := ()
for x := x[5][x][new int] := -if int {x = nil, x = ()}  then let  in 5 end else x.x() to (x()) do x()
function x(x : int) : int = (5) function x(x : int) : int = while () do ()
function x(x : int) : int = if nil+5 then x.x(5, 5)
int {x = let var x := 5 in int {x = int {x = 5, x = ()} , x = x}  ; x() end} 
x(-new int, if ("totor" ; 5)/x.x(break, "totor")|int {x = nil}  then x((5 ; 5), new int) else int {x = while int {x = (), x = "totor"}  do if () then nil} )
class x extends int {var x := 5 var x := 5} 
int {x = let class x extends int {}  in let var x := 5 in end end, x = x["totor"].x[while int [break] of nil do x("totor", ())] := int {x = int {} , x = (nil)} } 
for x := new int to if while let  in end do x.x(nil, break)*nil+nil|x.x("totor", "totor") then if int {}  then x(if () then 5 else "totor", x) else x() else int {x = x.x.x(x(), x := break), x = new int}  do int [x["totor"].x] of x[break].x.x(int {} , if (5) then x.x())
function x(x : int, x : int) : int = while x.x(nil, nil) do x(nil, ())
class x extends int {var x := 5 var x := 5} 
var x : int := new int
class x extends int {var x := 5 var x := 5}  type x = {}
int {x = if x(int {x = -(), x = x.x(nil, ())} , int {x = int {x = nil} , x = while 5 do ()} ) then int {}  else x.x.x.x()} 
if let var x := 5 in int {x = for x := 5 to 5 do ()}  end then int {x = -x[()] := while nil do "totor", x = for x := new int to int {}  do -if nil then nil} 
new int
if int [new int] of int [x[nil]] of int {x = let  in 5 end}  then new int else while (x.x((), nil)) do if int {}  then x()
int [x()] of (let  in 5 end ; () ; 5)&x(if ()/5 then x() else new int, new int)
type x = {x : int} function x(x : int) : int = x()
x()
type x = class extends int{var x := 5} class x {var x := 5} 
x(while if x.x := x.x() then x.x := if () then () else () else let var x := 5 in break ; 5 end do new int, if for x := int {x = x.x("totor", "totor"), x = if 5 then () else ()}  to int [-()] of if nil then "totor" do int {x = x.x()}  then let var x := 5 var x := 5 in x() ; nil end else x(-while 5 do (), new int))
x(for x := new int+x[break].x() to x[5].x()-("totor") do int {x = let var x := 5 in () ; 5 end, x = int {x = x()} } , ((nil ; 5)))
type x = class {var x := 5}
var x := x := "totor"
class x {var x := 5 var x := 5} 
x()
new int
var x := -5 var x : int := break
function x(x : int, x : int) = if while "totor" do nil then while 5 do break
var x : int := let  in 5 end
var x : int := while break do () class x extends int {var x := 5}  function x() : int = "totor" var x := 5 var x := 5
x.x.x[int {x = if nil then 5 else nil, x = x()} ].x := x[break].x[for x := x.x() to new int do int {} ].x(int {x = let var x := 5 in end} , let var x := 5 in end/let var x := 5 in nil ; 5 end)
class x extends int {var x := 5}  class x extends int {var x := 5} 
class x extends int {var x := 5}  type x = {} class x extends int {}  var x := 5 var x := 5
class x extends int {var x := 5} 
int {} 
class x {var x := 5 var x := 5}  function x(x : int) : int = break-nil type x = int
class x extends int {var x := 5}  type x = class extends int{}
function x(x : int) : int = x.x := int {}  function x(x : int) = x := break type x = int var x := 5 var x := 5
function x(x : int) = if if nil then break else break then if break then nil else nil var x : int := 5
x.x[for x := "totor" to break do break][int {} ].x.x()
int {x = for x := let import "empty.tih" var x := 5 in end to x() do x.x[int {} ], x = -let var x := 5 in end} 
class x extends int {var x := 5 var x := 5} 
type x = {x : int} class x {var x := 5}  class x {}  import "empty.tih"
class x extends int {var x := 5} 
x()
int [for x := int {}  to x[5].x.x(x(), x[break].x()) do x.x[x()] := x(if () then break, (5))] of x(x.x[int {x = 5} ].x(), for x := if if break then () then (5) to int {x = if 5 then (), x = x}  do int [x()] of x(5, break))
-x(x(), int {} )
while let function x() : int = nil import "empty.tih" var x := 5 in end do if (-break ; ()) then (let  in 5 end ; 5) else -let var x := 5 in end
x(x.x[x.x()]&x[()][if nil then break].x(if x.x() then if "totor" then break else "totor" else x.x(), if let  in 5 end then int {x = "totor"} ), x.x.x[x["totor"].x(while break do (), x.x(5, "totor"))] := if int {}  then while int [break] of nil do let  in 5 end)
class x {var x := 5 var x := 5} 
int [int [int [x[break].x(x.x(), x)] of x(int [nil] of 5, (5))] of if if x(5, ()) then for x := () to "totor" do break then x[5].x()] of int [x["totor"].x.x()] of int {} 
class x extends int {var x := 5} 
(if if int [5] of break then int {}  then x.x := (5))
if let class x {}  import "empty.tih" var x := 5 in new int*if break then 5 ; x := break ; "totor" ; 5 end then x["totor"].x[x.x.x(int {} , new int)].x() else new int|x()
x[break].x[int {x = int {x = 5, x = ()} , x = for x := 5 to nil do "totor"} ][x.x[int {} ].x()]
class x extends int {var x := 5} 
int {} 
x[nil][for x := "totor" to () do "totor"].x[if -x() then if int {x = "totor"}  then x(break, "totor") else int [nil] of "totor" else int [let  in end] of ()+()] := while x() do new int
x["totor"].x.x[-let var x := 5 in end]
function x(x : int) = if -"totor" then int {x = nil}  else x
int {} 
int {} 
let var x : int := "totor" function x() = 5 var x := 5 var x := 5 in end
-for x := int {x = x.x := let  in end, x = let var x := 5 in "totor" ; 5 end}  to x[nil].x := if x then (5) else nil*break do x[()].x.x()
x(int {x = let var x := 5 in -5 end} , if while x.x.x(x(nil, 5), int {x = "totor", x = ()} ) do x.x := x.x() then if int {x = new int, x = ()/()}  then x() else x(x((), "totor"), (5)) else new int)
if int {x = let var x := 5 var x := 5 in end}  then if x.x.x.x(if nil then () else "totor"+if "totor" then 5, x[break].x()) then let import "empty.tih" var x := 5 in end else int [x.x.x()] of int {x = x()} 
class x {var x := 5} 
let function x(x : int) = let  in end type x = int var x := 5 var x := 5 in if x() then let var x := 5 in end else if int {x = break}  then int {x = nil, x = ()}  end
class x {var x := 5 var x := 5}  function x(x : int) : int = nil&5
new int
int {x = x.x.x[int {x = x} ] := int {} , x = -while x[()] := x.x(5, break) do x(if nil then (), 5-5)} 
let class x extends int {var x := 5}  in (break ; 5)&if nil|"totor" then if "totor" then "totor" else x ; x[nil] end
class x extends int {var x := 5 var x := 5}  class x extends int {var x := 5}  type x = int import "empty.tih"
int {} 
let class x extends int {var x := 5}  in end
if while new int do x() then if x(x(x := (), let  in 5 end), (break)) then (if () then "totor" else ()) else x(x(for x := break to () do nil, while "totor" do nil), x())
x.x[x].x-x.x.x.x
var x := while 5 do 5
class x extends int {var x := 5} 
class x extends int {var x := 5}  var x : int := 5
(int {} )
function x(x : int) : int = if x := nil then let  in end else x() type x = {} var x := 5 var x := 5 var x := 5
type x = class extends int{var x := 5}
class x extends int {var x := 5 var x := 5} 
int {x = int [x.x.x] of new int} 
x(for x := new int to let var x := 5 var x := 5 in if 5 then nil else 5 end do int [(5 ; 5)] of x[()] := x((), "totor"), x()-new int)
function x(x : int, x : int) = x.x
x["totor"].x[x.x][x.x[int {x = nil, x = break} ].x(x.x((), 5)&int {x = "totor"} , x.x.x())]
var x := x((), ())
var x := int {} 
class x extends int {var x := 5}  class x extends int {var x := 5}  type x = int
class x extends int {var x := 5} 
x[()][-"totor"].x := (x())*int [x.x[x.x()].x(let var x := 5 in break ; 5 end, x((5), if "totor" then 5 else 5))] of int [x()] of x.x := -5
x["totor"].x[(nil)][int {} ]
int [let class x extends int {}  in end] of -if x.x.x(for x := 5 to break do nil, x(5, ())) then int {x = int {x = break, x = "totor"} , x = int {} } 
class x extends int {var x := 5}  var x := nil function x() = "totor" var x := 5 var x := 5
new int
function x(x : int) : int = ("totor")
function x(x : int, x : int) : int = for x := x to x.x() do "totor"|break class x extends int {var x := 5}  function x() : int = () var x := 5 var x := 5
function x(x : int, x : int) = let var x := 5 in end
class x {var x := 5}  class x {var x := 5}  class x extends int {}  import "empty.tih"
int {x = while let var x := 5 var x := 5 in (5) ; break ; 5 end do x(int [let  in end] of if 5 then "totor", -int {} )} 
(-let var x := 5 in end)
var x : int := x.x(5, 5) type x = array of int
function x(x : int, x : int) = x[5].x() function x(x : int) = new int class x extends int {}  var x := 5
let class x {var x := 5}  var x := 5 var x := 5 var x := 5 in (-"totor" ; "totor" ; 5) ; x[nil].x() end
function x(x : int) : int = if x := () then -break else if () then 5 else "totor" class x {var x := 5}  class x extends int {}  var x := 5 var x := 5
if let class x {}  var x := 5 var x := 5 in end then -let var x := 5 in x.x(5, 5) ; nil end else let class x {}  in end
var x := x.x()
class x {var x := 5 var x := 5}  var x := ()
class x extends int {var x := 5}  class x {var x := 5} 
class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = int {x = "totor", x = nil} 
if if x["totor"][-"totor"] then if x["totor"] then x(x.x(nil, ()), -()) then int {x = let var x := 5 var x := 5 in x() ; "totor" ; 5 end, x = int {x = -for x := "totor" to () do ()} }  else while new int do (int {x = (), x = nil} )
class x extends int {var x := 5 var x := 5}  function x(x : int) = x
type x = array of int
type x = class {var x := 5} function x(x : int) = (5) function x() = () import "empty.tih"
function x(x : int, x : int) : int = x(int [()] of (), x := "totor")
function x(x : int, x : int) : int = int {x = if "totor" then nil}  type x = class {} function x() = "totor"
type x = array of int var x := 5 var x := 5
x["totor"].x.x.x(x[break][x()] := x[break].x(), x())+(if x() then x(break, 5) ; x.x())
type x = int function x(x : int) : int = if () then nil
x[nil].x.x[x.x[int [nil] of 5] := ("totor")] := int {x = -x(new int, x)} 
if int {x = (x() ; 5), x = (for x := "totor" to "totor" do () ; () ; 5)}  then (int {}  ; int {x = "totor"} )
type x = array of int function x(x : int) : int = int {x = "totor", x = 5} 
class x extends int {var x := 5}  var x := () class x {} 
let var x := nil in end
var x := x := ()
x[5].x.x.x.x(int {} , int {x = int {} , x = x[5][x.x(nil, break)] := let  in end*while nil do nil} )
var x := int {x = ()} 
function x(x : int, x : int) = new int function x(x : int) : int = for x := "totor" to () do break
function x(x : int) : int = let var x := 5 in end class x {var x := 5}  function x() = ()
function x(x : int, x : int) = x[5].x() function x(x : int) = int {} 
int {x = int [int {x = int {} , x = x()} ] of let var x := 5 var x := 5 in end, x = (x(x(break, 5), int {x = "totor"} ))} 
let function x(x : int) = (5) in end
class x extends int {var x := 5 var x := 5}  type x = class extends int{} var x := 5 var x := 5 var x := 5
function x(x : int) = int {}  class x {var x := 5} 
x["totor"].x.x[-("totor")]
class x {var x := 5}  var x : int := "totor"
type x = int function x(x : int) = x.x(5, nil) type x = int import "empty.tih" var x := 5
class x extends int {var x := 5} 
x[5][x].x.x
while x[break][-nil][if if break then () then if () then 5 else x()] do while x.x.x := int {x = x("totor", ())}  do int {x = if for x := 5 to "totor" do break then x, x = x[nil].x()} 
class x {var x := 5} 
x[break][x][if x((), break) then 5&"totor" else int [()] of 5][new int].x((-x.x(nil, break) ; 5*break), new int)
let function x(x : int) : int = int [()] of nil in end
function x(x : int, x : int) : int = -x := 5
let type x = {} in end
class x {var x := 5 var x := 5} 
function x(x : int) : int = x[5] var x := 5
x(x.x.x[int {x = "totor", x = "totor"} +x := 5] := for x := if let  in end then -break else x.x() to x.x.x() do int {x = for x := 5 to break do ()} , int {} )
x()
type x = class {var x := 5}
class x extends int {var x := 5 var x := 5} 
class x {var x := 5}  var x := () var x := 5 import "empty.tih" var x := 5
var x : int := if break then "totor" type x = class extends int{} var x := 5 import "empty.tih"
let type x = class {} in if int {x = int {x = nil} , x = x("totor", nil)}  then x.x else x() ; x() ; if "totor" then "totor" else nil ; nil ; 5 end
function x(x : int) : int = x["totor"].x() function x(x : int) : int = int {x = nil, x = break} 
function x(x : int) = x[5].x(int {x = break} , if break then ()) class x {var x := 5}  function x() = break
class x extends int {var x := 5 var x := 5} 
function x(x : int) = x()
function x(x : int) = int {}  function x(x : int) : int = let  in 5 end
-let function x() : int = () var x := 5 in end
function x(x : int) = while 5 do ()&int [()] of () function x(x : int) = x := break type x = int
function x(x : int) : int = new int var x := "totor" type x = int import "empty.tih" var x := 5
var x := x()
x(int {x = int {x = x.x := if "totor" then 5} } , x(x(), new int))
type x = array of int function x(x : int) = 5&5 var x := 5
-if while new int do if int {x = (), x = ()}  then x("totor", 5) else if () then 5 else "totor" then if (()) then x[break] else if new int then x.x.x(x(break, 5), (5))
function x(x : int, x : int) : int = int {x = int {x = break} , x = x.x()}  class x {var x := 5} 
let function x(x : int) = x(break, "totor") function x() = () in int [int {x = if nil then nil, x = int {} } ] of x["totor"] := x.x(5, break) end
if if x.x[let  in 5 end].x(x[break].x(), new int) then -for x := for x := 5 to 5 do () to x.x() do break/5 then int [int [x.x.x()] of let var x := 5 in end] of x.x[x.x(nil, ())]
let var x := break in end
if x.x.x.x.x(--x.x(), new int) then -int {}  else x.x.x[if x() then int {} ] := int [int {} ] of int {x = int [()] of break} 
let class x extends int {var x := 5}  in new int end
(x.x)*int {} 
int [x.x.x[("totor" ; 5)].x()] of (x(x(5, ()), let  in 5 end) ; for x := 5 to 5 do "totor")
function x(x : int, x : int) = let var x := 5 in "totor" end
type x = int function x(x : int) = x
x()
function x(x : int, x : int) = x["totor"].x(new int, for x := 5 to nil do 5) class x extends int {var x := 5}  function x() : int = ()
function x(x : int, x : int) : int = while let  in end do x.x() function x(x : int) : int = (5) var x := 5 import "empty.tih"
function x(x : int) : int = -int {} 
function x(x : int, x : int) = if if 5 then break else break then new int
while if x() then int {}  else x.x[new int] do x.x.x.x.x()
while (-for x := 5 to break do () ; new int) do int {x = (x.x() ; ()), x = let var x := 5 var x := 5 in if nil then nil end} 
int {x = let var x := 5 in end, x = if int {}  then if while int {x = "totor", x = break}  do while "totor" do break then x.x else x(x, -break) else -int {} } 
class x extends int {var x := 5 var x := 5}  var x := break function x() : int = nil var x := 5 var x := 5
function x(x : int, x : int) = (5)
x["totor"][int [()] of "totor"][-x := break][let import "empty.tih" var x := 5 in x.x("totor", "totor") end]
x["totor"].x.x[int [int {} ] of if x.x() then x.x("totor", break) else int {} ].x(int {x = x.x.x} , let class x {}  import "empty.tih" in end)
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5}  class x {var x := 5}  class x {} 
let function x(x : int) : int = while 5 do () in x["totor"].x := -(5) end
-for x := if x.x.x(-(), let  in end) then x(x(), int {} ) to int {}  do new int
for x := for x := int [if for x := break to 5 do nil then x] of x.x to x[break].x do x() to int {}  do int [let var x := 5 var x := 5 in end] of new int
while x() do int {} 
function x(x : int, x : int) = for x := x(nil, "totor") to int {x = 5}  do if nil then break function x(x : int) : int = x
function x(x : int) = let var x := 5 in end
function x(x : int, x : int) : int = int {x = int {x = ()} }  function x(x : int) = if 5 then () function x() : int = () var x := 5 var x := 5
var x : int := let  in 5 end type x = array of int function x() = "totor" import "empty.tih"
class x extends int {var x := 5} 
function x(x : int) : int = ("totor" ; 5) class x extends int {var x := 5} 
function x(x : int) : int = int {x = x := "totor"}  type x = array of int
function x(x : int, x : int) : int = x.x function x(x : int) = let  in 5 end
x[nil][x := ()].x[x()|x*x := "totor"].x()
if x["totor"].x[x()].x() then let type x = int import "empty.tih" in int {x = x(), x = x.x((), break)}  ; let  in 5 end end
class x {var x := 5} 
class x extends int {var x := 5 var x := 5} 
new int-if x() then let var x := 5 var x := 5 in x.x() ; nil end else int {} 
x.x[x := "totor"][let var x := 5 in end].x.x(-x(), let class x extends int {}  in end)
x[break].x[if x then while nil do ()].x
((let  in 5 end ; "totor" ; 5) ; ()/5/x(break, ()))
int {} 
function x(x : int) : int = let var x := 5 in () end var x := break type x = int
function x(x : int, x : int) : int = int {x = int [nil] of nil}  function x(x : int) = new int type x = int
var x : int := x(5, "totor") function x(x : int) = let  in 5 end class x {} 
function x(x : int, x : int) = for x := int {x = break}  to new int do x var x : int := 5 class x extends int {}  import "empty.tih" var x := 5
int [int {} ] of int {x = int [while if () then break do x := 5] of int {} , x = if int {x = for x := () to 5 do 5}  then new int} 
function x(x : int, x : int) = let var x := 5 in break ; 5 end
class x {var x := 5 var x := 5} 
type x = array of int
new int
if let class x {}  in if let  in end then int {x = 5}  else new int end then x["totor"]["totor"*()].x.x()
class x {var x := 5}  var x := nil type x = int
int {} 
-x.x[int [5] of nil][int {x = int {x = break} , x = let  in 5 end} ].x(int {x = x.x.x(5+nil, int [break] of break), x = x()} , x.x[int {x = break, x = ()} ])
let class x {var x := 5}  function x() = break in end
x[break].x.x[new int].x(let class x extends int {}  in for x := x to x.x(5, ()) do x.x() end, x.x.x[while int [break] of "totor" do if 5 then 5].x(int {x = for x := new int to for x := 5 to "totor" do break do let  in end, x = x.x.x()} , int {x = x[nil].x()} ))
function x(x : int) = x((5), x)
x.x[-nil][if -break then int [()] of break else x][if int [if () then 5 else ()] of let  in 5 end then for x := (5) to int [nil] of break do (5) else x.x.x()] := new int
let class x extends int {var x := 5}  function x() = () in x["totor"].x.x(x[()] := (5), x.x) ; x.x end
function x(x : int, x : int) = x[()]
int [int {x = let var x := 5 var x := 5 in end} ] of if int {}  then (if nil then "totor" ; () ; 5)
function x(x : int) : int = x() class x extends int {var x := 5} 
x()
function x(x : int, x : int) : int = for x := break+5 to break-"totor" do while break do break class x {var x := 5}  class x extends int {}  var x := 5 var x := 5
function x(x : int) : int = x.x := x
x.x[x((), 5)].x.x()-x()
type x = class extends int{var x := 5} type x = class extends int{} type x = int
type x = class {var x := 5} class x extends int {var x := 5} 
if if int [x.x.x()] of for x := new int to x do int [5] of break then int [-int {x = nil, x = "totor"} ] of let var x := 5 in "totor" ; 5 end else if for x := nil to break do () then let  in end/x() then x(for x := int ["totor"] of () to while 5 do break do while 5 do nil-x[()].x(), x[()].x)
var x := x.x(5, ()) class x extends int {var x := 5}  function x() : int = nil
type x = array of int
var x : int := x
x.x.x[let var x := 5 in break end].x
class x {var x := 5 var x := 5}  function x(x : int) = x.x("totor", break) function x() : int = 5 import "empty.tih"
for x := x[nil].x.x := if int [x.x()] of x.x(5, ()) then x["totor"].x(x(5, nil), x.x()) else new int to int {x = -int [(5)] of x("totor", 5), x = x[break].x.x(-int [5] of nil, (() ; 5))}  do new int
type x = array of int function x(x : int) = x
function x(x : int, x : int) : int = if if () then nil else 5 then int {x = ()}  else x.x(break, nil) var x := () function x() = ()
int {x = x[()].x.x.x(int {} , int {x = let  in 5 end, x = x("totor", "totor")} &x.x.x())} 
if -let var x := 5 in x := "totor" end then new int
class x extends int {var x := 5 var x := 5}  function x(x : int) = let  in end function x() = break var x := 5 var x := 5
int {} 
if x(let var x := 5 in end, x()) then if int [int {x = if () then break} ] of int {x = int {x = (), x = ()} , x = int {x = (), x = ()} }  then if for x := if "totor" then () to x := 5 do x := "totor" then x() else x["totor"] := (5) else -let var x := 5 in end
let class x extends int {var x := 5}  in for x := if int {x = nil, x = break}  then x.x("totor", 5) to int {}  do x[nil].x(if () then break else "totor", x.x()) end
class x extends int {var x := 5}  function x(x : int) : int = x()
x["totor"][(5)][let  in 5 end|x.x("totor", "totor")][x.x[int {x = 5, x = 5} ] := new int].x(x(), x.x[x()][x["totor"].x(int {x = break} , for x := 5 to 5 do 5)].x(-x[()].x(let  in 5 end, for x := nil to nil do "totor"), int {x = int {x = 5*"totor", x = x.x()} , x = int {x = x(), x = x()} } ))
function x(x : int, x : int) = for x := 5*break to int {x = "totor"}  do x.x()
if x.x.x[while x.x() do while () do nil] := int {}  then let class x extends int {}  import "empty.tih" var x := 5 in end
new int
x()
x[()].x[new int][x.x.x.x()].x(if new int then while -for x := () to 5 do () do let var x := 5 in 5 ; 5 end else int {x = x(), x = -int {x = "totor"} } , while x[()].x.x() do if int {}  then while let  in 5 end do int {}  else int [5&break] of (5))
function x(x : int) = new int class x extends int {var x := 5}  class x {}  var x := 5
function x(x : int, x : int) : int = x.x var x : int := 5
x((x.x.x(int {x = ()} , int {} )), int {x = int [int [while nil do "totor"] of x := "totor"] of let var x := 5 in end} )
x["totor"].x[x[5] := -break].x := int {} 
function x(x : int, x : int) = int {} 
x(x(), x(x.x.x.x(for x := int {}  to x.x(nil, 5) do x(), new int), while if (5) then x.x("totor", "totor") do if -break then int {x = 5, x = "totor"}  else x.x()))
class x {var x := 5}  class x extends int {var x := 5} 
function x(x : int) = if int {}  then x("totor", break) else if nil then break else "totor"
int {} 
int {} 
function x(x : int) : int = x(5, "totor")&x := nil
x()
function x(x : int, x : int) : int = new int
function x(x : int, x : int) = if int {x = 5, x = "totor"}  then new int function x(x : int) : int = -"totor" class x {} 
class x {var x := 5} 
function x(x : int, x : int) : int = int {x = break, x = "totor"} *while () do 5
x.x.x[int {x = x(), x = ()&"totor"} ].x
type x = int
var x : int := x := break
let class x {var x := 5}  function x() = break in let var x := 5 in int {x = nil, x = "totor"}  ; () end ; int [int {} ] of for x := "totor" to () do () end
if x[5].x.x := let import "empty.tih" var x := 5 in new int end then x.x[new int].x := let var x := 5 var x := 5 in x end
function x(x : int) : int = int {x = int [5] of nil} 
if x.x.x.x.x(x.x[x()].x(), x["totor"][for x := () to break do "totor"]) then (let  in 5 end*x := break ; int {x = "totor", x = break} ) else int {x = int {} |x["totor"] := x := 5, x = -x(x(nil, 5), x.x())} 
int [int [x[5][let  in end]] of x.x[-"totor"].x(new int, let var x := 5 in break end)] of -let var x := 5 var x := 5 in new int end
(x[()][int [5] of "totor"].x())
int {x = x(), x = if x(break+break, let  in 5 end) then ("totor" ; 5)} -int {x = int {x = x()-if nil then "totor" else break} } 
if int {}  then x["totor"][x.x("totor", ())][-let  in end]
var x : int := int {x = (), x = break} 
x.x.x[(() ; 5)][-(nil)]
function x(x : int, x : int) = (())
class x {var x := 5} 
int {x = x[()].x[int {} ] := (-5)} 
x[nil].x[int {x = 5} *let  in end][x.x.x := (nil)].x()
function x(x : int) = x.x.x()
x.x.x.x.x := for x := let var x := 5 var x := 5 in x end to for x := int {x = let  in end}  to x[()].x() do if let  in end then x() else x.x(break, break) do for x := let var x := 5 in end to (5)-int {}  do new int
type x = class {var x := 5}
var x : int := -"totor"
x(int {} , int {x = x(new int, int [x.x("totor", "totor")] of x("totor", ())), x = x()/new int} )
function x(x : int, x : int) : int = x.x()/let  in 5 end class x {var x := 5} 
x.x.x[if x then for x := 5 to () do "totor" else if nil then 5][if x(x, x.x(nil, nil)) then while int {}  do x(break, ()) else x(let  in 5 end, x())].x()
x[()][new int].x.x.x(new int, -if int [x] of x.x() then x() else int {x = x()} )
class x extends int {var x := 5 var x := 5} 
class x extends int {var x := 5}  function x(x : int) : int = (5) function x() = ()
function x(x : int) : int = int [if nil then () else "totor"] of int {x = break, x = break}  class x {var x := 5}  var x := 5 var x := 5 var x := 5
class x extends int {var x := 5}  type x = {} class x extends int {} 
class x {var x := 5}  function x(x : int) = new int
function x(x : int, x : int) = let var x := 5 in end function x(x : int) : int = for x := 5 to 5 do nil
while x.x.x.x.x() do let class x {}  in end
type x = class extends int{var x := 5}
type x = {x : int} class x extends int {var x := 5} 
type x = {x : int} function x(x : int) : int = while "totor" do nil
class x {var x := 5}  class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
x[nil][int {} ].x[new int]
int {} -int {x = x.x[nil/"totor"], x = if while x.x(nil, 5) do x then x[5] else x.x} 
x.x[x("totor", nil)][x(let  in 5 end, while break do "totor")].x.x(let function x() : int = "totor" in int {x = int [break] of "totor"}  end, x[5].x[("totor")])
x[nil].x.x.x := new int+x["totor"] := x(break, 5)|let var x := 5 var x := 5 in int {x = break}  end
function x(x : int, x : int) : int = int [-"totor"] of x := () function x(x : int) : int = let  in 5 end
function x(x : int, x : int) : int = let var x := 5 in end
function x(x : int) : int = x.x := for x := () to 5 do "totor" function x(x : int) : int = int {x = (), x = 5}  type x = int var x := 5 var x := 5
class x {var x := 5 var x := 5}  class x {var x := 5} 
if if -x() then int {}  else x[nil].x := for x := x to int {x = "totor", x = nil}  do new int then let class x extends int {}  in end
if -while int {}  do for x := int {x = ()}  to int {x = break}  do -nil then x[nil][for x := () to 5 do break].x.x(-new int, for x := if int [break] of break then x() else x.x() to int {}  do x(x := nil, x))
type x = array of int class x extends int {var x := 5} 
let type x = class extends int{} function x() = "totor" var x := 5 var x := 5 in end
int [for x := int {x = let var x := 5 in end, x = (break ; 5)}  to x.x.x.x(let var x := 5 in end, new int) do if x.x then x.x] of -x()
var x := int {} 
function x(x : int) : int = x.x.x()
var x : int := int {} 
var x := while "totor" do break var x : int := "totor"
function x(x : int, x : int) : int = let var x := 5 in end
type x = class extends int{var x := 5} function x(x : int) : int = x
function x(x : int, x : int) = int [int {} ] of while break do break var x : int := 5
let class x {var x := 5}  in end
new int
type x = array of int type x = array of int
(int {x = if x then x.x(5, "totor") else x(nil, "totor"), x = x(let  in 5 end, new int)}  ; x(x.x(), x.x()) ; if break then break else "totor")
var x := -() class x extends int {var x := 5} 
x[()][x(nil, 5)][x(int {x = (), x = "totor"} , for x := break to () do break)].x
int {x = x.x.x.x.x(int [int {x = x()} ] of (nil ; 5), x.x.x.x(int {x = let  in end} , ("totor"))), x = int [int [if int {x = (), x = 5}  then nil+break] of x.x.x(()-nil, while nil do "totor")] of x.x-int {} } 
-x[5][x((), break)].x := x[nil].x(int [nil] of break, ()/"totor")-int {} 
class x extends int {var x := 5} 
var x : int := x(break, 5)
class x {var x := 5} 
var x : int := int {} 
class x {var x := 5} 
function x(x : int, x : int) = if "totor"-break then new int function x(x : int) : int = let  in 5 end
new int
class x extends int {var x := 5 var x := 5} 
int {x = x()} 
var x := int {x = (), x = 5}  function x(x : int) = x() type x = int
x[5][x("totor", 5)][new int].x
let function x(x : int) = for x := nil to 5 do nil class x {}  in end
while let var x := 5 var x := 5 in end do x()+-int {x = let var x := 5 in "totor" ; 5 end} 
x.x[x.x((), 5)].x.x
var x := let  in 5 end var x := 5
function x(x : int, x : int) : int = int {} 
var x : int := while "totor" do ()
(int [(() ; 5)] of let var x := 5 in end ; -int {x = 5, x = ()}  ; while () do break ; break ; 5)
let type x = {} class x {}  in end
function x(x : int, x : int) = let var x := 5 in end class x {var x := 5}  var x := 5 import "empty.tih" var x := 5
var x : int := let  in end
function x(x : int, x : int) = int {}  function x(x : int) = let  in 5 end
x.x.x[x.x.x(int [break] of nil, int [5] of "totor")][x[5].x].x(if x.x.x()*if x.x() then x := nil else -() then x["totor"][int {} ] := x.x()+while break do break, -while x.x := if nil then "totor" do x())
function x(x : int) : int = int {}  class x extends int {var x := 5}  type x = int
function x(x : int) = -int [break] of 5
let function x(x : int) : int = for x := "totor" to () do break class x {}  var x := 5 var x := 5 in int {x = for x := x.x() to x.x() do let  in 5 end}  end
function x(x : int, x : int) = int {x = -break}  type x = {} class x extends int {}  import "empty.tih" var x := 5
x.x[x.x(nil, "totor")][x.x.x(int {} , int {} )][if let var x := 5 in break ; 5 end then int [if 5 then "totor" else "totor"] of int {x = nil}  else int {x = x.x((), 5)} ]
class x {var x := 5}  class x extends int {var x := 5} 
type x = class {var x := 5} class x extends int {var x := 5}  class x extends int {} 
class x {var x := 5 var x := 5} 
class x {var x := 5 var x := 5} 
type x = {x : int}
var x := x()
function x(x : int, x : int) : int = x()
type x = array of int type x = class {} function x() = nil
int {x = int [for x := x.x := new int to for x := x(5, break) to x.x() do x.x() do new int] of new int, x = new int} 
class x {var x := 5} 
int {} 
var x : int := int {} 
type x = array of int
x[()][int {x = ()} ][x[nil].x(int {x = nil, x = nil} , if nil then "totor")].x
int {x = -x(int {x = nil} , int [break] of 5)&int {} } 
var x : int := int {x = "totor", x = ()}  function x(x : int) : int = 5|()
function x(x : int) : int = x(x, let  in end)
x()
var x := x.x(break, break)
function x(x : int, x : int) : int = x(x("totor", 5), (5))
function x(x : int) : int = while x do int [nil] of break
let type x = array of int in end
type x = {x : int} function x(x : int) = x var x := 5 var x := 5 var x := 5
type x = array of int type x = array of int var x := 5 var x := 5
x["totor"][-break].x := x(x.x := int [5] of break, int [(5)] of while nil do 5)&x(while x["totor"] := let  in end do x.x.x(), x())
new int
int {} 
x[5].x.x.x := x()
int {x = int {} , x = int {x = int {x = for x := let  in 5 end to x.x() do x()} } } 
-x.x[int {x = nil} ][while -() do x(nil, ())].x()
int {} 
function x(x : int, x : int) = while for x := () to break do nil do int {}  type x = array of int class x {} 
class x extends int {var x := 5} 
int {} 
new int
int {} 
class x {var x := 5 var x := 5} 
int [x(int {} , int [int [5-()] of (5)] of for x := if nil then () to let  in 5 end do x.x(5, "totor"))] of x.x[-nil][x((5), int {x = "totor"} )].x()
x.x[int [()] of break].x[x.x.x.x(if while 5 do () then int {x = "totor"} , while if () then break do (5))].x()
function x(x : int, x : int) = x(int {x = (), x = 5} , int {} ) type x = int class x {} 
class x {var x := 5} 
type x = class extends int{var x := 5} function x(x : int) : int = for x := 5 to nil do "totor" class x {}  var x := 5 var x := 5
x[()][-"totor"].x.x
let var x : int := "totor" in int {x = x()}  end
var x := x()
function x(x : int) = int {} 
class x {var x := 5 var x := 5} 
for x := x() to new int do int {x = x.x[()-5] := x.x(break, 5)*x.x(nil, "totor"), x = for x := x.x()|for x := break to break do break to new int do if while "totor" do break then (5)} 
type x = class extends int{var x := 5} class x {var x := 5}  type x = int
(x[()][int {} ])
int {x = int [while for x := x := () to -() do x() do int {x = (5), x = if () then () else ()} ] of let import "empty.tih" var x := 5 in end, x = x(int [x[5].x(int {x = break, x = ()} , let  in 5 end)] of x[break].x(), int {x = x(), x = for x := (5) to for x := nil to () do nil do ()*nil} )} 
class x {var x := 5} 
x[nil].x.x[x[5][int {x = nil, x = ()} ].x(int {} , new int)].x(int {} , x[5][int {x = nil} ].x.x())
x(x.x.x[x()], x(while let  in 5 end-x() do if x.x((), break) then let  in 5 end else x.x("totor", nil), for x := x[break] to x.x do new int))
-let type x = int in end
type x = class extends int{var x := 5}
if if for x := (5 ; 5) to let var x := 5 in break end do x.x then int [x[5] := -break] of x["totor"] := 5-5 then while x() do let var x := 5 in break end+x.x else if for x := int {}  to -()/5 do -x.x(5, 5) then x() else int [int [()+nil] of int {} ] of (break)
(new int ; let var x := 5 in "totor" end)
class x {var x := 5}  function x(x : int) : int = new int
int {x = let class x extends int {}  in end, x = x.x.x[int {x = for x := () to 5 do ()} ].x()} 
x["totor"][x.x((), nil)][if -break then while "totor" do "totor"].x.x(if if int {x = x, x = int {} }  then x() else int {x = while "totor" do (), x = x := "totor"}  then x(x["totor"].x(-(), int [nil] of "totor"), int {x = 5-break, x = if () then 5 else 5} ) else x[break][-()].x(if let  in 5 end then int {}  else ()/"totor", int {} ), x(x(for x := x() to int {x = (), x = ()}  do new int, x()), let var x := 5 in x ; () ; 5 end))
if let function x() = 5 import "empty.tih" var x := 5 in while -break do int {x = nil, x = break}  ; x() end then let class x {}  import "empty.tih" in let  in end|"totor"+"totor" ; for x := () to 5 do () end
int {x = x["totor"].x[if for x := () to () do nil then x()], x = if x.x := for x := nil to nil do break*(5 ; 5) then if int {}  then (() ; 5)} 
type x = {x : int} function x(x : int) = -()
var x := int {}  function x(x : int) : int = new int var x := 5
x[break][x()].x.x
var x : int := (5) class x {var x := 5} 
(x.x := int [()] of "totor" ; (5) ; 5)/int {x = int {x = x[break]} } 
let class x {var x := 5}  in end
x()
int {x = let class x {}  import "empty.tih" in end} 
(x.x.x.x())
x[()].x.x.x.x()
x((int {x = let  in end} ), x())
type x = int function x(x : int) : int = x()
var x := x.x((), ())
int {x = x[break][for x := nil to () do "totor"].x, x = for x := if int {x = nil+()}  then x.x.x(x, new int) else while int {}  do (5) to for x := x[5].x() to if int ["totor"] of break then x do (break) do int {} } 
class x {var x := 5} 
function x(x : int, x : int) : int = int {} 
type x = class extends int{var x := 5} class x extends int {var x := 5}  class x extends int {}  var x := 5
new int-x[break].x[x[()] := int {x = "totor", x = "totor"} ].x((if 5 then nil ; ()), x.x[(5)].x())
function x(x : int) : int = let var x := 5 in end
x(int {x = int {x = -int {x = break} } , x = x.x.x := new int} , if int {}  then x["totor"].x := -int [()] of nil else x[5].x := int {} )
int {x = if int {x = x.x.x(), x = ("totor" ; 5)}  then while x[nil] := int [()] of () do x.x.x() else x(x.x, if let  in 5 end then x() else if () then break), x = if int {x = x[nil].x(), x = x[break].x()}  then x.x.x else let import "empty.tih" var x := 5 in end} 
class x {var x := 5}  function x(x : int) = int {x = ()} 
class x extends int {var x := 5}  class x extends int {var x := 5}  type x = int
function x(x : int, x : int) = if break then () else nil-nil*nil
class x extends int {var x := 5} 
function x(x : int, x : int) = let var x := 5 in "totor" end function x(x : int) : int = x.x("totor", "totor")
let class x {var x := 5}  in end
x(if int {x = for x := "totor" to 5 do nil+int {x = nil} , x = x[nil].x()}  then while int {x = "totor"} /int {}  do x.x.x() else x((break ; 5), x.x()-int {} ), int [if () then break else 5*int {x = break, x = "totor"} -new int] of x.x.x)
int {x = new int, x = while x(new int, x["totor"].x()) do x.x[let  in end].x()} 
x(x.x[x()][let var x := 5 in break end].x(), x())
int {x = (x.x.x(x(), int {x = nil} ) ; if "totor" then nil)} 
function x(x : int, x : int) = int {x = int {} , x = x()}  type x = array of int
int {x = x()} 
class x {var x := 5} 
type x = int class x extends int {var x := 5}  type x = int
int {} 
x["totor"].x.x.x
x(-x.x+if new int then let  in end, for x := x[()].x.x(let var x := 5 in 5 end, if x.x() then x(break, nil) else x) to let import "empty.tih" var x := 5 in end do int {x = x.x.x(), x = -x()} )
function x(x : int, x : int) = let var x := 5 in end
let type x = class {} in (int {x = "totor", x = "totor"} ) ; ("totor") ; new int ; nil ; 5 end
function x(x : int) : int = x(if () then "totor" else break, -break) function x(x : int) = x function x() = nil
int {x = x(x.x.x, x(x(x(break, ()), if "totor" then break else break), x(new int, 5|"totor"))), x = int [while for x := for x := break to 5 do 5 to x := "totor" do if () then break do let var x := 5 in "totor" end] of int {} } 
-int [int {x = x.x.x(x.x(), int ["totor"] of nil)} ] of x()&x.x.x()
class x extends int {var x := 5}  class x {var x := 5} 
type x = class extends int{var x := 5} var x := break class x extends int {}  var x := 5
x(if if x()*while break do 5 then int {x = 5-"totor"}  else int [let  in 5 end] of x.x(5, 5) then new int, x.x.x.x.x())
x()
var x : int := x
class x {var x := 5 var x := 5}  var x : int := 5 function x() = "totor"
class x {var x := 5}  function x(x : int) : int = x := () var x := 5 var x := 5 var x := 5
var x : int := int {x = (), x = nil}  class x extends int {var x := 5}  function x() = 5
x["totor"][if () then ()].x.x
x["totor"].x[x[()] := while () do break].x := int {} 
function x(x : int) : int = if -() then int {} 
if int [x[nil].x] of x() then while x.x[x.x((), break)].x(int {x = if break then "totor" else ()} , new int) do ((5) ; () ; 5)
int [if int {} &int {}  then let import "empty.tih" var x := 5 in end else x()] of while x["totor"].x.x() do int {} 
(x.x.x := while let  in 5 end do for x := () to nil do nil)
function x(x : int) : int = int {}  class x extends int {var x := 5}  type x = int
let var x : int := break class x {}  import "empty.tih" var x := 5 in let import "empty.tih" in end end
class x {var x := 5}  function x(x : int) : int = if nil then break else "totor"
class x extends int {var x := 5 var x := 5} 
var x : int := int {x = (), x = nil}  function x(x : int) = x() function x() = "totor" import "empty.tih"
x(if int [x(int {x = break} , -break)] of if if nil then nil then x.x(break, break) then int [int {x = int {} , x = x.x()} ] of let var x := 5 in () ; 5 end else new int, x["totor"][for x := break to break do ()][int {} ].x())
function x(x : int) = for x := x.x(break, break) to x(break, nil) do int {x = 5} 
int {x = for x := x(int [let  in 5 end] of x(nil, ()), x.x.x(while 5 do (), x)) to x[()].x := if x.x() then int {}  else let  in end do x.x[while break do break] := let  in 5 end|x.x("totor", nil), x = let class x extends int {}  in while x((), ()) do let  in 5 end end} 
x(x(x(), int [while x do x.x(nil, 5)] of new int), let type x = int in end)
class x {var x := 5 var x := 5}  class x extends int {var x := 5} 
function x(x : int, x : int) : int = int [let  in 5 end] of int {} 
class x {var x := 5 var x := 5}  var x : int := ()
for x := x.x[x].x to x.x.x.x do int [x.x.x] of int {x = int {x = break} *let  in end} 
function x(x : int) = if if 5 then nil else break then if 5 then nil else ()
function x(x : int) : int = -()|int {} 
if x[5].x[new int] := x.x.x.x(int [let  in 5 end] of if nil then () else nil, int {x = int {x = 5, x = break} } ) then x(let import "empty.tih" var x := 5 in if 5 then nil else "totor" ; () ; 5 end, while int {x = x.x("totor", nil)}  do int [int {} ] of break-nil) else x[break][x()].x := x[break][while break do 5].x(int {} , for x := x.x("totor", 5) to x := () do -"totor")
int {} 
new int*let type x = int in x() ; let  in end ; break end
function x(x : int) : int = new int type x = {}
class x {var x := 5 var x := 5} 
int [new int] of int [let var x := 5 var x := 5 in int {x = (), x = ()}  ; nil end] of x()
new int
function x(x : int, x : int) : int = let var x := 5 in nil end
int [int {x = x[nil].x, x = x.x.x} ] of x.x.x.x.x()
var x : int := let  in 5 end class x extends int {var x := 5}  function x() : int = ()
let class x {}  in int {x = x.x()}  end&for x := while x() do let var x := 5 in break ; 5 end to for x := int {x = int {} }  to int {}  do x.x.x() do int {x = if new int then int {x = "totor", x = "totor"}  else while nil do "totor"} 
type x = int
var x : int := x((), break)
let type x = int var x := 5 in x() ; x.x()+while () do break ; -"totor" ; 5 ; 5 end
class x extends int {var x := 5 var x := 5} 
int {x = for x := x[nil].x.x(x[5].x(), let var x := 5 in nil ; 5 end) to x(if -"totor" then x() else if "totor" then () else break, int {x = int [break] of 5, x = x(5, nil)} ) do int [(nil)] of while let  in end do x.x(break, "totor")} 
class x {var x := 5} 
x.x.x[int {x = x} ][x()]
function x(x : int) : int = int {}  type x = class {}
class x extends int {var x := 5 var x := 5} 
type x = {x : int}
type x = array of int
x.x.x.x.x
type x = array of int function x(x : int) : int = let  in end
if int {x = if x[nil].x(x(), int {} ) then x[()].x(int {} , 5&5) else x[nil].x()}  then x(for x := x.x.x() to new int do int {x = int {x = nil, x = ()} } , x[nil].x.x(let var x := 5 in end, (5 ; 5)))
while if if -int {x = nil}  then x[break] then let import "empty.tih" in end else while while x.x("totor", "totor") do int {x = 5}  do int {x = int [5] of nil}  do while x() do x[nil].x.x()
for x := if (nil ; 5) then if int {x = (), x = break}  then let  in end else if x then x to int {}  do let import "empty.tih" in -5 ; 5 ; 5 end+let function x() : int = "totor" in end
var x := x.x()
var x := if 5 then break type x = array of int var x := 5
x[5][if 5 then () else ()][let var x := 5 in end].x
class x extends int {var x := 5} 
int {x = int [if let  in end then x|x(x := 5, if () then "totor" else ())] of if int [x.x(break, 5)] of let  in end then x[5].x(while 5 do (), int [nil] of ()), x = for x := for x := x["totor"] to if "totor"+"totor" then let  in end do let var x := 5 in nil end to int {x = int {} }  do if x.x.x() then int {} } 
-let class x extends int {}  var x := 5 var x := 5 in x()&x.x((), ()) ; x.x() ; "totor" end
new int
x.x.x.x.x := let class x extends int {}  import "empty.tih" in x.x := -"totor" end
class x {var x := 5 var x := 5}  function x(x : int) : int = x() type x = int import "empty.tih" var x := 5
class x {var x := 5}  function x(x : int) = x := () function x() : int = 5 var x := 5
new int
class x {var x := 5 var x := 5}  type x = array of int class x {} 
function x(x : int) = -x function x(x : int) = (5) class x extends int {}  var x := 5
int {x = new int} 
function x(x : int, x : int) : int = x.x.x(x, (5)) class x {var x := 5} 
function x(x : int) = while -() do -"totor" function x(x : int) = x(5, nil) class x {} 
function x(x : int) : int = let var x := 5 in () end
function x(x : int, x : int) = while int {}  do if nil then "totor" else () type x = int
type x = array of int
var x := int {x = "totor"} 
x(((5) ; if break then ()), x.x.x.x := while -x do let var x := 5 in end)
type x = array of int
function x(x : int, x : int) : int = if int [()] of nil then if 5 then break function x(x : int) : int = int {x = "totor"} 
class x extends int {var x := 5 var x := 5}  function x(x : int) = int {x = ()} 
new int
int {x = int [((5) ; "totor" ; 5)] of (if 5 then ())} 
x[break].x.x[x.x.x := let var x := 5 in end].x(let class x extends int {}  in end, int {} )
(let import "empty.tih" var x := 5 in int {x = (), x = 5}  ; break ; 5 end ; new int ; x ; break ; 5)
var x := new int
type x = class {var x := 5} function x(x : int) : int = (5) function x() : int = break var x := 5
function x(x : int) : int = int {} 
x.x[new int][x.x.x()][x.x[int {} ]].x(if -x()*(5) then x.x.x else int {} , let function x() : int = () in end)
x()
if x(if if int {}  then if 5 then break then if int [5] of "totor" then let  in 5 end, for x := int {x = int {x = nil, x = ()} , x = let  in end}  to (nil) do int {x = let  in end, x = x.x(5, break)} ) then int {} -int {} 
var x := int {x = break}  var x := 5 function x() = "totor"
int [-int {} ] of x[break].x[for x := int [break] of 5 to x do (5)] := for x := if int [break] of 5 then for x := 5 to break do () to --() do for x := x() to x do x := "totor"
x.x[(5)].x()+x[()].x.x(let var x := 5 in end, ("totor"))|while (new int ; () ; 5) do int {x = x()} 
if x.x[x := 5].x.x(int {x = x[nil], x = for x := int {x = (), x = "totor"}  to let  in end do while break do ()} , int {} ) then x()
x(int {x = int {x = while x() do int {x = "totor"} } } , if x[5].x.x(x(if "totor" then nil, x.x("totor", 5)), if x((), ()) then while break do "totor") then int {}  else x[5]["totor"&"totor"].x())
int [let type x = int var x := 5 var x := 5 in end] of int {} 
while int {}  do x[nil].x[let var x := 5 in end] := x.x[new int]
-int {x = (nil), x = -int {x = "totor"} } *x.x.x[x(if break then (), let  in end)] := for x := int {}  to int [x := "totor"] of new int do x["totor"].x(if "totor" then 5 else "totor", while "totor" do nil)
x.x.x.x[x[nil].x.x()].x(x(), x(x.x[x.x()] := x(while () do (), let  in end), int [x.x.x()] of (5)))
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = new int class x extends int {var x := 5}  function x() : int = "totor"
while let class x {}  var x := 5 in end do int {x = int {x = while int {x = 5, x = break}  do new int} , x = x.x.x.x()} 
class x extends int {var x := 5 var x := 5} 
let type x = {} in end
int {x = x[break][x := ()]} +if if int {}  then let var x := 5 in "totor" ; 5 end then -x.x.x() else if int [x.x()] of if "totor" then "totor" then if x := 5 then int [break] of ()
(int {} )
(x.x.x := for x := x("totor", break) to x do int {x = "totor", x = break}  ; x.x.x() ; -5)
let function x(x : int) : int = int {}  function x() = 5 import "empty.tih" in int {x = -int {x = 5} }  ; if break|break then let  in 5 end ; int {x = (), x = break}  end
int {} |for x := while --nil do int [x := ()] of while break do nil to int {}  do while "totor"-()/int {}  do if x.x(break, break) then int {x = break}  else if () then 5
type x = array of int
var x : int := let  in 5 end function x(x : int) = x
class x extends int {var x := 5}  class x {var x := 5}  class x {}  var x := 5 var x := 5
x(x[()][if "totor" then 5 else 5].x.x(), new int)
while int {}  do let function x() : int = "totor" var x := 5 in end
int {x = if if x() then int {}  else if int {x = 5, x = "totor"}  then int {x = break}  then int {x = if x.x(break, "totor") then int {x = (), x = break}  else nil*break}  else x.x.x} 
int {} 
while if int [x[break].x()] of -break*let  in end then -x.x := x do int [let var x := 5 var x := 5 in end] of new int
int {} 
new int
int [x(int {x = int {} , x = int [int {x = "totor"} ] of for x := 5 to break do ()} , x(int [while 5 do nil] of x := (), int [x] of int {x = nil, x = break} ))] of int {} 
x[5][int {x = 5, x = ()} ].x[int {} ].x(int [x(int {x = for x := break to break do nil, x = nil*"totor"} , x()/let  in end)] of new int, if int {}  then x["totor"].x else int {x = if (5) then -nil} )
type x = {x : int} function x(x : int) = new int function x() = nil
type x = {x : int} function x(x : int) = x.x(5, "totor") var x := 5 var x := 5
x()
int {} 
int [if if x["totor"] := let  in end then x(for x := break to "totor" do 5, let  in 5 end) then x()] of for x := int [int {x = int [break] of (), x = let  in end} ] of int {x = (5), x = (5)}  to x.x.x.x() do (if break then 5)
class x extends int {var x := 5} 
function x(x : int, x : int) : int = x[5] class x extends int {var x := 5}  function x() : int = 5
function x(x : int) : int = int [int {} ] of if "totor" then 5 class x extends int {var x := 5} 
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) = x[nil]
x(while let var x := 5 in end do x(), let function x() = break import "empty.tih" var x := 5 in int [int {x = nil} ] of int {x = break}  ; x.x(5, 5) end)
var x := if break then nil else 5 function x(x : int) = let  in 5 end
var x : int := x.x() type x = {} class x extends int {} 
class x {var x := 5 var x := 5}  type x = {}
var x : int := x.x() type x = int function x() = 5
x()
class x {var x := 5 var x := 5}  function x(x : int) = x()
int {x = new int, x = x[nil].x[-let  in 5 end]} 
x["totor"][(5)].x.x
class x extends int {var x := 5}  class x extends int {var x := 5} 
function x(x : int) : int = x[5] := x
x[nil][while nil do "totor"].x[x(x[break].x(), int [5/5] of x(nil, ()))].x(for x := while -x() do int [x.x("totor", 5)] of new int to if x(5, ())*(5) then (break ; 5) else let var x := 5 in () ; 5 end do let var x := 5 in end, int {x = new int} )
x((for x := "totor" to () do 5&if nil then 5 ; int [5] of break), (int [x := ()] of x.x((), 5)))
class x extends int {var x := 5} 
class x {var x := 5 var x := 5}  type x = int
var x : int := for x := () to () do break function x(x : int) : int = x.x(break, "totor")
int [x[break][let  in end].x := x[5].x := x(for x := () to () do 5, x.x(break, nil))] of x.x.x[while 5*() do for x := nil to nil do break]
var x : int := for x := 5 to "totor" do 5
if x.x[int {x = "totor"} ].x.x(x.x.x.x(new int, x(int ["totor"] of break, x((), 5))), while int {}  do (break ; 5)) then while (-break ; break ; 5) do x.x.x := -let  in end else int {x = -if new int then -"totor" else x := 5} 
int {} 
type x = {x : int}
(for x := new int to for x := break+"totor" to x.x() do int {x = (), x = nil}  do int [int {} ] of x ; new int ; for x := "totor" to "totor" do nil ; "totor")
class x extends int {var x := 5} 
x()
int [-int [new int&if 5 then "totor" else "totor"] of int [x] of let  in end] of x(while x(new int, new int) do x(), int {} )
function x(x : int) = let var x := 5 in () ; 5 end var x : int := () type x = int
int {} 
-int {x = x.x.x := if x(nil, nil) then for x := () to "totor" do nil} 
let class x {var x := 5}  in for x := for x := 5-nil to x() do x := break to let var x := 5 in nil end do for x := int {x = ()}  to int {x = (), x = nil}  do let  in 5 end end
let var x := 5 in end
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = int {x = "totor", x = break} 
x()
var x := x
class x extends int {var x := 5} 
(x[break][x("totor", ())].x(new int, int [int {x = 5, x = "totor"} ] of x := "totor") ; -x)
x[5][x()].x[int {x = x(x := 5, let  in end), x = if x(5, 5) then while nil do break} ].x()
class x extends int {var x := 5 var x := 5} 
var x : int := int {x = ()}  type x = {}
function x(x : int) : int = -x(break, ()) function x(x : int) = x((), nil)
function x(x : int, x : int) : int = -int {x = nil, x = 5}  class x {var x := 5}  type x = int
class x extends int {var x := 5 var x := 5}  var x : int := 5 class x extends int {} 
(new int ; x.x(5, "totor") ; nil ; 5)*x.x.x.x
function x(x : int) = let var x := 5 in end
class x {var x := 5} 
var x := if () then nil type x = array of int class x extends int {}  var x := 5 var x := 5
if new int then x["totor"][int {} ].x.x(int {x = let var x := 5 in end} , (-break ; nil ; 5)) else int {x = -let var x := 5 in end} 
x()
function x(x : int) = x() type x = class {} var x := 5
x()
var x := x()
(x(if (5) then if break then 5 else break, x()))
(let var x := 5 in end ; new int ; ())|int {x = int {} , x = let import "empty.tih" in end} 
int {} 
var x := x := ()
new int
type x = int var x : int := () function x() : int = break var x := 5 var x := 5
for x := x[()].x.x.x() to int {x = int {} }  do x()
int [let type x = int in if x.x("totor", 5) then let  in end else if () then 5 else () end] of int {x = for x := x(x, let  in 5 end) to for x := int ["totor"] of 5 to -break do ()&break do let var x := 5 in 5 end, x = let import "empty.tih" var x := 5 in end} 
function x(x : int) : int = x() function x(x : int) : int = x.x()
type x = class {var x := 5}
x["totor"].x[int {x = new int} ].x.x()
function x(x : int, x : int) : int = if int {x = "totor"}  then new int class x extends int {var x := 5}  var x := 5 import "empty.tih" var x := 5
var x := 5/5 function x(x : int) : int = let  in 5 end
let function x(x : int) = int {x = nil}  in x.x[let  in end].x(x.x := int [break] of 5, if if "totor" then 5 else break then for x := nil to nil do "totor" else for x := break to 5 do "totor") ; -int {x = break, x = break}  ; (5) ; 5 ; 5 end
x[break][5*"totor"].x.x := new int
type x = int
int {} 
int [x[break].x.x] of while (let  in end ; break) do x.x.x
class x {var x := 5} 
-x["totor"].x[x[break].x()]
(int {x = while x() do for x := nil to 5 do break}  ; x[nil] ; x.x() ; () ; 5)
var x := int {x = ()} 
x.x[new int][int {} ][let var x := 5 var x := 5 in end] := -x[()].x
var x := while break do break type x = {} var x := 5 import "empty.tih" var x := 5
class x extends int {var x := 5} 
var x : int := x := break
x(int [-x.x()] of int [let  in 5 end] of int {} , let import "empty.tih" var x := 5 in end)/let var x := 5 in int {x = int {} }  end
let class x {var x := 5}  class x {}  import "empty.tih" var x := 5 in int {x = int {x = while break do "totor"} , x = let var x := 5 in end}  end
class x {var x := 5} 
function x(x : int, x : int) = int [nil|()] of if nil then () else "totor"
function x(x : int) : int = -let  in 5 end type x = int class x {} 
x(new int, x["totor"].x[int [for x := 5 to () do break] of -5])
var x := -"totor" function x(x : int) : int = for x := nil to "totor" do nil
function x(x : int) = x() function x(x : int) = x.x() var x := 5
if x.x[x(break, nil)][-new int].x(x["totor"][if "totor" then 5], if if int {}  then (5) then let var x := 5 in nil end else if (5) then x.x() else x.x()) then for x := if x[()].x(x, -nil) then int {x = x.x(break, 5), x = int ["totor"] of 5}  to if x[5].x(-break, x()) then x[break].x(int {x = nil, x = ()} , while 5 do break) do -x[break]
-for x := (break|nil ; nil ; 5) to let var x := 5 in nil ; 5 end*x() do let import "empty.tih" in end
x.x.x[x.x].x.x()
(new int)
--if x() then let var x := 5 in () ; 5 end else x()
new int
x[5][while break do "totor"][int {x = -5} ][(x.x((), ()) ; "totor")] := new int
int [if x(let  in 5 end, int {} )/int {x = x.x()}  then x[5]|x.x.x(if nil then () else nil, let  in 5 end) else int {x = while x do int {x = (), x = 5} , x = x[5].x(while nil do 5, int {x = nil} )} ] of x["totor"].x[-let  in end].x(x.x.x.x(int {} , int {x = int [5] of 5, x = if () then break} ), x[break].x.x(new int, while -5 do x))
class x extends int {var x := 5 var x := 5}  function x(x : int) = if 5 then "totor" else () class x {} 
int {x = int [int {x = while int {}  do (5)} ] of x(if if 5 then nil else 5 then int {x = (), x = break} , x[break].x(while () do "totor", if break then "totor" else nil)), x = let function x() : int = 5 in int {x = new int, x = new int}  ; int {x = "totor", x = break}  end} 
int {x = int {x = if x(x(), if 5 then "totor" else 5) then if if nil then nil else () then let  in end else x(x, "totor"|()), x = if int [while 5 do 5] of x() then let var x := 5 in 5 ; 5 end} } 
for x := x[nil].x.x := (int {x = break} ) to x()-x[5][x(5, "totor")] do x[break][int {x = break} ][int {x = x.x(5, nil), x = x := "totor"} ].x(let import "empty.tih" var x := 5 in int {}  ; nil end, x["totor"].x.x())
function x(x : int) = int [5&()] of int {x = nil, x = nil} 
-let function x() = 5 var x := 5 var x := 5 in end
function x(x : int, x : int) = while new int do int {}  var x : int := () class x extends int {} 
class x extends int {var x := 5} 
var x : int := x := "totor"
x.x.x.x[int {x = let var x := 5 in end} ]
int {x = x(let var x := 5 in nil ; 5 end|int {} , int {} )} 
type x = {x : int}
var x : int := break+5 class x extends int {var x := 5} 
if (while let  in end do if break then "totor" else "totor" ; nil&"totor") then int {x = if x.x then if x("totor", 5) then if "totor" then "totor", x = if x(nil&nil, x.x()) then x.x else int [x()] of int {} } 
x(x.x[x.x(nil, break)].x, x.x[-break][while let  in 5 end do int {} ] := int [(5)+-nil] of x.x := let  in end)
int [let function x() = nil var x := 5 var x := 5 in end] of let class x {}  in while x := break do new int end
for x := x(x.x[if 5 then "totor"], -new int) to x[nil][if break then "totor" else 5].x := new int do -int [let var x := 5 in () ; 5 end] of new int
function x(x : int, x : int) : int = if 5+"totor" then if () then () else x.x(5, nil)
function x(x : int, x : int) = x[5].x()
let type x = int class x {}  import "empty.tih" in end
var x : int := x.x(5, "totor")
if int [x[nil][x := 5].x(x[nil] := while "totor" do nil, x.x := while break do ())] of int [new int] of let var x := 5 in end then x[()].x.x.x(for x := for x := while 5 do "totor" to new int do while nil do () to x() do if x then x else if "totor" then 5 else 5, -x[5].x(x(), -()))
function x(x : int) = int {}  var x : int := () function x() = ()
x[()][while 5 do nil][let var x := 5 in () end].x.x()
function x(x : int, x : int) : int = x(if 5 then break else nil, x)
class x {var x := 5} 
function x(x : int, x : int) = -int {x = 5, x = 5} 
type x = {x : int}
type x = {x : int} var x := nil type x = int
x.x.x[if int ["totor"] of "totor" then x() else for x := break to nil do "totor"][let var x := 5 var x := 5 in while break do nil ; break end].x()
class x extends int {var x := 5 var x := 5} 
x()
class x {var x := 5}  var x := "totor"
new int
function x(x : int, x : int) = int {x = x.x(5, nil)}  function x(x : int) = x.x("totor", 5) type x = int
let class x {var x := 5}  function x() : int = nil in (-"totor") end
function x(x : int, x : int) : int = x[nil] class x extends int {var x := 5}  var x := 5
for x := x.x[int [break] of nil].x to -for x := int {x = nil, x = ()} &x(break, ()) to x.x.x(x.x(), while 5 do "totor") do new int do let function x() = () var x := 5 var x := 5 in end
var x := while nil do 5 var x := "totor" var x := 5
function x(x : int, x : int) : int = int {x = -nil} 
for x := new int to (x[break].x()) do int [int [int {x = int {x = nil, x = nil} } ] of x.x.x()] of x.x[if break then "totor"].x()
class x {var x := 5}  function x(x : int) : int = int {x = "totor", x = ()}  class x extends int {} 
((x ; nil) ; new int ; int {x = 5} )
function x(x : int) : int = int ["totor"] of break+int {} 
int [let function x() = nil var x := 5 in end] of int {x = while if 5 then 5 else () do nil/break/let var x := 5 in nil end} 
var x : int := -5
let var x : int := nil function x() : int = () import "empty.tih" var x := 5 in x[break][let  in end] ; int {}  end
function x(x : int, x : int) = int {x = (5), x = int {x = (), x = 5} } 
-x.x.x.x
x.x.x.x[new int].x(if x["totor"][x := 5].x() then int {x = x["totor"].x(while () do break, let  in end)} , x(x.x.x := x(), x[nil].x.x()))
function x(x : int) = int {x = int {} } 
var x : int := let  in 5 end var x := nil var x := 5 import "empty.tih" var x := 5
while x() do let class x extends int {}  in if x() then x.x() else int {}  end
x()
var x : int := 5&"totor" class x extends int {var x := 5}  function x() : int = nil var x := 5 var x := 5
new int
type x = class {var x := 5}
class x extends int {var x := 5}  type x = array of int function x() : int = nil var x := 5
class x {var x := 5} 
int {} 
type x = class extends int{var x := 5}
x(int [x(x[nil].x(), if x := "totor" then int ["totor"] of 5 else int {x = break} )] of if x.x.x() then new int else int [new int] of ()-5, new int)
for x := x.x.x[x(x.x(break, 5), int [nil] of break)] := int {}  to for x := let import "empty.tih" in if nil then "totor" else "totor" ; 5 end to let import "empty.tih" in if "totor" then nil else break end do let var x := 5 in end+int {x = "totor"} *let  in end do let class x extends int {}  var x := 5 var x := 5 in end
class x {var x := 5 var x := 5} 
function x(x : int) = x.x.x(x((), break), x)
var x := let  in end
function x(x : int, x : int) = let var x := 5 in end
x((if x then int {}  else x()), x(x.x|int {x = x := (), x = int [5] of break} , if let var x := 5 in 5 end then x.x.x(x, int {x = 5, x = 5} ) else int {x = x()} ))
class x {var x := 5 var x := 5} 
int {x = for x := x.x[while nil do break].x(int {x = -break, x = let  in end} , let var x := 5 in break end) to x.x[x] := x.x := let  in end do (nil-nil ; 5), x = x.x.x[int {} *int {x = (), x = break} ].x()} 
x()
if while x[()].x := x(int [()] of 5, x.x()) do let var x := 5 in end then x.x[x][-for x := () to "totor" do ()].x() else if if int {x = int {} , x = int ["totor"] of ()}  then x[break] else x[()].x() then if x() then int {x = x.x()}  else int {x = for x := break to () do break, x = (5)}  else x(for x := let  in 5 end to "totor"-() do x, if while break do break then x() else x())
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
int {x = x.x.x[new int].x(int {x = new int, x = let var x := 5 in end} , x[nil][(5)].x())} 
function x(x : int) = -x.x() class x {var x := 5} 
class x {var x := 5} 
function x(x : int) : int = new int
x.x[x()].x[x.x[if nil then break].x()]
var x := x := nil function x(x : int) : int = x() var x := 5
class x {var x := 5}  class x {var x := 5}  function x() = nil
class x {var x := 5} 
int {} 
int {x = x()} 
var x := x.x(5, break) class x extends int {var x := 5} 
function x(x : int) : int = int {}  function x(x : int) : int = -()
x[()].x[x.x.x()].x
class x {var x := 5 var x := 5}  class x {var x := 5}  class x extends int {}  import "empty.tih" var x := 5
function x(x : int, x : int) : int = x["totor"] := let  in 5 end
var x := x
class x {var x := 5 var x := 5}  class x {var x := 5} 
class x extends int {var x := 5} 
function x(x : int, x : int) = if x() then x.x() else x()
class x extends int {var x := 5 var x := 5}  var x := "totor"
class x {var x := 5}  class x extends int {var x := 5} 
(int [int {x = x()} ] of int [let  in end] of int {x = ()}  ; x.x ; x.x(break, nil) ; break)
int {x = x[nil][for x := nil to "totor" do 5].x.x()} 
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = if "totor" then nil else nil class x {} 
class x extends int {var x := 5 var x := 5} 
(int {x = int {} }  ; while let  in end do x ; let  in end ; "totor")
int [x["totor"].x.x] of for x := while while int {x = (), x = break}  do if break then break else () do new int to x[break].x := -break&break do let var x := 5 in end+x["totor"]
x["totor"].x[x()].x.x()
type x = class extends int{var x := 5} type x = class extends int{}
type x = class {var x := 5}
if x(for x := (5 ; 5) to let var x := 5 in nil end do if int {x = nil, x = break}  then (5) else int {x = break} , (x := break)) then (let var x := 5 in end)
class x extends int {var x := 5} 
int {x = -new int} 
type x = class {var x := 5} class x {var x := 5} 
class x extends int {var x := 5 var x := 5}  type x = int
if int {x = (if () then 5 else break), x = int {x = int [let  in 5 end] of x.x(), x = x()} }  then (new int ; x)
class x extends int {var x := 5} 
x(-(5)|int {x = x, x = (5)} , int [x[()].x] of if int {}  then (break ; 5) else new int)
x[break][int {x = 5, x = "totor"} ].x[x[()].x()|x["totor"].x()].x()
let class x extends int {var x := 5}  in end
if (int {} ) then int {}  else x()
function x(x : int, x : int) = int {}  var x := 5 class x {} 
if int {}  then if (if 5 then nil) then if -5-nil then x() else x.x(nil, break)+while 5 do nil else let var x := 5 in end
x.x[while 5 do ()].x[x()].x(let var x := 5 in end, x["totor"].x.x)
let function x(x : int) = x var x := 5 import "empty.tih" var x := 5 in end
int [(for x := if () then nil to x := break do int {x = "totor"} )] of x()
class x extends int {var x := 5} 
var x := x.x()
x()
function x(x : int, x : int) : int = x(new int, let  in end) function x(x : int) = for x := () to () do 5
x.x[-()][let var x := 5 in nil ; 5 end][x()].x()
type x = array of int type x = int
function x(x : int, x : int) = x() type x = array of int type x = int import "empty.tih" var x := 5
var x := if "totor" then nil type x = {}
var x : int := x() function x(x : int) : int = int {x = "totor"}  class x extends int {}  import "empty.tih" var x := 5
int {x = int {x = int {x = if x.x() then int {x = nil}  else x()} , x = let var x := 5 var x := 5 in end} , x = x.x[for x := "totor" to () do 5][x()]} 
var x : int := if break then "totor" else ()
class x {var x := 5}  function x(x : int) = if () then break else ()
x[5][x()].x[int {} ]
function x(x : int, x : int) : int = (nil ; 5)
for x := new int to int {x = int {x = new int} }  do new int
function x(x : int, x : int) = (nil) class x {var x := 5} 
let function x(x : int) : int = x() in end
int {x = int {} } 
function x(x : int) : int = (break ; 5) function x(x : int) = while "totor" do () class x extends int {} 
let function x(x : int) : int = int {x = "totor"}  in x.x.x.x() ; (()) ; int [break] of break ; () end
function x(x : int) : int = new int function x(x : int) : int = -nil var x := 5
x[break].x.x[(())+x := nil+x()]
x.x[int {} ].x.x.x()
var x := int [()] of 5
type x = array of int function x(x : int) : int = let  in 5 end
function x(x : int) = let var x := 5 in end
var x := x((), break)
int {} 
var x := if 5 then nil else break
if x(while -break do int {} /int [int {x = nil} ] of int {x = nil} , -if x.x() then "totor"/"totor" else int {x = 5, x = ()} ) then x.x[x(nil, nil)][while -nil do int {x = break, x = ()} ]
var x := if "totor" then 5 else nil class x {var x := 5}  var x := 5 import "empty.tih" var x := 5
type x = class extends int{var x := 5} function x(x : int) : int = x()
var x : int := (5) function x(x : int) = if 5 then "totor"
class x extends int {var x := 5}  function x(x : int) : int = while break do nil
function x(x : int) = x(int {x = "totor"} , x.x())
(x())
type x = {x : int} var x := "totor"
function x(x : int) = x.x function x(x : int) = new int type x = int
function x(x : int, x : int) : int = int {x = "totor"} +x
type x = class extends int{var x := 5} class x extends int {var x := 5} 
function x(x : int) : int = int {x = for x := () to "totor" do ()} 
var x : int := x := 5
class x extends int {var x := 5 var x := 5}  function x(x : int) : int = -break
var x := if 5 then break else 5 class x {var x := 5} 
class x {var x := 5}  class x extends int {var x := 5}  type x = int
let type x = class {} in int {}  ; -x() end
class x {var x := 5 var x := 5}  class x {var x := 5} 
int {x = new int, x = int {x = if let  in end then x("totor", "totor")&x.x.x(x := break, int {x = nil, x = ()} )} } 
class x extends int {var x := 5} 
function x(x : int, x : int) = if (5) then if nil then "totor" else break else let  in end function x(x : int) = let  in 5 end type x = int
x[break][x].x.x
function x(x : int) : int = x() class x {var x := 5} 
type x = int
while while let import "empty.tih" var x := 5 in int [break] of "totor" ; 5 end do x(if int ["totor"] of 5 then for x := nil to 5 do () else if 5 then "totor" else nil, x[()].x()) do x(x(), while x()|for x := () to break do nil do let var x := 5 in break end)
function x(x : int) = int {x = new int} 
var x := int {x = break, x = 5} 
for x := for x := x[nil][int {} ].x() to x(int {} , x[nil].x()) do x.x.x()/for x := int [break] of break to x.x() do x(nil, 5) to x.x[int {x = nil, x = ()} ].x := x["totor"].x := while (5) do if () then break else 5 do for x := int {}  to x[break].x(int {x = nil} , x())&let var x := 5 in end do int {} 
function x(x : int, x : int) : int = new int
var x : int := while nil do nil
-x[nil][while break do break].x := int [let  in end] of if nil then () else break-int {x = int {x = break, x = nil} , x = -()} 
function x(x : int, x : int) = new int var x : int := 5 function x() : int = "totor" import "empty.tih"
var x : int := break|nil
class x {var x := 5} 
for x := if int {x = let var x := 5 in end}  then (while "totor" do ()) to int {x = new int&x.x := for x := nil to "totor" do "totor", x = for x := -x() to int {x = if () then "totor" else (), x = while nil do 5}  do for x := if 5 then () else 5 to x.x(break, ()) do x}  do x.x[x.x()] := let var x := 5 in break ; 5 end/x[()].x.x()
class x extends int {var x := 5}  function x(x : int) = x := break class x {}  var x := 5 var x := 5
type x = array of int
class x extends int {var x := 5 var x := 5} 
function x(x : int, x : int) : int = x[5].x(x := 5, x := ()) function x(x : int) : int = (5) function x() = nil
for x := let type x = int in end to -x(x.x.x((5), if 5 then nil), x.x.x(int {} , int {x = (), x = 5} )) do let var x := 5 var x := 5 in x.x ; (5) end
type x = int function x(x : int) : int = x.x(5, nil) class x extends int {} 
function x(x : int, x : int) = x.x()|if () then break else 5 function x(x : int) : int = x.x() function x() = break
int {} 
function x(x : int, x : int) = -let  in 5 end var x := 5 function x() = "totor"
class x {var x := 5 var x := 5}  type x = class {}
x(x.x.x.x, for x := x(x[5].x(x(), int {} ), while -5 do x.x(5, "totor")) to (x) do new int)
x(x[()][x(nil, break)][int {x = let  in end, x = for x := "totor" to break do nil} ].x(int [if x() then int {}  else for x := "totor" to 5 do "totor"] of x(x := 5, int {x = (), x = 5} ), if x["totor"] := if break then break else "totor" then x.x.x() else x.x), x.x.x[if () then 5*let  in end])
x.x[new int].x.x := -x()
while x(let var x := 5 var x := 5 in end, while x[nil].x() do new int) do while int {x = int {} , x = let var x := 5 in nil end}  do for x := if x() then int [5] of 5 to int [x(nil, ())] of break+() do while (5) do int [()] of 5
type x = array of int
class x extends int {var x := 5 var x := 5}  class x {var x := 5}  function x() : int = 5
function x(x : int, x : int) : int = int [5] of 5+"totor"|() class x extends int {var x := 5}  function x() : int = ()
x[5].x[x[5] := 5|break].x := if -x[5] := int {x = (), x = "totor"}  then for x := for x := int {}  to let  in end do int [break] of 5 to for x := new int to x.x(nil, "totor") do x.x(break, ()) do int {x = x()}  else x(if x.x() then int {x = nil, x = nil} , (() ; 5))
function x(x : int) = new int*-()
type x = {x : int}
int {} 
function x(x : int, x : int) : int = x.x
class x extends int {var x := 5}  class x extends int {var x := 5}  var x := 5
x(let import "empty.tih" in end, if int {x = int {} }  then x.x else x(int [nil] of break, new int))/int {} 
var x : int := x()
var x := x := nil
x[5].x.x.x.x()
var x := int [5] of "totor" type x = class extends int{}
function x(x : int) = x()-()-5 class x {var x := 5}  var x := 5
class x {var x := 5} 
class x extends int {var x := 5 var x := 5}  type x = class {}
x[5].x.x[int {x = int {x = int {x = "totor"} , x = while () do "totor"} } ] := if int {}  then let import "empty.tih" in end else let var x := 5 var x := 5 in for x := nil to nil do () ; 5 end
int {x = ((() ; 5) ; ()&"totor" ; "totor"), x = if x[break][x.x(nil, 5)] := let var x := 5 in end then x.x.x.x() else (let  in end)} 
if -x() then (int {} )
var x : int := x.x()
x.x.x.x[x.x.x.x()].x(while while if x := "totor" then let  in end else new int do while (5) do int {x = 5}  do x["totor"].x, x[nil][int {x = "totor"} ][("totor")].x(-if x.x() then x.x(), x(let var x := 5 in end, if x(break, 5) then let  in end else let  in end)))
if new int then new int
function x(x : int, x : int) = 5*"totor"-int ["totor"] of "totor"
-while x.x.x do int [if int {x = break, x = ()}  then if () then () else nil else let  in end] of int {} 
class x extends int {var x := 5 var x := 5} 
type x = class extends int{var x := 5} class x extends int {var x := 5}  class x extends int {} 
function x(x : int, x : int) = x((5), int {x = break, x = break} )
function x(x : int, x : int) = let var x := 5 in 5 ; 5 end class x {var x := 5} 
function x(x : int, x : int) = x[5].x(x := break, int [5] of break) var x : int := nil
var x := (5) type x = {}
var x := x := nil
function x(x : int, x : int) = x((5), for x := nil to 5 do ())
let function x(x : int) = x.x((), ()) type x = int var x := 5 in -int {}  ; for x := x to while 5 do () do int [5] of "totor" end
for x := x() to while x(if break then () else break, if () then nil) do if -"totor" then int {}  do x[()].x(x.x(), let  in 5 end)|x[()] := x.x("totor", 5)|-x[5][int {x = 5, x = nil} ].x(x[break].x(new int, (5)), let var x := 5 in nil ; 5 end)
class x extends int {var x := 5 var x := 5}  class x {var x := 5} 
x(int [int {x = -if 5 then "totor"} ] of if int {x = x.x(5, "totor"), x = -5}  then (break), let class x extends int {}  import "empty.tih" var x := 5 in end)
if if int [-()-()] of new int then int {}  then for x := for x := let var x := 5 in end to while x.x("totor", 5) do int {}  do int {x = new int}  to for x := x() to for x := ()-() to (5) do x.x() do if for x := break to 5 do break then for x := nil to () do break else x.x(break, nil) do while if 5 then "totor" else break&new int do int {x = int [()] of 5} 
x.x.x.x[x["totor"][x := break]].x()
int {x = while x[nil][int [5] of nil] do int {x = while ()/() do let  in end, x = for x := x to int {x = 5, x = nil}  do while break do 5} , x = x[nil].x.x := x.x := "totor"|break-(nil ; 5)} 
let var x : int := "totor" in end
class x extends int {var x := 5}  class x extends int {var x := 5}  function x() : int = () import "empty.tih"
int {x = x.x.x[x["totor"] := "totor"/nil] := x.x[int ["totor"] of ()] := x()} 
x.x[x("totor", ())][for x := for x := () to break do () to -nil do x()].x
if for x := x[nil].x := let var x := 5 in () end to int [int {x = x := break} ] of int {}  do -x.x.x(if "totor" then (), int [break] of nil) then x[()].x[int {} ]
class x extends int {var x := 5}  var x : int := nil
let function x(x : int) : int = new int in x.x.x := for x := -nil to x := nil do int {}  end
x.x.x.x[let import "empty.tih" var x := 5 in end]
if x["totor"].x.x := x[break].x then x() else x.x[int {} ][x()] := new int
int {x = if (-nil) then x() else let var x := 5 in break end-while while () do () do let  in end, x = int {x = x[nil].x := int {x = "totor"|nil, x = int {x = break} } , x = x(while int [()] of "totor" do nil*5, for x := x.x() to if () then nil else () do -nil)} } 
function x(x : int, x : int) : int = while let  in 5 end do let  in end
function x(x : int, x : int) : int = int [let  in 5 end] of int ["totor"] of break function x(x : int) : int = int [nil] of "totor" class x extends int {}  import "empty.tih" var x := 5
if if x["totor"].x.x(while int [()] of "totor" do while () do nil, if nil then "totor" else ()|"totor"/"totor") then int [x[break]] of int [int {x = (), x = ()} ] of while 5 do break else x(new int, int {x = int ["totor"] of nil, x = while "totor" do break} ) then let var x := 5 in -"totor" end/x.x[int {x = break, x = "totor"} ].x() else -(int {} )
class x {var x := 5} 
var x : int := int [nil] of 5
if x[5].x.x := let import "empty.tih" in end then -for x := x[()] := x.x() to int {}  do x.x else x["totor"][x(5, 5)].x.x(for x := x() to int {}  do (nil), x[nil].x.x())
while x[()].x.x := -x(x := "totor", new int) do int [int {x = let var x := 5 in end, x = x[nil].x(x(), x())} ] of int {x = let var x := 5 in "totor" end} 
function x(x : int, x : int) : int = x(x.x(), int {x = break, x = 5} )
type x = class {var x := 5}
int {x = x[nil].x[x.x.x()].x(if new int then x.x else x.x.x(), x["totor"].x)} 
while int {}  do x(let import "empty.tih" in int {}  ; break ; 5 end, int {} )
x.x.x[-x()].x := if if while for x := "totor" to "totor" do () do x.x() then while x("totor", nil) do (5) else x.x := x("totor", "totor") then x() else x.x+int {x = x()} 
class x {var x := 5 var x := 5} 
x.x.x.x[int {x = x[nil], x = int {x = x(), x = -break} } ]
if if let import "empty.tih" in new int end then x() then x(while x(5|(), let  in 5 end) do if nil then "totor"*x(5, break), int {} ) else -x()
for x := x() to x[()][let  in 5 end].x do if x.x.x := (nil ; 5) then let import "empty.tih" var x := 5 in end else let var x := 5 var x := 5 in -"totor" ; nil ; 5 end
x[()][let  in 5 end].x.x.x(let function x() = 5 var x := 5 var x := 5 in -()&break end, x[5].x[x[5].x(for x := 5 to break do (), int ["totor"] of ())])
type x = int
int {x = x.x[-5].x.x()} 
int {x = while (while nil do nil) do if int [x()] of x := nil then let var x := 5 in end} 
function x(x : int) = (5)
class x extends int {var x := 5 var x := 5}  function x(x : int) = let  in 5 end
var x : int := int {x = "totor", x = break}  type x = class {} var x := 5
int {} 
x(x.x[nil/()][x(let  in 5 end, if nil then "totor")].x(), x.x.x[int {x = x, x = x} ])
new int
function x(x : int, x : int) : int = x.x.x() var x : int := nil
(for x := x.x.x(x(), let  in 5 end) to int {}  do x.x.x())
var x := int {x = nil, x = "totor"} 
function x(x : int, x : int) : int = if let  in end then new int
class x {var x := 5} 
x()
class x extends int {var x := 5} 
class x {var x := 5} 
let type x = class {} class x {}  var x := 5 in end
x(x[5].x[x[nil]], new int)
var x := x((), break)
class x extends int {var x := 5}  function x(x : int) : int = new int
function x(x : int) : int = let var x := 5 in () ; 5 end class x extends int {var x := 5}  function x() = nil import "empty.tih"
if int {x = int {} , x = if x.x.x() then x(x(), x.x())}  then let type x = int import "empty.tih" in x.x := new int ; if break then 5 else nil end
var x : int := x := "totor" class x extends int {var x := 5} 
-int {} 
x["totor"][x][x.x.x()].x()|x()
function x(x : int) = (break)
function x(x : int) : int = x() function x(x : int) = int {x = break} 
x.x[if break then "totor"][while 5 do 5&for x := "totor" to break do break][int {x = while x.x(break, nil) do new int, x = int {} } ].x(int {x = int {x = x()} , x = if new int*x := 5 then (nil ; 5)} , (if int {x = (), x = break}  then new int))
class x extends int {var x := 5} 
